<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>project reactor切换线程导致内存溢出的坑</title>
    <link href="/2533120135.html"/>
    <url>/2533120135.html</url>
    
    <content type="html"><![CDATA[<h1 id="reactor会在很多地方使用到缓存，或者称为预取功能。但当上游生产的对象比较大想要减少预取的数量时可能会踩到坑，需要格外注意。"><a href="#reactor会在很多地方使用到缓存，或者称为预取功能。但当上游生产的对象比较大想要减少预取的数量时可能会踩到坑，需要格外注意。" class="headerlink" title="reactor会在很多地方使用到缓存，或者称为预取功能。但当上游生产的对象比较大想要减少预取的数量时可能会踩到坑，需要格外注意。"></a>reactor会在很多地方使用到缓存，或者称为预取功能。但当上游生产的对象比较大想要减少预取的数量时可能会踩到坑，需要格外注意。</h1><h2 id="事例代码"><a href="#事例代码" class="headerlink" title="事例代码"></a>事例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Flux.range(<span class="hljs-number">0</span>, <span class="hljs-number">10000</span>)<br>            .buffer(<span class="hljs-number">1</span>)<br>            <span class="hljs-comment">// 问题在这里</span><br>    .parallel(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>)<br>            .runOn(Schedulers.boundedElastic())<br>            .doOnNext(list -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;处理数据:&quot;</span> + list.size());<br>                <span class="hljs-comment">//模拟耗时</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">5000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>            &#125;)<br>            .checkpoint()<br>            .then()<br>            .block();<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中我们使用Flux.range模拟生产者，假设生产的对象大，比如说从db中查询数据，我们不希望一次性全部生产到内存中。</p><p>本意上我们使用parallel将处理分片为5分，通过runOn分配到5个线程中同时消费。而且 <code>parallel(5, 1)</code> 中的第二个参数控制了分片预取的数量为1，所以每次从上游最多取5个元素。</p><p>但是并没有达到预期内存直接爆了。下面是runOn的源码，<code>runOn</code> 操作符同样也有预取能力，我们不填第二个参数默认256个。而这个参数是每个通道的预取数量，也就是说不知不觉中预取了 5 * 256 &#x3D; 1280个元素，与我们原先设想的预取5个相差甚远。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ParallelFlux&lt;T&gt; <span class="hljs-title function_">runOn</span><span class="hljs-params">(Scheduler scheduler, <span class="hljs-type">int</span> prefetch)</span> &#123;<br>Objects.requireNonNull(scheduler, <span class="hljs-string">&quot;scheduler&quot;</span>);<br><span class="hljs-keyword">return</span> onAssembly(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ParallelRunOn</span>&lt;&gt;(<span class="hljs-built_in">this</span>,<br>scheduler,<br>prefetch,<br>Queues.get(prefetch)));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h2><p>同理再看一个publishOn的例子，我们只是期望切换消费者线程，但不知不觉中预取了 256个元素 (publishOn的第二个参数，默认从上游预取256个) ，从而可能与我们的预期相悖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Flux.range(<span class="hljs-number">0</span>, <span class="hljs-number">10000</span>)<br>            .buffer(<span class="hljs-number">1</span>)<br>            <span class="hljs-comment">//</span><br>            .publishOn(Schedulers.boundedElastic())<br>            .doOnNext(list -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;处理数据:&quot;</span> + list.size());<br>                <span class="hljs-comment">//模拟耗时</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">5000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>            &#125;)<br>            .checkpoint()<br>            .then()<br>            .block();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用reactor的多线程能力一定要注意预取控制，有些情况还是挺反预期的，最好自己指定第二个参数人工控制预取数量，否则可能导致预取数量引起oom。</p><p>还有一种 flatMap + publishOn的写法 , 利用 flatMap 控制并发数量和预取数量，同时内部使用 publishOn切换线程 （此时使用publishOn就无需指定预取数量了，因为只有一个)。 这种用法不会预取数量过多。</p><p>flatMap第一个参数会返回一个流，事例代码中限制从上游取5个生成5个子流，只有前一个流完成后才会向上游再申请数据，所以不存在对上游的预取。</p><p>flatMap的第三个参数prefetch值表示是从第一个参数的返回的子流中预取的数量，而不是从flatMap的上游预取的数量，如果返回的Mono本身不会产生大量的数据，不写也可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Flux.range(<span class="hljs-number">0</span>, <span class="hljs-number">10000</span>)<br>            .buffer(<span class="hljs-number">1</span>)<br>            .flatMap(list -&gt; Mono.fromRunnable(() -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;处理数据:&quot;</span> + list.size());<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">5000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>            &#125;).publishOn(Schedulers.boundedElastic())<br>       , <span class="hljs-number">5</span><br>               , <span class="hljs-number">1</span>)<br>            .blockLast();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>reactor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker使用macvlan获取独立ip</title>
    <link href="/2533120124.html"/>
    <url>/2533120124.html</url>
    
    <content type="html"><![CDATA[<h1 id="docker使用macvlan获取独立ip"><a href="#docker使用macvlan获取独立ip" class="headerlink" title="docker使用macvlan获取独立ip"></a>docker使用macvlan获取独立ip</h1><p>docker启动的容器会获取一个docker分配的内网ip，一般是172开头。现在想让容器内获取一个与宿主机同级别的ip，在路由器看来是两个独立的设备。</p><p>这里需要使用linux的 macvlan功能，他可以把物理网卡虚拟出来一个，让其拥有独立的mac地址，在路由器看来就是独立的设备。</p><p><a href="https://docs.docker.com/engine/network/drivers/macvlan/">docker macvlan的官方文档</a></p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ol><li>使用docker命令创建一个macvlan的网络<br>该命令会创建一个macvlan类型的network，同时指定子网和网关，parent表示绑定的物理网卡,macvlan-net未网络的名字</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker network create -d macvlan --subnet=192.168.1.0/24 --gateway=192.168.1.1 -o parent=enp2s0 macvlan-net<br><br>docker network ls #使用这个命令查看我们常见出来的network<br></code></pre></td></tr></table></figure><ol start="2"><li>启动docker容器，指定刚才创建的网络，并且指定了其IP地址（IP需要没有被使用）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --network=macvlan-net --rm --ip=192.168.1.200 --name=my-container -it alpine:latest /bin/sh<br></code></pre></td></tr></table></figure><p>上述两条命令执行完成后，容器启动起来后，可以测试网络是正常的。<br>同时打开路由器或光猫后台，能够看到192.168.1.200 作为一台独立的设备连接进来了。</p><h2 id="解决与宿主机不通的问题"><a href="#解决与宿主机不通的问题" class="headerlink" title="解决与宿主机不通的问题"></a>解决与宿主机不通的问题</h2><p>但是但是，基于安全考虑在Linux上macvlan与宿主机之间是不互通的。假设宿主机ip是 192.168.1.2他和 192.168.1.200之间相关ping不通。  </p><p>但是两个macvlan之间是互通的，因此我们可以这么做。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用linux命令创建一个macvlan-shim，同样绑定的物理网卡上</span><br>sudo ip link add macvlan-shim link enp2s0 type macvlan mode bridge<br><span class="hljs-meta prompt_"># </span><span class="language-bash">为macvlan-shim绑定一个ip，要求ip没有被使用过，并且与上面docker创建的不同</span><br>sudo ip addr add 192.168.1.210 dev macvlan-shim<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动该macvlan</span><br>sudo ip link set macvlan-shim up<br></code></pre></td></tr></table></figure><p>做完这些，这样我们宿主机上就有了三个网卡了：</p><ul><li>enp2s0 物理网卡，ip 192.168.1.2</li><li>macvlan-net 网卡，其中ip是 192.168.1.200 被分配给了docker容器内使用</li><li>macvlan-shim 网卡，其中ip是 192.168.1.210，宿主机使用</li></ul><p>宿主机ip与两个macvlan是不通的，但是macvlan之间可以通。</p><p>宿主机上添加一条路由表，表明192.168.1.200走macvlan-shim这个网卡，<br>又因为macvlan-shim网卡与macvlan-net是通的，他能找到 192.168.1.200这台机器，因此宿主机与容器网络打通了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo ip route add 192.168.1.200 dev macvlan-shim<br></code></pre></td></tr></table></figure><h2 id="拆除"><a href="#拆除" class="headerlink" title="拆除"></a>拆除</h2><p>不想要了把上面的配置都还原。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">移除宿主机的macvlan</span><br>sudo ip link set macvlan-shim down  # 下线接口<br>sudo ip addr delete 192.168.1.210/32 dev macvlan-shim #移除ip<br>sudo ip link delete macvlan-shim  #移除macvlan<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">移除docker的macvlan</span><br>docker stop &lt;xxx&gt;  # 停止容器<br>docker network ls  #查看网络接口<br>docker network rm macvlan-net #移除docker的macvlan<br></code></pre></td></tr></table></figure><h2 id="docker-compose配置"><a href="#docker-compose配置" class="headerlink" title="docker compose配置"></a>docker compose配置</h2><p>使用compose方式配置network，可以按照下面模板做修改。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">my_debian:</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">my_debian</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">debian:latest</span><br>    <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br>    <span class="hljs-attr">tty:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-attr">macvlan_network:</span><br>        <span class="hljs-attr">ipv4_address:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.200</span> <br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">macvlan_network:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">macvlan</span><br>    <span class="hljs-attr">driver_opts:</span><br>      <span class="hljs-attr">parent:</span> <span class="hljs-string">enp2s0</span><br>    <span class="hljs-attr">ipam:</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">subnet:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span><span class="hljs-string">/24</span><br>          <span class="hljs-attr">gateway:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>/etc/systemd/system和/lib/systemd/system的区别</title>
    <link href="/3242209425.html"/>
    <url>/3242209425.html</url>
    
    <content type="html"><![CDATA[<h1 id="etc-systemd-system和-lib-systemd-system的区别"><a href="#etc-systemd-system和-lib-systemd-system的区别" class="headerlink" title="&#x2F;etc&#x2F;systemd&#x2F;system和&#x2F;lib&#x2F;systemd&#x2F;system的区别"></a>&#x2F;etc&#x2F;systemd&#x2F;system和&#x2F;lib&#x2F;systemd&#x2F;system的区别</h1><p>记录一下这个问题：</p><p>我们系统里存在这两个目录都是可以存放systemd执行的配置文件的。他们有什么区别呢？</p><ul><li>&#x2F;etc&#x2F;systemd&#x2F;system</li><li>&#x2F;lib&#x2F;systemd&#x2F;system</li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>首先etc下面的优先级更高，也就说说存在同名的时候以etc下的优先，lib下的靠后。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>&#x2F;lib下的一般是安装软件时自动生成的，比如通过apt安装一个软件，他就可以在lib下面生成一个配置，从而使用systemd的守护能力。<br>&#x2F;etc下一般是管理员手工配置的，也就是我们人工配置到这里。</p><h3 id="启动配置"><a href="#启动配置" class="headerlink" title="启动配置"></a>启动配置</h3><p>但是但是，并不是放在这两个目录就会开机启动，而需要使用 <code>systemctl start xxx</code>把配置启动起来。</p><p>而这行命令的效果就是把你服务的配置文件在 <code>/etc/systemd/system/multi-user.target.wants</code>中创建一个软连接。没有在这个目录下创建软连接的服务配置，<br>是不会被开机启动的哦。</p><p>你打开<code>/etc/systemd/system/multi-user.target.wants</code>看一下哦，里面都是启动了的服务，并且都是软连接到前面两个目录下的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>目录</th><th>优先级</th><th>作用</th></tr></thead><tbody><tr><td>&#x2F;etc&#x2F;systemd&#x2F;system</td><td>高</td><td>存放systemd的配置文件,一般人工配置在这里</td></tr><tr><td>&#x2F;lib&#x2F;systemd&#x2F;system</td><td>低</td><td>存放systemd的配置文件，一般软件配置在这里</td></tr><tr><td>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants</td><td></td><td>存放开启了开机启动的服务的配置文件，一般软连接到上面两个目录</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>systemctl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何删除 syncthing 中忽略的文件</title>
    <link href="/1745260155.html"/>
    <url>/1745260155.html</url>
    
    <content type="html"><![CDATA[<h1 id="如何删除-syncthing-中忽略的文件"><a href="#如何删除-syncthing-中忽略的文件" class="headerlink" title="如何删除 syncthing 中忽略的文件"></a>如何删除 syncthing 中忽略的文件</h1><p>记录一下这个问题：</p><p>首先我又两台机器：</p><table><thead><tr><th>机器</th><th>作用</th></tr></thead><tbody><tr><td>PC</td><td>数据发送方</td></tr><tr><td>SERVER</td><td>中转或备份</td></tr></tbody></table><p>现在我有一些数据，先前是从PC同步到SERVER了的，后面我不想同步这些数据了。<br>如果我只是简单的增加忽略模式，那先前已经同步到SERVER上的并不会被删除。<br>按照下面步骤可以实现删除的效果，其实是利用了 <code>恢复本地改变</code> 的功能</p><h3 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h3><ol><li>PC端设置为仅发送，确保PC端不会被误删</li><li>SERVER设为仅接收，这很重要，因为我们将依靠恢复本地更改功能进行删除</li><li>在文件夹仍为仅接收的情况下，删除<code>SERVER</code>和<code>PC</code>的忽略模式。如果您只想删除部分文件，则只需删除要删除的文件的忽略模式。</li><li>这时SERVER端会出现”恢复本地改变”按钮，就能将服务器上多余的文件删除了</li><li>恢复先前的忽略模式</li></ol><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>因为我们把SERVER配置的<code>仅接收</code>，并且清除掉SERVER端的忽略模式的情况下，SERVER端就会保证和PC端保持一致，<br>如果服务端少的数据会从PC端补齐，如果SERVER多的数据就会删除。</p><h3 id="关于忽略模式："><a href="#关于忽略模式：" class="headerlink" title="关于忽略模式："></a>关于忽略模式：</h3><p>发送端的忽略模式是保证自己不将这些文件发送出去。<br>接受端的忽略模式是保证自己不接受这些文件。<br>建议配置成一样的，但也可以不一样哦，比如只配置发送端的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>syncthing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最近的反思</title>
    <link href="/1880172858.html"/>
    <url>/1880172858.html</url>
    
    <content type="html"><![CDATA[<h1 id="最近的反思"><a href="#最近的反思" class="headerlink" title="最近的反思"></a>最近的反思</h1><p>&emsp;&emsp;最近的工作状态不太好，做事情变得拖拉了，精力不足思考问题时感觉头脑不灵活了，尤其是工作到下午的时候犯困。<br>但是晚上10点多到家后反而有精神，平时上床后也得玩手机到12点半至1点才能睡觉，从而形成了恶性循环。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>&emsp;&emsp; 有哪些问题导致的我最近的变化呢？我将如何改变它：</p><ol><li><strong>儿子半夜醒来要抱，夜间睡觉要打断好几次，不能睡完整的觉。</strong><br>&emsp;&emsp;儿子小夜间醒来暂时不能解决，等大一点就能睡整觉了。但是我可以提前关手机提前睡觉，尽可能保证12点之后躺床上开始睡觉不再看手机。</li><li><strong>买股票了，花时间精力投入这上面</strong><br>&emsp;&emsp;购买的股票亏损了，每天地铁上都会看。患得患失耗费了精气神，把时间花费在这上面实在是没有必要，毕竟就买了一点钱亏损了也亏不到哪里去。所以呢我决定投资一些基金类的而不去买单只股票。这样的话平时也不需要过多关注这件事，偶尔逢低加仓逢高卖掉就行，不要让这件事情影响生活。</li><li><strong>沉迷抖音</strong><br>&emsp;&emsp;从十一放假开始，养成了刷抖音的习惯。坐地铁、上厕所、下班到家都会打开手机刷起来。而回头来看看的视频什么都记不住没有任何意义，躺在床上刷抖音会使自己更累并不能得到很好的休息。抖音已经存在78年了，有趣的事情很多根本就刷不完，还容易陷入信息茧房中。<br>&emsp;&emsp;并且当我频繁的看手机不能和家里人交流，导致我老婆也经常刷起视频来了，短视频慢慢的对我的家庭造成了腐蚀。我决定从今天起不再刷抖音，到家里多和家里人交流，一起看电视、讲话都可以。上班路上可以看一些B站有意义的视频、或者看一些实事、或者在论坛里划划水都可以。</li><li><strong>沉迷nas折腾</strong><br>&emsp;&emsp;购买nas2个月左右了，安装了debian系统。总想着折腾docker、折腾软件、折腾影音下载啥的，想要购买大硬盘，因为价格原因一直纠结耗费心神。<br>&emsp;&emsp;其实折腾了2个月，那些nas必备的同步、存储功能已经完全没问题了，再深入的折腾下去也没有意义。下载的电影制作的海报墙啥的平时工作也没有时间看，而且值得收藏的好电影也不多，因此我应该停手不要再继续折腾它了。<br>&emsp;&emsp;我虽然是程序员但平时与linux打交道也不多，我购买nas后没有安装市面上成品nas系统而选择了linux系统，在这个折腾的过程中其实也学到了很多。</li></ol><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>我要把更多时间投入到有意义的事情上：</p><ol><li><strong>持续学习</strong><br>&emsp;&emsp;学习会计相关的知识，学习linux系统、学习编程等等。工作结合学习，学以致用不断的投资自己。</li><li><strong>提升精力</strong><br>&emsp;&emsp;我已经很久没锻炼了，虽然现在年轻但是一坐一天后面肯定不行。并且平时的坐姿不规范，颈椎、腰、腿都出现了一些不好的症状，我要每周锻炼一次下楼跑步至少半小时以上逐渐的加强让自己的精力得到提升。</li><li><strong>减少内耗</strong><br>&emsp;&emsp;我想买硬盘很久了，思考问题一直纠结耗费了精力、不断内耗。但其实有没有活动也相差不到百八十块钱，与耗费的精力相比根本不值一提。<br>所以我以后做事要干脆利落一点，核心就是不要在一些事情上反复纠结，不要想着能够买到最低，做到最好，先出发迈出第一步才是最重要的</li></ol>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>费曼学习法</title>
    <link href="/2518805489.html"/>
    <url>/2518805489.html</url>
    
    <content type="html"><![CDATA[<h1 id="费曼学习法"><a href="#费曼学习法" class="headerlink" title="费曼学习法"></a>费曼学习法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp; <code>费曼</code>是一个获取过诺贝尔奖的人，他讲述了一种学习方法，通过这种方法可以让你比别人对事物的学习更快更透彻。  </p><h2 id="方法描述"><a href="#方法描述" class="headerlink" title="方法描述"></a>方法描述</h2><p>&emsp;&emsp;  费曼学习法可以简化为四个单词: Concept （概念）、Review （回顾）、Simplify （简化）、Teach （教给别人）。  </p><h2 id="方法步骤"><a href="#方法步骤" class="headerlink" title="方法步骤"></a>方法步骤</h2><h3 id="第一步：-假装把它（知识）交给一个小孩子"><a href="#第一步：-假装把它（知识）交给一个小孩子" class="headerlink" title="第一步： 假装把它（知识）交给一个小孩子"></a><strong>第一步： 假装把它（知识）交给一个小孩子</strong></h3><p>&emsp;&emsp;  拿一张白纸，在上面过写下你想要学习的主题。想一下，如果要把它教给一个孩子，你会讲哪些并写下来。这里你要教授的对象不是那些聪明的年轻人而是一个8岁的孩子，他的词汇量和知识是不能够理解那些行话和标准术语的。  </p><p>&emsp;&emsp; 许多人倾向于用复杂的词汇和行话来掩盖他们不明白的东西。问题是我们只是在糊弄自己，因为我们不知道自己不明白。另外，使用行话会隐藏周围人对我们的误解。  </p><p>&emsp;&emsp; 当你自始至终都用孩子可以理解的语言写出一个想法，那么你便迫使自己在更深层次上理解该概念，并简化了观点之间的关系和联系。如果你努力，就会清楚的知道自己哪里还有不明白的地方，这种紧张状态很好  –  预示着学习的机会来了。</p><h3 id="第二步：回顾"><a href="#第二步：回顾" class="headerlink" title="第二步：回顾"></a><strong>第二步：回顾</strong></h3><p>&emsp;&emsp; 在第一步中，你不可避免的卡壳，忘记重要的点，不能理解，或者不能将重要的概念联系起来。<br>这一反馈相当宝贵。因为你已经发现了自己知识的边缘。懂得自己能力的界限也是一种能力，你刚刚就确定了一个！  </p><p>&emsp;&emsp; 这是学习开始的地方。因为你知道自己在哪里卡住了，那么你回到原始材料重新学习，直到你可以用基本的术语解释这一概念。<br>认定自己知识的界限，会限制你可能犯的错误，并且在应用知识时，可以增加成功的机率。  </p><h3 id="第三步：将语言理化、简化"><a href="#第三步：将语言理化、简化" class="headerlink" title="第三步：将语言理化、简化"></a><strong>第三步：将语言理化、简化</strong></h3><p>&emsp;&emsp;  现在你手上有一套自己的手写笔记，检查一下并确保自己没有从原材料中借用任何行话。将这些笔记用最简单的语言组织成一个流畅的故事。  </p><p>将这些故事大声的读出来，如果这些解释不够简单，或者听起来比较混乱，很好，这意味着你想要理解该领域，还需要一些工作。</p><h3 id="第四步：传授"><a href="#第四步：传授" class="headerlink" title="第四步：传授"></a><strong>第四步：传授</strong></h3><p>&emsp;&emsp; 如果你真的想好确保你的理解没有问题，就把它传授给另一个（找一个不懂行的人，或者是一个8岁的孩子）。检测知识最终的途径是你能有能力将它传播给另一个人。  </p><p>这不仅是学习的妙方，还是窥探不同思维方式的窗口。他讲你的想法撕开揉碎，从头重组。这种学习方法会让你的观点和概念有更深入的理解。重要的是，以这种方式解决问题，你可以在别人不知道他们自己在说什么的情况下，理解这个问题。</p><hr><p>参考<a href="https://baike.baidu.com/item/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/50895393">百度百科</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shardingjdbc4.x初始化数据源过程</title>
    <link href="/227567824.html"/>
    <url>/227567824.html</url>
    
    <content type="html"><![CDATA[<h1 id="shardingjdbc4-x初始化数据源过程"><a href="#shardingjdbc4-x初始化数据源过程" class="headerlink" title="shardingjdbc4.x初始化数据源过程"></a>shardingjdbc4.x初始化数据源过程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>看过好几遍了老是忘记，idea点击配置时总是跳转到DataSourceUtil中引起误解。所以我这次要把他记录下来。  </p></blockquote><hr><p>使用shardingjdbc4.x配置数据源时，一般我们是这个配置的。那他背后是如何将数据源创建出来的呢，下面请看源码。  </p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs properties"><br><span class="hljs-attr">spring.shardingsphere.datasource.names</span>=<span class="hljs-string">ds0,ds1</span><br><br><span class="hljs-attr">spring.shardingsphere.datasource.ds0.type</span>=<span class="hljs-string">com.zaxxer.hikari.HikariDataSource</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds0.driver-class-name</span>=<span class="hljs-string">software.aws.rds.jdbc.mysql.Driver</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds0.jdbc-url</span>=<span class="hljs-string">jdbc:mysql:127.0.0.1:3306/xxx?useUnicode=true&amp;characterEncoding=utf-8&amp;transformedBitIsBoolean=true&amp;allowMultiQueries=true&amp;useSSL=false</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds0.username</span>=<span class="hljs-string">username</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds0.password</span>=<span class="hljs-string">password</span><br><br><span class="hljs-attr">spring.shardingsphere.datasource.ds1.type</span>=<span class="hljs-string">com.zaxxer.hikari.HikariDataSource</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds1.driver-class-name</span>=<span class="hljs-string">software.aws.rds.jdbc.mysql.Driver</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds1.jdbc-url</span>=<span class="hljs-string">jdbc:mysql:127.0.0.1:3306/xxx?useUnicode=true&amp;characterEncoding=utf-8&amp;transformedBitIsBoolean=true&amp;allowMultiQueries=true&amp;useSSL=false</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds1.username</span>=<span class="hljs-string">username</span><br><span class="hljs-attr">spring.shardingsphere.datasource.ds1.password</span>=<span class="hljs-string">password</span><br></code></pre></td></tr></table></figure><hr><p>这里我们使用Hikari连接池初始化了两个名称为ds0,ds1的数据源。下面解释下他背后是怎么配置数据源的</p><p>首先在：<code>org.apache.shardingsphere.shardingjdbc.spring.boot.SpringBootConfiguration</code> 类中有下面这样一段代码</p><p>他会从环境中查找 <code>spring.shardingsphere.datasource.names</code>前缀的配置，也就是我们上面的配置的两个数据源名字，逗号分隔<br>然后依次将每个数据源名称前面拼接上 <code>spring.shardingsphere.datasource.</code>前缀开始查找配置，并使用 <code>DataSourceUtil</code>工具类将数据源反射创建出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEnvironment</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Environment environment)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;spring.shardingsphere.datasource.&quot;</span>;<br>    <span class="hljs-keyword">for</span> (String each : getDataSourceNames(environment, prefix)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            dataSourceMap.put(each, getDataSource(environment, prefix, each));<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> ReflectiveOperationException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShardingSphereException</span>(<span class="hljs-string">&quot;Can&#x27;t find datasource type!&quot;</span>, ex);<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> NamingException namingEx) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShardingSphereException</span>(<span class="hljs-string">&quot;Can&#x27;t find JNDI datasource!&quot;</span>, namingEx);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">getDataSourceNames</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Environment environment, <span class="hljs-keyword">final</span> String prefix)</span> &#123;<br>    <span class="hljs-type">StandardEnvironment</span> <span class="hljs-variable">standardEnv</span> <span class="hljs-operator">=</span> (StandardEnvironment) environment;<br>    standardEnv.setIgnoreUnresolvableNestedPlaceholders(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> == standardEnv.getProperty(prefix + <span class="hljs-string">&quot;name&quot;</span>)<br>            ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">InlineExpressionParser</span>(standardEnv.getProperty(prefix + <span class="hljs-string">&quot;names&quot;</span>)).splitAndEvaluate() : Collections.singletonList(standardEnv.getProperty(prefix + <span class="hljs-string">&quot;name&quot;</span>));<br>&#125;<br>  <br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">private</span> DataSource <span class="hljs-title function_">getDataSource</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Environment environment, <span class="hljs-keyword">final</span> String prefix, <span class="hljs-keyword">final</span> String dataSourceName)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException, NamingException &#123;<br>    Map&lt;String, Object&gt; dataSourceProps = PropertyUtil.handle(environment, prefix + dataSourceName.trim(), Map.class);<br>    Preconditions.checkState(!dataSourceProps.isEmpty(), <span class="hljs-string">&quot;Wrong datasource properties!&quot;</span>);<br>    <span class="hljs-keyword">if</span> (dataSourceProps.containsKey(jndiName)) &#123;<br>        <span class="hljs-keyword">return</span> getJndiDataSource(dataSourceProps.get(jndiName).toString());<br>    &#125;<br>    <span class="hljs-type">DataSource</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> DataSourceUtil.getDataSource(dataSourceProps.get(<span class="hljs-string">&quot;type&quot;</span>).toString(), dataSourceProps);<br>    DataSourcePropertiesSetterHolder.getDataSourcePropertiesSetterByType(dataSourceProps.get(<span class="hljs-string">&quot;type&quot;</span>).toString()).ifPresent(<br>        dataSourcePropertiesSetter -&gt; dataSourcePropertiesSetter.propertiesSet(environment, prefix, dataSourceName, result));<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><hr><p>DataSourceUtil根据指定的dataSourceClassName反射创建数据源，在赋值属性时，会根据属性名查找set方法，并对一些基本类型做转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-meta">@NoArgsConstructor(access = AccessLevel.PRIVATE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceUtil</span> &#123;<br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SET_METHOD_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;set&quot;</span>;<br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Collection&lt;Class&lt;?&gt;&gt; GENERAL_CLASS_TYPE;<br>  <br>    <span class="hljs-keyword">static</span> &#123;<br>        GENERAL_CLASS_TYPE = Sets.newHashSet(<span class="hljs-type">boolean</span>.class, Boolean.class, <span class="hljs-type">int</span>.class, Integer.class, <span class="hljs-type">long</span>.class, Long.class, String.class, Collection.class);<br>    &#125;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Get data source.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataSourceClassName data source class name</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataSourceProperties data source properties</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> data source instance</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ReflectiveOperationException reflective operation exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataSource <span class="hljs-title function_">getDataSource</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String dataSourceClassName, <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; dataSourceProperties)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException &#123;<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (DataSource) Class.forName(dataSourceClassName).newInstance();<br>        <span class="hljs-keyword">for</span> (Entry&lt;String, Object&gt; entry : dataSourceProperties.entrySet()) &#123;<br>            callSetterMethod(result, getSetterMethodName(entry.getKey()), <span class="hljs-literal">null</span> == entry.getValue() ? <span class="hljs-literal">null</span> : entry.getValue().toString());<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getSetterMethodName</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String propertyName)</span> &#123;<br>        <span class="hljs-keyword">if</span> (propertyName.contains(<span class="hljs-string">&quot;-&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> CaseFormat.LOWER_HYPHEN.to(CaseFormat.LOWER_CAMEL, SET_METHOD_PREFIX + <span class="hljs-string">&quot;-&quot;</span> + propertyName);<br>        &#125;<br>        <span class="hljs-keyword">return</span> SET_METHOD_PREFIX + String.valueOf(propertyName.charAt(<span class="hljs-number">0</span>)).toUpperCase() + propertyName.substring(<span class="hljs-number">1</span>);<br>    &#125;<br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callSetterMethod</span><span class="hljs-params">(<span class="hljs-keyword">final</span> DataSource dataSource, <span class="hljs-keyword">final</span> String methodName, <span class="hljs-keyword">final</span> String setterValue)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; each : GENERAL_CLASS_TYPE) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> dataSource.getClass().getMethod(methodName, each);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-type">boolean</span>.class == each || Boolean.class == each) &#123;<br>                    method.invoke(dataSource, Boolean.valueOf(setterValue));<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-type">int</span>.class == each || Integer.class == each) &#123;<br>                    method.invoke(dataSource, Integer.parseInt(setterValue));<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-type">long</span>.class == each || Long.class == each) &#123;<br>                    method.invoke(dataSource, Long.parseLong(setterValue));<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Collection.class == each) &#123;<br>                    method.invoke(dataSource, Arrays.asList(setterValue.split(<span class="hljs-string">&quot;,&quot;</span>)));<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    method.invoke(dataSource, setterValue);<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> ReflectiveOperationException ignored) &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>shardingjdbc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux的dns解析</title>
    <link href="/3456619767.html"/>
    <url>/3456619767.html</url>
    
    <content type="html"><![CDATA[<h1 id="linux的dns解析"><a href="#linux的dns解析" class="headerlink" title="linux的dns解析"></a>linux的dns解析</h1><p>dns是我们最常用的功能，他就是实现一个目的，域名转换成ip，在linux系统中如何配置最好呢。</p><h2 id="最简单的dns"><a href="#最简单的dns" class="headerlink" title="最简单的dns"></a>最简单的dns</h2><p>系统默认会查找 <code>/etc/resolv.conf</code> 文件查找dns，所以我只要修改该文件就能改变系统使用的dns,像下面这样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www ~]# vim /etc/resolv.conf<br>nameserver 168.95.1.1<br>nameserver 139.175.10.20<br></code></pre></td></tr></table></figure><p>但是这种做法非常的不灵活。而且基本没法做动态管理， 因此 <code>systemd-resolved.service</code>出来了</p><hr><h2 id="systemd-resolved-service"><a href="#systemd-resolved-service" class="headerlink" title="systemd-resolved.service"></a>systemd-resolved.service</h2><p>看他的名字就能看出来，这是一个比较官方的实现,且很多系统预先已经安装了，它实现的功能很简单。</p><p>如果有些系统没有的话可以使用命令安装:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install systemd-resolved<br></code></pre></td></tr></table></figure><p>他做了这么几件事</p><ol><li>在本地53端口搭建一个dns服务器，将接收到的dns请求转发给配置的上游dns</li><li>修改resolv.conf文件指向127.0.0.1,也就是将系统dns指向systemd-resolved.service</li><li>提供了一些命令行，支持通过命令改dns之类的能力</li></ol><p>使用这个命令也能看到53已经被systemd-recolved监听了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@armbian:/$ sudo lsof -i:53<br>COMMAND       PID            USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME<br>systemd-r 1461065 systemd-resolve   17u  IPv4 5663216      0t0  UDP localhost:domain <br>systemd-r 1461065 systemd-resolve   18u  IPv4 5663217      0t0  TCP localhost:domain (LISTEN)<br></code></pre></td></tr></table></figure><p>有了他的代理就可以做一些灵活的事情了.<br>下面是他的配置文件，DNS字段用空格分隔多个上游dns，DNSOverTLS参数可以指定使用ssh协议加密dns数据，支持缓存啦等能力。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"> <span class="hljs-built_in">cat</span> /etc/systemd/resolved.conf</span><br><br>[Resolve]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Some examples of DNS servers <span class="hljs-built_in">which</span> may be used <span class="hljs-keyword">for</span> DNS= and FallbackDNS=:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Cloudflare: 1.1.1.1 1.0.0.1 2606:4700:4700::1111 2606:4700:4700::1001</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Google:     8.8.8.8 8.8.4.4 2001:4860:4860::8888 2001:4860:4860::8844</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Quad9:      9.9.9.9 2620:fe::fe</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">DNS=</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">FallbackDNS=</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">Domains=</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">DNSSEC=no</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">DNSOverTLS=no</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">MulticastDNS=<span class="hljs-built_in">yes</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">LLMNR=<span class="hljs-built_in">yes</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">Cache=<span class="hljs-built_in">yes</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">DNSStubListener=<span class="hljs-built_in">yes</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">DNSStubListenerExtra=</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">ReadEtcHosts=<span class="hljs-built_in">yes</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">ResolveUnicastSingleLabel=no</span><br></code></pre></td></tr></table></figure><hr><h2 id="smartdns或者dnsmasq"><a href="#smartdns或者dnsmasq" class="headerlink" title="smartdns或者dnsmasq"></a>smartdns或者dnsmasq</h2><p>systemd-resolved.service 基本满足了我们的需求，但是还不够我们要一些更加强大的能力比如说：</p><ul><li>DOT,DOH</li><li>定制缓存能力，  比如某些网站的dns不缓存</li><li>不同的域名使用不同的dns进行解析，比如国内网站走114.114.114.114,国外网站走8.8.8.8</li><li>智能选择速度最快的地址，比如一个网站返回多个ip，智能选择一个速度最快的</li><li>广告过滤， 拦截某些广告的地址，这样就变相拦截了广告</li></ul><p>等等啦这些功能，单纯 <code>systemd-resolved.service</code>就不够用了。我们引入 <code>smartdns</code>来实现上面的功能。<br><code>dnsmasq</code>与<code>smartdns</code>类似。</p><p>官网文档：<a href="https://pymumu.github.io/smartdns/install/linux/">smartdns官网文档</a></p><p>smartdns也是在本地53端口开启了一个dns服务器，并且将请求转发给他的上游dns。实现原理上与 <code>systemd-resolved.service</code>是没有区别的。<br>不过针对请求的处理上它实现了更多的功能，具体看官网介绍吧。<br>不过有一点是既然都是监听53端口所以会与 <code>systemd-resolved.service</code>冲突, 安装完成后将 <code>systemd-resolved.service</code>关闭掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemct stop systemd-resolved.service<br>sudo systemct disable systemd-resolved.service<br>sudo systemct restart smartdns #重启smartdns<br></code></pre></td></tr></table></figure><p><strong>smartdns代理上游dns时可以使用 DOT、DOH 访问，所以解决了域名污染问题。</strong></p><p>smartdns的配置文件在 <code>/etc/smartdns</code>目录下。下面做一些简单介绍,  细节的看官网文档非常的详细:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs shell">root:$ cat /etc/smartdns/smartdns.conf <br><span class="hljs-meta prompt_"># </span><span class="language-bash">dns服务器的名称，友好展示，可以不配</span><br>server-name bf_smartdns<br><span class="hljs-meta prompt_"># </span><span class="language-bash">引入外部配置文件，相当于把指定的配置文件copy到当前配置文件中</span><br>conf-file /etc/smartdns/anti-ad-smartdns.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">绑定 tcp，udp的53端口，默认只监听了udp，有些程序会使用到tcp所以把tcp的监听也打开了</span><br>bind [::]:53<br>bind-tcp [::]:53<br><span class="hljs-meta prompt_"># </span><span class="language-bash">既然是tcp， 那就有超时时间，配置60秒</span><br>tcp-idle-time 60<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">dns缓存的数量</span><br>cache-size 16384<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">强制指定 qtype 返回 SOA</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">force specific qtype <span class="hljs-built_in">return</span> soa</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">force-qtype-SOA [qtypeid |...]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">force-qtype-SOA 65 28</span><br>force-qtype-SOA 65<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">支持双栈，即支持ipv4和ipv6</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Enable IPV4, IPV6 dual stack IP optimization selection strategy</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">dualstack-ip-selection-threshold [num] (0~1000)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">dualstack-ip-allow-force-AAAA [<span class="hljs-built_in">yes</span>|no]</span><br>dualstack-ip-selection yes<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置日志，日志在 /var/log/smartdns/smartdns.log</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">set</span> <span class="hljs-built_in">log</span> level</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">log-level: [level], level=fatal, error, warn, notice, info, debug</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">log-file: file path of <span class="hljs-built_in">log</span> file.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">log-size: size of each <span class="hljs-built_in">log</span> file, support k,m,g</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">log-num: number of logs, 0 means <span class="hljs-built_in">disable</span> <span class="hljs-built_in">log</span></span><br>log-level info<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">log-file /var/log/smartdns/smartdns.log</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">log-size 128k</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">log-num 2</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">log-file-mode [mode]: file mode of <span class="hljs-built_in">log</span> file.</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这一块是配置上游的dns，使用普通udp协议访问，因为我是用了DOH 所以这了没做配置</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">remote udp dns server list</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">server [IP]:[PORT] [-blacklist-ip] [-whitelist-ip] [-check-edns] [-group [group] ...] [-exclude-default-group]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">default port is 53</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  -blacklist-ip: filter result with blacklist ip</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  -whitelist-ip: filter result whth whitelist ip,  result <span class="hljs-keyword">in</span> whitelist-ip will be accepted.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  -check-edns: result must exist edns RR, or discard result.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  -group [group]: <span class="hljs-built_in">set</span> server to group, use with nameserver /domain/group.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  -exclude-default-group: exclude this server from default group.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">server 8.8.8.8 -blacklist-ip -check-edns -group g1 -group g2</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">server 114.114.114.114</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">remote tcp dns server list</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">server-tcp [IP]:[PORT] [-blacklist-ip] [-whitelist-ip] [-group [group] ...] [-exclude-default-group]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">default port is 53</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">server-tcp 8.8.8.8</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这一块是配置上游的dns，但是使用tls加密的即支持DOT的dns， 因为我是用了DOH 所以这了没做配置</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">remote tls dns server list</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">server-tls [IP]:[PORT] [-blacklist-ip] [-whitelist-ip] [-spki-pin [sha256-pin]] [-group [group] ...] [-exclude-default-group]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  -spki-pin: TLS spki pin to verify.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  -tls-host-verify: cert hostname to verify.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  -host-name: TLS sni hostname.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  -no-check-certificate: no check certificate.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Get SPKI with this <span class="hljs-built_in">command</span>:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">   <span class="hljs-built_in">echo</span> | openssl s_client -connect <span class="hljs-string">&#x27;[ip]:853&#x27;</span> | openssl x509 -pubkey -noout | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | openssl enc -<span class="hljs-built_in">base64</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">default port is 853</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">server-tls 8.8.8.8</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">server-tls 1.0.0.1</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">这一块是配置上游dns，使用https协议的，即 DOH</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">remote https dns server list</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">server-https https://[host]:[port]/path [-blacklist-ip] [-whitelist-ip] [-spki-pin [sha256-pin]] [-group [group] ...] [-exclude-default-group]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  -spki-pin: TLS spki pin to verify.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  -tls-host-verify: cert hostname to verify.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  -host-name: TLS sni hostname.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  -http-host: http host.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  -no-check-certificate: no check certificate.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">default port is 443</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">server-https https://cloudflare-dns.com/dns-query</span><br>server-https https://223.5.5.5/dns-query<br>server-https https://1.12.12.12/dns-query<br>server-https https://doh.opendns.com/dns-query<br>server-https https://101.101.101.101/dns-query<br></code></pre></td></tr></table></figure><p>好啦，下面是从smartdns官网拷贝的介绍，功能是非常灵活的。</p><blockquote><p>  多虚拟DNS服务器<br>支持多个虚拟DNS服务器，不同虚拟DNS服务器不同的端口，规则，客户端。<br>  多 DNS 上游服务器<br>支持配置多个上游 DNS 服务器，并同时进行查询，即使其中有 DNS 服务器异常，也不会影响查询。<br>  支持每个客户端独立控制<br>支持基于MAC，IP地址控制客户端使用不同查询规则，可实现家长控制等功能。<br>  返回最快 IP 地址<br>支持从域名所属 IP 地址列表中查找到访问速度最快的 IP 地址，并返回给客户端，提高网络访问速度。<br>  支持多种查询协议<br>支持 UDP、TCP、DOT 和 DOH 查询及服务，以及非 53 端口查询；支持通过socks5，HTTP代理查询;<br>  特定域名 IP 地址指定<br>支持指定域名的 IP 地址，达到广告过滤效果、避免恶意网站的效果。<br>  域名高性能后缀匹配<br>支持域名后缀匹配模式，简化过滤配置，过滤 20 万条记录时间 &lt; 1ms。<br>  域名分流<br>支持域名分流，不同类型的域名向不同的 DNS 服务器查询，支持iptable和nftable更好的分流；支持测速失败的情况下设置域名结果到对应ipset和nftset集合。<br>  Windows &#x2F; Linux 多平台支持<br>支持标准 Linux 系统（树莓派）、OpenWrt 系统各种固件和华硕路由器原生固件。同时还支持 WSL（Windows Subsystem for Linux，适用于 Linux 的 Windows 子系统）。<br>  支持 IPv4、IPv6 双栈<br>支持 IPv4 和 IPV 6网络，支持查询 A 和 AAAA 记录，支持双栈 IP 速度优化，并支持完全禁用 IPv6 AAAA 解析。<br>  支持DNS64<br>支持DNS64转换。<br>  高性能、占用资源少<br>多线程异步 IO 模式，cache 缓存查询结果。<br>  主流系统官方支持<br>主流路由系统官方软件源安装smartdns。</p></blockquote><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ol><li><p>ali的223.5.5.5不建议使用，有些网站解析出的域名是错误的。建议使用cloudflare的配合缓存也不会慢的。  </p></li><li><p>重启smartdns可以用这个命令 <code>sudo systemctl stop smartdns &amp;&amp; sleep 1 &amp;&amp; sudo rm -f /tmp/smartdns.cache &amp;&amp; sudo systemctl start smartdns</code>  </p></li><li><p>有些doh可以用这样进行测试<code>curl -H &#39;accept: application/dns-json&#39; &#39;https://1.1.1.1/dns-query?name=www.google.com&amp;type=A&#39;</code>  </p></li><li><p>如果发现不生效可以再检查下resolve.conf文件，有时候重启机器后可能里面配置的127.0.0.1会被改成网关的192.168.1.1，怀疑是dhcp服务在修改它</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>搞事情</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>dns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker配置使用ipv6</title>
    <link href="/750222647.html"/>
    <url>/750222647.html</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp; 现在家庭宽带基本都有公网的ipv6地址了，本篇介绍如何让容器内获取到ip6地址，这里说的ip6地址不是从路由器获取的公网地址而是由docker分配的内网地址。<br>当容器内的程序向外部发送消息时docker会进行转换，因此这个地址虽然不能被外部访问，但是可以访问外部也是有价值的。</p><h1 id="1-检查本地的ipv6是否正确"><a href="#1-检查本地的ipv6是否正确" class="headerlink" title="1.检查本地的ipv6是否正确"></a>1.检查本地的ipv6是否正确</h1><p>使用下面命令尝试ping和curl试试能否成功，不成功代表本地的ipv6没配置好。如果宿主机都不能使用ipv6那容器获取ipv6也没用了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping6 ipv6.baidu.com<br>curl https://speed.neu6.edu.cn/getIP.php<br></code></pre></td></tr></table></figure><p>下面是我的<code>/etc/network/interfaces</code>配置文件,指明了enp2s0网卡的ipv6为auto。 这样配置我可以获取到ipv6地址了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">This file describes the network interfaces available on your system</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">and how to activate them. For more information, see interfaces(5).</span><br><br>source /etc/network/interfaces.d/*<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">The loopback network interface</span><br>auto lo<br>iface lo inet loopback<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">The primary network interface</span><br>auto enp2s0<br>allow-hotplug enp2s0<br>iface enp2s0 inet dhcp<br>iface enp2s0 inet6 auto<br></code></pre></td></tr></table></figure><h1 id="2-配置docker使用ipv6"><a href="#2-配置docker使用ipv6" class="headerlink" title="2.配置docker使用ipv6"></a>2.配置docker使用ipv6</h1><p>下面是我的docker配置文件, ipv6表示启用ipv6, ip6tables,experimental 设为 true。fixed-cidr-v6是容器内的内网地址，和上面的172.31是一种用途。<br>修改后记得重启docker <code>sudo systemctl restart docker</code></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"> hcy@debian:/$ cat /etc/docker/daemon.json <br>&#123;<br>  &quot;bip&quot;: &quot;172.31.0.1/24&quot;,<br>  &quot;ipv6&quot;: true,  <br>  &quot;fixed-cidr-v6&quot;: &quot;2001:db8:1::/64&quot;,<br>  &quot;experimental&quot;: true,<br>  &quot;ip6tables&quot;: true,  <br>  &quot;data-root&quot;: &quot;/var/lib/docker/&quot;,<br>  &quot;log-level&quot;: &quot;warn&quot;,<br>  &quot;log-driver&quot;: &quot;json-file&quot;,<br>  &quot;log-opts&quot;: &#123;<br>     &quot;max-size&quot;: &quot;10m&quot;,<br>     &quot;max-file&quot;: &quot;5&quot;<br>   &#125;,<br>   &quot;registry-mirrors&quot;: [<br>      &quot;https://hub.docker.com&quot; <br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-配置docker-compose文件"><a href="#3-配置docker-compose文件" class="headerlink" title="3.配置docker-compose文件"></a>3.配置docker-compose文件</h1><p>在原先的compose文件中，指明启用ipv6,注意networks是根元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">services:<br>  app:<br>    image: xxx<br>    volumes:<br>      - config.json:/config.json<br>    ports:<br>      - &#x27;30011:30011&#x27;<br>    restart: always<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里是需要增加的</span><br>networks:<br>  default:<br>    enable_ipv6: true<br></code></pre></td></tr></table></figure><h1 id="4-下线并重新上线服务"><a href="#4-下线并重新上线服务" class="headerlink" title="4. 下线并重新上线服务"></a>4. 下线并重新上线服务</h1><p>服务重新上线后，使用下面手段判断ipv6能否使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it xxx /bin/sh  #进入容器内部<br>ifconfig                     #查看容器内已经可以获取到ipv6了<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ping或者curl ipv6的网站能够成功</span><br>ping6 ipv6.baidu.com<br>curl https://speed.neu6.edu.cn/getIP.php<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.docker.com/engine/daemon/ipv6/">https://docs.docker.com/engine/daemon/ipv6/</a><br><a href="https://fariszr.com/docker-ipv6-setup-with-propagation/">https://fariszr.com/docker-ipv6-setup-with-propagation/</a></p><p>文章中说到的添加<code>default-address-pools</code>我没有配置，经测试也是可以的</p>]]></content>
    
    
    <categories>
      
      <category>搞事情</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker compose 安装 ZeroTier 客户端</title>
    <link href="/2141418386.html"/>
    <url>/2141418386.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-compose文件"><a href="#1-compose文件" class="headerlink" title="1. compose文件"></a>1. compose文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">name: zerotier<br>services:<br>  zerotier-one:<br>    image: zerotier/zerotier:latest<br>    container_name: zerotier-one<br>    restart: always<br>    cap_add:<br>      - NET_ADMIN<br>      - SYS_ADMIN<br>      - CAP_SYS_RAWIO<br>    devices:<br>      - /dev/net/tun:/dev/net/tun<br>    network_mode: host<br>    volumes:<br>      - ./zerotier-one:/var/lib/zerotier-one<br></code></pre></td></tr></table></figure><h2 id="2-启动容器"><a href="#2-启动容器" class="headerlink" title="2. 启动容器"></a>2. 启动容器</h2><p>上面文件同目录下执行，如果默认 docker-compose.yml 可直接执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker compose up -d<br></code></pre></td></tr></table></figure><h2 id="3-替换-planet（非自建根服务器跳过）"><a href="#3-替换-planet（非自建根服务器跳过）" class="headerlink" title="3. 替换 planet（非自建根服务器跳过）"></a>3. 替换 planet（非自建根服务器跳过）</h2><blockquote><p>自建根服务器参考：<a href="https://github.com/xubiaolin/docker-zerotier-planet">https://github.com/xubiaolin/docker-zerotier-planet</a>  </p></blockquote><p>进入目录.&#x2F;zerotier-one 替换 planet 文件</p><h2 id="4-重启-zerotier-one-服务（非自建跳过）"><a href="#4-重启-zerotier-one-服务（非自建跳过）" class="headerlink" title="4. 重启 zerotier-one 服务（非自建跳过）"></a>4. 重启 zerotier-one 服务（非自建跳过）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it zerotier-one service zerotier-one restart<br></code></pre></td></tr></table></figure><h2 id="5-加入网络"><a href="#5-加入网络" class="headerlink" title="5. 加入网络"></a>5. 加入网络</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it zerotier-one zerotier-cli join 网络 id<br></code></pre></td></tr></table></figure><p>end</p><blockquote><p>参考:<br>   <a href="https://github.com/xubiaolin/docker-zerotier-planet">https://github.com/xubiaolin/docker-zerotier-planet</a><br>   <a href="https://hub.docker.com/r/zerotier/zerotier">https://hub.docker.com/r/zerotier/zerotier</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>搞事情</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zeroTier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决emby无法删除文件问题</title>
    <link href="/2055878545.html"/>
    <url>/2055878545.html</url>
    
    <content type="html"><![CDATA[<p>emby不能删除文件就是权限问题。<br>查看emby是哪个用户执行的，要么把emby的执行用户改成文件的用户，要么把文件改为emby执行的用户。<br>只要有权限肯定能删掉的  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 首先进入容器内部</span><br>docker exec -it emby /bin/sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 查看emby服务使用哪个用户执行的，可以看到emby是由bin用户执行的</span><br><span class="hljs-meta prompt_">/# </span><span class="language-bash">ps  ps -ef</span> <br>PID   USER     TIME  COMMAND<br>    1 root      0:00 s6-svscan -t0 /var/run/s6/services<br>   32 root      0:00 s6-supervise s6-fdholderd<br>  171 root      0:00 s6-supervise emby-server<br>  174 root      0:00 sh ./run<br>  196 bin       0:14 /system/EmbyServer -programdata /config -ffdetect /bin/ffdetect -ffmpeg /bin/ffmpeg -ffprobe /bin/ffprobe -restartexitcode 3<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 回到宿主机，查看镜像看为啥使用bin执行呢</span><br>docker image inspect lovechen/embyserver<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">4. 结果太多我就不全部粘贴了，在Env下面可以看到镜像指定了 UID=2，GID=2,而2在我的系统里就是用户bin</span><br> &quot;Env&quot;: [<br> &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,<br> &quot;LANG=en_US.UTF-8&quot;,<br> &quot;HOME=/tmp&quot;,<br> &quot;AMDGPU_IDS=/share/libdrm/amdgpu.ids&quot;,<br> &quot;FONTCONFIG_PATH=/etc/fonts&quot;,<br> &quot;LD_LIBRARY_PATH=/lib:/system&quot;,<br> &quot;LIBVA_DRIVERS_PATH=/lib/dri&quot;,<br> &quot;OCL_ICD_VENDORS=/etc/OpenCL/vendors&quot;,<br> &quot;PCI_IDS_PATH=/share/hwdata/pci.ids&quot;,<br> &quot;SSL_CERT_FILE=/etc/ssl/certs/ca-certificates.crt&quot;,<br> &quot;UID=2&quot;,<br> &quot;GID=2&quot;,<br> &quot;GIDLIST=2&quot;,<br> &quot;NVIDIA_VISIBLE_DEVICES=all&quot;,<br> &quot;NVIDIA_DRIVER_CAPABILITIES=compute,video,utility&quot;,<br> &quot;XDG_CACHE_HOME=/config/cache&quot;<br>],<br></code></pre></td></tr></table></figure><hr><p>找到了问题解决就简单了。修改compose文件覆盖上面两个属性,在我的盒子上，我是使用root执行的因此将UID，GID覆盖成0  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">emby:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">lovechen/embyserver:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">emby</span><br>    <span class="hljs-attr">network_mode:</span> <span class="hljs-string">host</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">UID=0</span>  <span class="hljs-comment">#覆盖镜像中的 2</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">GID=0</span><br>    <span class="hljs-attr">devices:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/dev/dri:/dev/dri</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/docker/emby/emby-config:/config</span>   <span class="hljs-comment"># 配置目录</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/mnt/sharefile:/sharefile</span>              <span class="hljs-comment"># 资源挂载目录</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">&#x27;unless-stopped&#x27;</span><br>    <span class="hljs-attr">extra_hosts:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;host.docker.internal:host-gateway&quot;</span><br></code></pre></td></tr></table></figure><hr><p>ok 下线掉容器再重新up，可以正常删除了。 进入容器内部也发现emby是已我们配置的root角色执行的。<br>因为我是一台电视盒子自己用我没有创多用户，自己根据自己的情况调整用户就行</p>]]></content>
    
    
    <categories>
      
      <category>搞事情</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>emby</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024-08-30-gitea安装</title>
    <link href="/1253497344.html"/>
    <url>/1253497344.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>自己搭建一个git服务端防止电脑突然损坏代码数据丢失。一个人用的话可以选择gitea、gogs都可以。下面讲安装过程。</p><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><h3 id="2-1-启动容器"><a href="#2-1-启动容器" class="headerlink" title="2.1 启动容器"></a>2.1 启动容器</h3><p>首先按照这个compose启动容器，启动后打开网页3000端口会让你初始化。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">gitea:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">server:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">gitea/gitea:1.22.1</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">gitea</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">USER_UID=1000</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">USER_GID=1000</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">gitea</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/docker/gitea/data:/data</span>  <span class="hljs-comment"># 映射一个本地磁盘，配置和仓库都在里面</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/etc/timezone:/etc/timezone:ro</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/etc/localtime:/etc/localtime:ro</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;20000:3000&quot;</span> <span class="hljs-comment"># 网页端 、http拉代码用的端口， 3000不要动，前面的任意修改</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;222:22&quot;</span>     <span class="hljs-comment"># ssl 监听的端口 ， 22不要动，前面的任意修改</span><br></code></pre></td></tr></table></figure><p>启动页面我没有截图，稍微看一下基本不用改什么。因为一个人用，数据库选择sqlite3就可以了。他会创建一个用户名为 <code>git</code>作为ssh的user，与gitea的管理员没关系，所以不用修改。</p><h3 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h3><p>初始时是没有账户的，在页面上自己注册一个就好，第一个用户就是管理员。</p><ol><li>配置ssh展示端口：<br>&emsp;&emsp;在docker映射的data目录下找到这个 <code>/opt/docker/gitea/data/gitea/conf/app.ini</code>配置文件，在  <code>server </code>下面修改 <code>SSH_PORT</code>字段的值为docker映射出来的值。我这里是 222 ,他决定了页面展示的端口，容器内的ssh仍然监听的是22端口不受影响。</li></ol><p><img src="/img/in/2024-08-30-gitea%E5%AE%89%E8%A3%85/1725017785653.png" alt="1725017785653"></p><ol start="2"><li>配置ssh密钥：<br>&emsp;&emsp; 首先生成一个ssh密钥,生成流程中密码就不要输入了，不然后面每次连接都要输入密码很麻烦。默认会将生成<code>id_rsa, id_rsa.pub</code> 放在用户目录下的<code>.ssh</code>文件夹下。</li></ol><p>使用这个命令生成密钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p>在页面上点击用户头像，将公钥(.pub的那个)文本打开粘贴进去。<br><img src="/img/in/2024-08-30-gitea%E5%AE%89%E8%A3%85/image.png" alt="alt text"></p><ol start="3"><li><p>拉取代码：<br>&emsp;&emsp;  接下来页面上创建一个仓库就可以正常拉取代码了。</p></li><li><p>使用代理：<br>&emsp;&emsp;  你要像我一样不想暴露到公网可以配置代理服务，git配置代理的方式看我这篇文章<br>《<a href="https://www.huangchaoyu.com/2538332822.html/">git 设置代理拉取代码</a>》</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>搞事情</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gitea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>和解了 netty butebuf释放问题暂时解决不了</title>
    <link href="/416866345.html"/>
    <url>/416866345.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;我先前写了一个代理软件，纯netty写的使用起来没问题。因为先前看了reacto-netty想要应用一下，结果总是出现bytebuf没有主动释放但是refCnt变成0的问题。<br>被这个问题折磨一个星期了，解决不了总在我的脑子里挥之不去，记录下来暂时放一放吧等后面有时间在想。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>数据的正向流程是这样的</p><p><strong>data -&gt; AesGcmHandler -&gt; SsProtocolHandler -&gt; ChannelOperationsHandler</strong></p><p>其中AesGcmHandler继承自 ByteToMessageCodec 负责解密，他会输出一个新的PooledBytebuf向下游传递</p><p>SsProtocolHandler继承自 ReplayingDecoder，他会识别数据流，从中解析出目标ip和端口，识别成功后将自身移除，后续数据流不通过它</p><p>ChannelOperationsHandler 是reactor-netty框架内的，他会将数据桥接到内部的FluxReceive中，支持背压，数据会缓存到FluxReceive内部的queue中。</p><p>这里我遇到的问题是，上游SsProtocolHandler传递了数据缓冲到FluxReceive中，此时通过断点看出refCnt是1,等到下游consume请求数据时，queue中的数据refCnt变成0了。<br>为了排查这个问题我将上游传递的Butebuf进行wrap向下传递，queue中存储的数据确实是我wrap后的buf，断点查看这个wrapBuf的release方法发现release方法也没有被调用，但是等到程序执行到从queue中取数时，取出来的wrapBuf的refCnt是0。<br>我无法找打是在哪里释放的，并且因为netty线程绑定的原因，整个流程是发生在同一个线程上的。</p><p>reactory-netty内部逻辑我也做了分析，他只是将数据缓存在queue中，让我最理解不了的点是为什么release方法没有被调用的情况下refCnt数量会减少。<br>我有点怀疑是netty的bug，也许是他的池化内存有bug，其他暂时没有思路。</p><p>问题复现比较随机，但是能够稳定复现，批量发起多次请求的情况下一定可以出现。</p><hr><p>这个问题我已经排查了一个星期了，暂时先放弃</p><p><img src="/img/in/2024-08-28%E5%92%8C%E8%A7%A3%E4%BA%86nettybutebuf%E9%87%8A%E6%94%BE%E9%97%AE%E9%A2%98%E6%9A%82%E6%97%B6%E8%A7%A3%E5%86%B3%E4%B8%8D%E4%BA%86/1724822804202.png" alt="1724822804202"></p>]]></content>
    
    
    
    <tags>
      
      <tag>bug</tag>
      
      <tag>netty</tag>
      
      <tag>project-reactor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客搭建</title>
    <link href="/2949367309.html"/>
    <url>/2949367309.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>最近把博客从jelly迁移到hexo了,个人感觉页面美观了很多。并且插件也多了很多，下面将我操作的过程记录下来。</p><p>hexo是使用node开发的，事先安装好node，版本尽量高一些。</p><h3 id="2-安装hexo"><a href="#2-安装hexo" class="headerlink" title="2. 安装hexo"></a>2. 安装hexo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo<br></code></pre></td></tr></table></figure><p>这里我没有选择安装到全局</p><h3 id="3-初始化blog"><a href="#3-初始化blog" class="headerlink" title="3. 初始化blog"></a>3. 初始化blog</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">npx hexo init blog<br>cd blog<br>npm install<br></code></pre></td></tr></table></figure><h3 id="4-文章迁移"><a href="#4-文章迁移" class="headerlink" title="4. 文章迁移"></a>4. 文章迁移</h3><p>  将文章和图片复制到_post中，同时修改_config.yml配置文件中这行配置，指定文章命名格式</p><blockquote><p>new_post_name: :year-:month-:day-:title.md</p></blockquote><h3 id="5-安装主题"><a href="#5-安装主题" class="headerlink" title="5. 安装主题"></a>5. 安装主题</h3><p> 我选择安装<a href="https://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81">fluid主题</a>，安装方式有两种，选择安装方式二，将其源码下载下来放在themes文件夹下，重命令为fluid</p><p>_config.fluid.yml为主题的配置文件，优先级比themes文件下的_config.fluid.yml高，所以不要改动themes文件夹下的东西，不然后期升级很麻烦</p><h3 id="6-配置"><a href="#6-配置" class="headerlink" title="6. 配置"></a>6. 配置</h3><p> _config.yml中指定主题和语言</p><blockquote><p> theme: fluid  # 指定主题<br> language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改</p></blockquote><h3 id="7-创建关于页"><a href="#7-创建关于页" class="headerlink" title="7. 创建关于页"></a>7. 创建关于页</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npx hexo new page about<br></code></pre></td></tr></table></figure><h3 id="8-启动预览"><a href="#8-启动预览" class="headerlink" title="8. 启动预览"></a>8. 启动预览</h3><p>执行 <code>npx hexo clean; npx hexo g; npx hexo s;</code> 编译运行，打开本地4000端口预览下是否能够展示出来，<br>按照fluid主题的配置指南调整博客细节，比如说更换title，更换首页图片等</p><h3 id="9-推送到github"><a href="#9-推送到github" class="headerlink" title="9. 推送到github"></a>9. 推送到github</h3><p><a href="https://hexo.io/docs/">官方文档发布页</a>中描述了两种方式部署到github,<br>一种是将整个项目推送到github,使用github action编译成博客，<br>一种是将本地编译好的html (整个public目录)推送到github,源码保存在本地。</p><p>我是用了第二种方式,因为我不想将原始的md文件暴露出去,选择安装了 <code>hexo deploy</code>插件,通过执行 <code>npx hexo clean; npx hexo g; npx hexo deploy</code>命令,直接清理\编译\推送一步搞定。</p><h3 id="10-实用插件"><a href="#10-实用插件" class="headerlink" title="10. 实用插件"></a>10. 实用插件</h3><p><a href="https://hexo.io/plugins/">官方插件页</a>提供了很多插件可以使用,每个插件的文档都比较详细,选择自己需要的即可。我这里用到了</p><ul><li>hexo-generator-sitemap 插件，生成全局网站地图</li><li>hexo-abbrlink 为每篇文章生成唯一链接，这样后面文件名改名后链接也不改变。生成的数字是持久化在文章上的，所以后期文章名称改变了也不影响文章的地址，效果如图。</li></ul><p><img src="/img/in/2024-08-19-hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/1724072407587.png" alt="1724072407587"></p><p><img src="/img/in/2024-08-19-hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/1724072462714.png" alt="1724072462714"></p>]]></content>
    
    
    <categories>
      
      <category>搞事情</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rclone和alist文件加密问题</title>
    <link href="/2266882737.html"/>
    <url>/2266882737.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>本地的文件或者nas上的文件希望上传到网盘上，以防止本地磁盘损坏造成的数据丢失。同时又不想让网盘能够看到我们私有的照片，因此这里用到了rclone或者alist的文件加密功能。</p><h3 id="2-描述"><a href="#2-描述" class="headerlink" title="2.描述"></a>2.描述</h3><p>alist 提供了网盘挂载能力，他可以将支持的网盘挂载为 webdav协议，这样我们就可以脱离官方的客户端很方便的操纵网盘的文件了。<br>rclone 是remote clone的意思，他的功能挺多的，我通过rclone sync命令行可以让本地文件和远程文件(支持webdav)进行同步，以达到备份的目的。<br>同时rclone支持在与远程连接之间增加一层加密管道，原始文件写入管道自动加密，文件从管道读出自动解密。这样就能让我们的数据在云端处于加密状态，本次访问时可以实时解密，操作起来就像是没有加密一样，十分的方便。</p><p>rclone + alist 组合使用即很方便的将文件从本地加密同步到网盘。</p><h3 id="3-加密"><a href="#3-加密" class="headerlink" title="3.加密"></a>3.加密</h3><blockquote><p>下面是我没弄明白的地方，虽然我按照这么操作实现了目的，但是我并不知原理，后面我有时间再研究下。</p></blockquote><p>新版的alist同样也提供了加密的功能，并且借鉴了rclone的做法，与rclone使用相同的算法。也就是说在密码一致的情况下，rclone加密的文件alist能解密，alist加密的文件rclone能解密，使用起来十分的方便。</p><p>但是alist对密码做了处理，直接拿rclone的密文配置到alist中是不行的，或者相同的明文密码配置到alist中也不行。我参考了<a href="https://github.com/alist-org/alist/issues/5544">github</a>上这个提问。按照其中说的配置后可以生效。</p><h4 id="3-1-具体操作"><a href="#3-1-具体操作" class="headerlink" title="3.1 具体操作"></a>3.1 具体操作</h4><ol><li>查看rclone配置的密码和盐，文件在用户目录的.config下，其中的密码和密码2就是我们需要的的密码和盐，是以密文形式存储的。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /home/user/.config/rclone/<br><br>user@debian:~/.config/rclone$ cat rclone.conf <br>[kuake_se_wrap]   # 夸克网盘的加密包装器<br>type = crypt<br>remote = kuake:kuake_se_wrap<br>filename_encryption = off<br>directory_name_encryption = false<br>password = 密码<br>password2 = 盐<br><br></code></pre></td></tr></table></figure><ol start="2"><li>配置alist<br>将rclone的密码和盐前面增加 <code>___Obfuscated___</code>前缀粘贴到alist网页配置端的密码和盐位置上就可以了。我猜测是alist检测到 <code>___Obfuscated___</code>前缀就直接保存，而没有前缀的会进行加密。<br>进过我的验证，密码直接输入原始的明文密码或者前缀+rclone密文密码都可以。</li></ol><p><img src="/img/in/2024-08-26-rclone%E5%92%8Calist%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E9%97%AE%E9%A2%98/1724605012416.png" alt="1724605012416"></p><h4 id="3-2-一些资料"><a href="#3-2-一些资料" class="headerlink" title="3.2 一些资料"></a>3.2 一些资料</h4><p>(rclone的加密部分的文档)[<a href="https://rclone.org/crypt/]">https://rclone.org/crypt/]</a></p>]]></content>
    
    
    <categories>
      
      <category>搞事情</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rclone</tag>
      
      <tag>alist</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ss-rust安装</title>
    <link href="/3256892802.html"/>
    <url>/3256892802.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>想在外面访问家里局域网，但是又不想暴露在公网上。正好家里有公网ip，安装这个正合适。</p><p>ss-libev 已经不再更新了，推荐使用ss-rust。下面将安装过程记录下来。</p><p>安装方式有两种</p><ul><li>systemctl方式安装</li><li>docker安装</li></ul><p>推荐用docker，毕竟直接准备一个compose文件非常的方便。  </p><h3 id="2-systemctl方式安装"><a href="#2-systemctl方式安装" class="headerlink" title="2. systemctl方式安装"></a>2. systemctl方式安装</h3><h4 id="2-1-下载可执行文件"><a href="#2-1-下载可执行文件" class="headerlink" title="2.1 下载可执行文件"></a>2.1 下载可执行文件</h4><p>从<a href="https://github.com/shadowsocks/shadowsocks-rust/releases">下载页</a>获取对应的可执行文件，我有一台x86pc，还有一台arm盒子刷的debian。<br>我先用电视盒子做测试，因此我下载了<code>shadowsocks-v1.20.4.aarch64-unknown-linux-gnu.tar.xz</code>文件在系统上，根据自己的系统自行决定下载哪个。<br>使用<code>uname -m</code>命令看机器的版本信息。  </p><p>下载完成后执行<code>tar -xvf shadowsocks-v1.20.4.aarch64-unknown-linux-gnu.tar.xz</code>将文件解压出来，里面包含客户端、管理端啥的，只保留<code>ssserver</code>其余都可以删掉。  </p><h4 id="2-2-配置ss"><a href="#2-2-配置ss" class="headerlink" title="2.2 配置ss"></a>2.2 配置ss</h4><p>选一个位置创建一个配置文件<code>config.json</code>,里面内容如下,对应修改端口、密码、加密方式即可</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;server&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;0.0.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;server_port&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">10000</span><span class="hljs-punctuation">,</span>    # 修改<br>    <span class="hljs-attr">&quot;password&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;123456&quot;</span><span class="hljs-punctuation">,</span>    # 修改<br>    <span class="hljs-attr">&quot;method&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;aes-128-gcm&quot;</span><span class="hljs-punctuation">,</span> # 修改  <br>    <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">120</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;mode&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;tcp_and_udp&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;fast_open&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;nameserver&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;8.8.8.8&quot;</span>  #可以修改或删掉<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="2-3-配置系统服务"><a href="#2-3-配置系统服务" class="headerlink" title="2.3 配置系统服务"></a>2.3 配置系统服务</h4><p>创建一个系统服务配置，并按照下面说明配置好  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /etc/systemd/system<br>touch ss-rust.service<br>vi ss-rush.service<br></code></pre></td></tr></table></figure><p>把下面这段配置粘贴进去,需要改的地方是ExecStart，修改成你的执行文件路径和配置文件路径</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>= Shadowsocks Rust Service<br><span class="hljs-attr">After</span>=network-<span class="hljs-literal">on</span>line.target<br><span class="hljs-attr">Wants</span>=network-<span class="hljs-literal">on</span>line.target systemd-networkd-wait-<span class="hljs-literal">on</span>line.service<br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">LimitNOFILE</span>=<span class="hljs-number">32767</span> <br><span class="hljs-attr">Type</span>=simple<br><span class="hljs-attr">User</span>=root<br><span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure<br><span class="hljs-attr">RestartSec</span>=<span class="hljs-number">5</span>s<br><span class="hljs-attr">DynamicUser</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">ExecStartPre</span>=/bin/sh -c <span class="hljs-string">&#x27;ulimit -n 51200&#x27;</span><br><span class="hljs-attr">ExecStart</span>=/opt/shadowsocks/ssserver -c /opt/shadowsocks/config.json<br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><h4 id="2-4-启动系统服务"><a href="#2-4-启动系统服务" class="headerlink" title="2.4 启动系统服务"></a>2.4 启动系统服务</h4><p>启动成功日志会输出出来，看看日志没啥其他错就是启动成功了。<br>用手机客户端连接下试试，理论是OK的<br>可以用这个<a href="http://v6t.ipip.net/">网站</a> 测试下自己的ipv6情况  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable ss-rust  # 允许开机自启<br>systemctl start ss-rust   # 启动服务<br>systemctl status ss-rust  # 查看状态<br>journalctl -u ss-rust -f  # 查看日志<br></code></pre></td></tr></table></figure><h4 id="2-5-卸载"><a href="#2-5-卸载" class="headerlink" title="2.5 卸载"></a>2.5 卸载</h4><p>如果想卸载可按照这个方式停止并删除即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop ss-rust<br>systemctl disable ss-rust<br>rm -rf /etc/systemd/system/ss-rust.service<br></code></pre></td></tr></table></figure><h4 id="3-参考文档"><a href="#3-参考文档" class="headerlink" title="3. 参考文档"></a>3. 参考文档</h4><p>我参考了这个<a href="https://github.com/xOS/Shadowsocks-Rust">一键安装脚本</a>，但是没有直接用这个脚本</p><h3 id="4-docker安装"><a href="#4-docker安装" class="headerlink" title="4. docker安装"></a>4. docker安装</h3><p>config.json和上面是一致的， 我直接贴出来compose文件，<br>但是我的机器上docker的ip6没搞定，所以客户端那里如果有转发ip6的开关记得关掉不然很多优先使用ip6的会连不上。  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;100&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">shadowsocks:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">ghcr.io/shadowsocks/ssserver-rust:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">shadowsocks-rust</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/shadowsocks/config.json:/etc/shadowsocks-rust/config.json</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;30005:30005&#x27;</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>搞事情</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shadowsocks-rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>samba使用指定用户挂载磁盘</title>
    <link href="/3943455212.html"/>
    <url>/3943455212.html</url>
    
    <content type="html"><![CDATA[<p>以普通用户1000的身份挂载smb，不然默认是root用户，普通用户没办法修改文件或删除文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mount -t cifs \<br>-o username=root,password=1234,iocharset=utf8,uid=1000,gid=1000 <br>//192.168.1.2/share_file /mnt/smb<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>搞事情</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>samba</tag>
      
      <tag>smb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>N1盒子折腾</title>
    <link href="/2723250432.html"/>
    <url>/2723250432.html</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近购买了一个N1盒子玩玩,虽然这个盒子的cpu性能已经过时了,而且还是usb2.0的,实测传输速度只有40mb左右。<br>但是这个在网上很流行，教程和固件非常多可玩性比较高。那些路由器系统我没有兴趣，我买它是为了刷armbian的，又在拼夕夕上花了30块钱买一块500g的2.5寸硬盘，配合ddns做一个远程下载机还是挺不错的。</p><h2 id="1-安装系统"><a href="#1-安装系统" class="headerlink" title="1. 安装系统"></a>1. 安装系统</h2><p><a href="https://github.com/ophub/amlogic-s9xxx-armbian">armbian的下载地址在这里</a>,选择晶晨S9xx版本的包。推荐使用bullseye的版本对应debian11,<br>bookworm对应debian12但是毕竟咱盒子硬件比较旧了，选择前一个版本的固件更稳定一些。</p><p>用Rufus把系统镜像写入u盘，插入盒子上电自动就能从u盘启动了。在u盘启动的armbian中执行 <code>armbian-install</code>将系统写入盒子闪存中。重启后拔掉u盘重启后就安装成功了。</p><h2 id="2-磁盘挂载"><a href="#2-磁盘挂载" class="headerlink" title="2. 磁盘挂载"></a>2. 磁盘挂载</h2><p>机器只有8g内存，安装完系统可用6g左右，我在usb上挂着一个2.5寸硬盘。<br>首先使用 <code>lsblk</code>命令查看磁盘挂载情况，外接磁盘一般是sda，我这边只有一个分区，因此sda1就是我的磁盘，后面的&#x2F;mnt&#x2F;sharefile是我的挂载点，刚开始时是没有的。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">root@armbian:~<span class="hljs-comment"># lsblk</span><br>NAME         MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT<br>sda            8:0   <span class="hljs-number"> 0 </span>298.1G <span class="hljs-number"> 0 </span>disk <br>└─sda1         8:1   <span class="hljs-number"> 0 </span>298.1G <span class="hljs-number"> 0 </span>part /mnt/sharefile<br>mmcblk2      179:0   <span class="hljs-number"> 0 </span>  7.3G <span class="hljs-number"> 0 </span>disk <br>├─mmcblk2p1  179:1   <span class="hljs-number"> 0 </span>  511M <span class="hljs-number"> 0 </span>part /boot<br>└─mmcblk2p2  179:2   <span class="hljs-number"> 0 </span>  6.5G <span class="hljs-number"> 0 </span>part /<br>mmcblk2boot0 179:32  <span class="hljs-number"> 0 </span>    4M <span class="hljs-number"> 1 </span>disk <br>mmcblk2boot1 179:64  <span class="hljs-number"> 0 </span>    4M <span class="hljs-number"> 1 </span>disk <br>zram0        254:0   <span class="hljs-number"> 0 </span>   50M <span class="hljs-number"> 0 </span>disk /var/log<br></code></pre></td></tr></table></figure><p>磁盘挂载步骤</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkfs.ext4 /dev/sda  # 格式化磁盘为ext4格式<br>mkdir /mnt/sharefile # 创建空文件夹作为挂载点<br>mount -v /dev/sda1 /mnt/sharefile # 挂载<br>lsblk # 查看是否挂载成功<br></code></pre></td></tr></table></figure><p>但是这种挂载方式是临时挂载，重启就要重新做挂载，通过修改fstab可以做到系统启动自动挂载。<br>首先通过blkid命令查询硬盘uuid，因为前面的名字sda是系统生成的，再插入一块硬盘第二块就是sdb、sdc等等，不是固定的。如果你的两个usd插口都插了硬盘下次哪个在前哪个在后就不能确定了。<br>但是uuid是与硬盘绑定的，只要你不对硬盘进行分区，不进行格式化，他的uud相对是固定的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@armbian:~# blkid<br>/dev/mmcblk2p2: LABEL=&quot;ROOTFS_EMMC&quot; UUID=&quot;305f8c97-3156-491a-93b6-56ba0ca87ee3&quot; BLOCK_SIZE=&quot;4096&quot; TYPE=&quot;ext4&quot;<br>/dev/mmcblk2p1: LABEL_FATBOOT=&quot;BOOT_EMMC&quot; LABEL=&quot;BOOT_EMMC&quot; UUID=&quot;5933-954E&quot; BLOCK_SIZE=&quot;512&quot; TYPE=&quot;vfat&quot;<br>/dev/sda1: UUID=&quot;09ef634f-5af8-f24e-9497-b668e4fbc413&quot; BLOCK_SIZE=&quot;4096&quot; TYPE=&quot;ext4&quot; PARTLABEL=&quot;Linux data partition&quot; PARTUUID=&quot;825c0d80-6904-43c2-abe0-ac0e0060d9f0&quot;<br>/dev/zram0: LABEL=&quot;log2ram&quot; UUID=&quot;e96a98e0-5366-4843-9dd8-2a8aee06f61f&quot; BLOCK_SIZE=&quot;4096&quot; TYPE=&quot;ext4&quot;<br></code></pre></td></tr></table></figure><p>可以看到我的硬盘的UUID&#x3D;”09ef634f-5af8-f24e-9497-b668e4fbc413”，格式是ext4<br>备份然后编辑 &#x2F;etc&#x2F;fstab 文件，在原先的后面增加一行配置，一共6段数据，中间使用空格分割（几个空格没关系）<br>第一段填写UUID，不需要引号引用<br>第二段填写挂在点，提前创建好文件夹<br>第三段填写磁盘格式，这里是ext4<br>第四段填写 <code>defaults,nofail</code>，nofail 可以防止磁盘不可用时系统启动不起来<br>第五段六段填写 0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">UUID=09ef634f-5af8-f24e-9497-b668e4fbc413    /mnt/sharefile    ext4    defaults,nofail    0    0<br></code></pre></td></tr></table></figure><p>配置完成后先将上面测试用的挂载去掉<br>    umount &#x2F;mnt&#x2F;sharefile<br>然后执行：<br>    mount -a<br>如果没有报错，并且 lsblk 命令再次查看能够挂载成功则说明我们配置的 fstab是没错的。如果报错了或者没有成功则说明fstab配置的有问题，请将备份配置文件还原回去，再检查下是不是配错了，不然可能导致重启后启动不起来。<br>成功后，重启机器磁盘就可以自动挂载上去了。</p><h2 id="3-配置系统"><a href="#3-配置系统" class="headerlink" title="3. 配置系统"></a>3. 配置系统</h2><h3 id="1-配置apt"><a href="#1-配置apt" class="headerlink" title="1.配置apt"></a>1.配置apt</h3><p>编辑 ‘&#x2F;etc&#x2F;apt&#x2F;sources.list’文件，修改为清华apt源,将下面内容替换进去即可，一共四行<br>这里是debian提供的各个国家的镜像站，将地址替换为中国的即可 <code>https://www.debian.org/mirror/list</code></p><p><strong>bullseye 版本使用这个</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">deb http<span class="hljs-punctuation">:</span><span class="hljs-comment">//ftp.cn.debian.org/debian bullseye main contrib non-free</span><br>deb http<span class="hljs-punctuation">:</span><span class="hljs-comment">//ftp.cn.debian.org/debian bullseye-updates main contrib non-free</span><br>deb http<span class="hljs-punctuation">:</span><span class="hljs-comment">//ftp.cn.debian.org/debian bullseye-backports main contrib non-free</span><br>deb http<span class="hljs-punctuation">:</span><span class="hljs-comment">//ftp.cn.debian.org/debian/debian-security bullseye-security main contrib non-free</span><br></code></pre></td></tr></table></figure><p><strong>bookworm 使用这个</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">deb http<span class="hljs-punctuation">:</span><span class="hljs-comment">//ftp.cn.debian.org/debian bookworm main contrib non-free non-free-firmware</span><br>deb http<span class="hljs-punctuation">:</span><span class="hljs-comment">//ftp.cn.debian.org/debian bookworm-updates main contrib non-free non-free-firmware</span><br>deb http<span class="hljs-punctuation">:</span><span class="hljs-comment">//ftp.cn.debian.org/debian bookworm-backports main contrib non-free non-free-firmware</span><br>deb http<span class="hljs-punctuation">:</span><span class="hljs-comment">//ftp.cn.debian.org/debian/debian-security bookworm-security main contrib non-free non-free-firmware</span><br></code></pre></td></tr></table></figure><h3 id="2-安装docker"><a href="#2-安装docker" class="headerlink" title="2. 安装docker"></a>2. 安装docker</h3><p>软件源更新后下载速度是很快的，<strong>切换到root用户然后执行下面命令</strong>：<br>docker我们按照官方教程新增docker的apt源，然后使用apt命令就能安装。为什么要添加官方源而不是使用debian的apt源呢，因为debian的源不是最新的。</p><p><strong>1. 卸载docker旧的包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">for pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do sudo apt-get remove $pkg; done  <br></code></pre></td></tr></table></figure><p><strong>2. 安装docker的apt源到系统上,并且配置镜像地址而不是官方地址</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Add Docker<span class="hljs-string">&#x27;s official GPG key:</span></span><br>apt-get update<br>apt-get install ca-certificates curl<br>install -m 0755 -d /etc/apt/keyrings<br>curl -fsSL https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.asc<br>chmod a+r /etc/apt/keyrings/docker.asc<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">Add the repository to Apt sources:</span></span><br>echo \<br>  &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://mirrors.ustc.edu.cn/docker-ce/linux/debian \<br><span class="hljs-meta prompt_">  $</span><span class="language-bash"><span class="hljs-string">(. /etc/os-release &amp;&amp; echo &quot;$VERSION_CODENAME&quot;) stable&quot; | \</span></span><br><span class="hljs-string"><span class="language-bash">  tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span><br>sudo apt-get update<br></code></pre></td></tr></table></figure><p><strong>3. 安装docker</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin<br></code></pre></td></tr></table></figure><p><strong>done这样docker就安装好了</strong></p><p>docker仓库镜像在 <code>/etc/docker/daemon.json</code>中修改，不过现在不太好找可用的了。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;registry-mirrors&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;http://hub-mirror.c.163.com&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="3-命令提示建议"><a href="#3-命令提示建议" class="headerlink" title="3.命令提示建议"></a>3.命令提示建议</h3><p>当输入命令出现错别字时，会提示 <code>command not found</code>, 通过安装 <code>apt install command-not-found</code>工具（需重新连接shell）后给出建议，效果如下。<br>假设我输入一个不存在的命令lala，会出现如下提示。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">root@debian:/root# lala<br>Command <span class="hljs-string">&#x27;lala&#x27;</span> not found, did you mean:<br>  <span class="hljs-keyword">command</span> <span class="hljs-string">&#x27;nala&#x27;</span> from <span class="hljs-keyword">deb</span> nala<br>  <span class="hljs-keyword">command</span> <span class="hljs-string">&#x27;vala&#x27;</span> from <span class="hljs-keyword">deb</span> valac-bin<br>  <span class="hljs-keyword">command</span> <span class="hljs-string">&#x27;lola&#x27;</span> from <span class="hljs-keyword">deb</span> lola<br>Try: apt install &lt;<span class="hljs-keyword">deb</span> name&gt;<br></code></pre></td></tr></table></figure><h3 id="4-配置ssh端口"><a href="#4-配置ssh端口" class="headerlink" title="4. 配置ssh端口"></a>4. 配置ssh端口</h3><p>  使用默认的ssh 22端口不太安全，更换成高端口号更不容易被扫描。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/ssh<br>vi sshd_config<br></code></pre></td></tr></table></figure><ol><li>将原先被注释掉的 Port 22 恢复，并再增加一条 Port 5000。Port可以配置多个。</li><li>使用命令 systemctl restart sshd重启 ssh服务</li><li>再开一个端口连接5000 如果能正常连接进去说明配置生效，按照上面的方法将22端口注释掉</li></ol><h3 id="5-开启ssh认证日志"><a href="#5-开启ssh认证日志" class="headerlink" title="5.开启ssh认证日志"></a>5.开启ssh认证日志</h3><p>ssh连接的日志会输出到 <code>/var/log/auth.log</code>文件下的，后面要安装的fail2ban也是依赖该文件判定登陆是否成功、失败的次数，如果你没有这个文件可能是缺少了系统日志服务。</p><p>使用命令 <code>ps -ef |grep rsyslogd</code> 查看 rsyslogd是否存在<br>如果不存在 使用 <code>apt install rsyslogd</code> 安装<br>启动服务 <code>systemctl start rsyslog</code><br>这样就可以输出登陆认证日志了</p><h3 id="6-安装fail2ban"><a href="#6-安装fail2ban" class="headerlink" title="6. 安装fail2ban"></a>6. 安装fail2ban</h3><p>  fail2ban可以有效的方式暴力破解的方式，他会监听ssh的登陆日志，就是上面说的 <code>/var/log/auth.log</code>如果密码错误超过一定次数直接封禁ip。建议安装在宿主机上而不是docker里，过程如下。</p><ol><li>安装 <code>apt install fail2ban</code></li><li>启动 <code>systemctl start fail2ban</code></li></ol><p> 默认情况下fail2ban开启了ssh服务的拦截，不过是在22端口，因为上面我们修改了端口好，即使fail2ban能够通过日志发现黑客的攻击，但是只会通过iptables封掉对应的22端口<br>的访问，因为我们修改了ssh的端口号。<br>3. 配置修改配置文件 <code>/etc/fail2ban/jail.d/defaults-debian.conf</code><br>这里我配置了端口号，并配置了封禁时间96小时，失败5次即封ip,如果ssh开启了多个端口号可以用逗号拼起来<br>    <code>ini     [sshd]     enabled = true     port = 30000     bantime  = 96h     maxretry = 5     </code><br>4. 重启fail2ban <code>systemctl restart fail2ban</code></p><ol start="5"><li><p>查看fail2ban<br>fail2ban提供了服务端和客户端，一般我们操作客户端命令查看fail2ban的运行情况。常用的命令如下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">fail2ban-client status  查看整体状态<br>fail2ban-client status sshd  查看ssh的状态<br>fail2ban-client <span class="hljs-built_in">get</span> sshd banip --with-time 查看ssh被封的ip，把封禁时间和解封时间都展示出来<br><br>fail2ban-client <span class="hljs-built_in">set</span> sshd banip 555.222.111.222  手动封禁一个ip<br>fail2ban-client <span class="hljs-built_in">set</span> sshd unbanip 555.222.111.222  手动解封一个ip<br></code></pre></td></tr></table></figure></li></ol><p>更详细可的可以查看 fail2ban-client –help</p><ol start="6"><li>查看fail2ban的日志<br>日志在 <code>/var/log/fail2ban.log</code>下，里面有详细的封禁、解封日志</li></ol><h3 id="7-配置语言环境-locale"><a href="#7-配置语言环境-locale" class="headerlink" title="7. 配置语言环境 locale"></a>7. 配置语言环境 locale</h3><p>如果中文不展示，或和有其他乱码问题，可以按照下面这样做。</p><ol><li>修改locale文件配置成英文utf-8</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@vm:/opt# cat /etc/default/locale <br><span class="hljs-meta prompt_"># </span><span class="language-bash"> File generated by update-locale</span><br>LANG=en_US.UTF-8<br>LANGUAGE=<br>LC_CTYPE=&quot;en_US.UTF-8&quot;<br>LC_NUMERIC=&quot;en_US.UTF-8&quot;<br>LC_TIME=&quot;en_US.UTF-8&quot;<br>LC_COLLATE=&quot;en_US.UTF-8&quot;<br>LC_MONETARY=&quot;en_US.UTF-8&quot;<br>LC_MESSAGES=&quot;en_US.UTF-8&quot;<br>LC_PAPER=&quot;en_US.UTF-8&quot;<br>LC_NAME=&quot;en_US.UTF-8&quot;<br>LC_ADDRESS=&quot;en_US.UTF-8&quot;<br>LC_TELEPHONE=&quot;en_US.UTF-8&quot;<br>LC_MEASUREMENT=&quot;en_US.UTF-8&quot;<br>LC_IDENTIFICATION=&quot;en_US.UTF-8&quot;<br>LC_ALL=<br></code></pre></td></tr></table></figure><p>使用下面的命令有可视化窗口,空格是选择回车是确认。选择en_US英文模式,如果想用中文保持不变也可以</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo dpkg-reconfigure locales<br></code></pre></td></tr></table></figure><p>然后退出重新登陆</p><h3 id="8-安装samba"><a href="#8-安装samba" class="headerlink" title="8. 安装samba"></a>8. 安装samba</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装samba</span><br>apt install samba<br><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑samba配置文件</span><br>nano /etc/samba/smb.conf<br><span class="hljs-meta prompt_">#</span><span class="language-bash">[usb1]是显示的共享名字，path = /mnt/usb1是准备共享出来的目录</span><br>[usb1] <br>comment = myshare<br>path = /mnt/sharefile<br>writable = yes  <br>create mask = 0755<br>directory mask = 0755<br></code></pre></td></tr></table></figure><p>安装完成后,配置账号密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch /etc/samba/smbpasswd<br><br>smbpasswd -a root #配置用户名和密码,sabma的密码和ssh的密码是独立的,用户名共享<br><br>service smbd restart # 重启服务<br></code></pre></td></tr></table></figure><h2 id="4-一些命令"><a href="#4-一些命令" class="headerlink" title="4. 一些命令"></a>4. 一些命令</h2><p>vnstat 展示过去流量汇总情况，可通过添加 -l参数查看实时流量  </p><p>sysstat 是一个工具包,包含有几个很有用的系统检测程序,iostat,mpstat和sar</p><p>iostat用于磁盘I&#x2F;O分区的统计信息.可以用来分析磁盘I&#x2F;O,带宽等信息<br>    iostat -m 2，没2秒输出一次信息，以MB为单位展示（默认KB）</p><p>mpstat用于输出CPU的各种统计信息. 可以用来分析程序运行时在内核态和用户态的工作情况  </p><p>sar用于定时搜集系统的各种状态信息.然后可以对系统各个时间点的状态进行监控  </p>]]></content>
    
    
    <categories>
      
      <category>搞事情</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>斐讯N1</tag>
      
      <tag>debian</tag>
      
      <tag>armbian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git 设置代理拉取代码(转载)</title>
    <link href="/2538332822.html"/>
    <url>/2538332822.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-命令行式-git-设置-http-https-socks5-协议的代理"><a href="#1-命令行式-git-设置-http-https-socks5-协议的代理" class="headerlink" title="1.命令行式 git 设置 http&#x2F;https&#x2F;socks5 协议的代理"></a>1.命令行式 git 设置 http&#x2F;https&#x2F;socks5 协议的代理</h2><p>windows&#x2F;mac&#x2F;linux 通用设置</p><h4 id="http-协议的"><a href="#http-协议的" class="headerlink" title="http 协议的"></a>http 协议的</h4><pre><code class="hljs">git config --global http.proxy &quot;http://127.0.0.1:8080&quot;git config --global https.proxy &quot;http://127.0.0.1:8080&quot;</code></pre><h4 id="socks5-协议的"><a href="#socks5-协议的" class="headerlink" title="socks5 协议的"></a>socks5 协议的</h4><pre><code class="hljs">git config --global http.proxy &quot;socks5://127.0.0.1:1080&quot;git config --global https.proxy &quot;socks5://127.0.0.1:1080&quot;</code></pre><h4 id="取消-http"><a href="#取消-http" class="headerlink" title="取消 http"></a>取消 http</h4><pre><code class="hljs">git config --global --unset http.proxygit config --global --unset https.proxy</code></pre><h2 id="2-配置文件式-mac-linux-设置-ssh-代理"><a href="#2-配置文件式-mac-linux-设置-ssh-代理" class="headerlink" title="2.配置文件式 mac&#x2F;linux 设置 ssh 代理"></a>2.配置文件式 mac&#x2F;linux 设置 ssh 代理</h2><p>配置文件为： ~&#x2F;.ssh&#x2F;config</p><pre><code class="hljs"># 必须是 github.comHost github.comHostName github.comUser git# 走 socks5 代理ProxyCommand nc -v -x 127.0.0.1:1080 %h %p# 走 HTTP 代理# ProxyCommand nc -v -X connect -x 127.0.0.1:8090 %h %p</code></pre><h2 id="3-配置文件式-windows-设置-ssh-代理"><a href="#3-配置文件式-windows-设置-ssh-代理" class="headerlink" title="3.配置文件式 windows 设置 ssh 代理"></a>3.配置文件式 windows 设置 ssh 代理</h2><p>配置文件同样是 ： ~&#x2F;.ssh&#x2F;config</p><pre><code class="hljs">Host github.comHostName github.comUser git# 走 socks5 协议# ProxyCommand connect -S 127.0.0.1:8090 %h %p# 走 http 协议ProxyCommand connect -H 127.0.0.1:8090 %h %p</code></pre><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>在设置 <code>http/https</code> 上，两者系统没有区别。</p><p>但是在设置 ssh 代理时，<code>git bash</code> 内置了 <code>connect</code> ，所以在 windows 中，使用的是 <code>connect</code>。</p><p>而在 mac 或者 linux 上，执行 <code>connect</code> 找不到命令，取而代之的是 <code>nc</code> 所以两者的区别仅在于 <code>ProxyCommand</code> 后面使用的命令是不同的</p><p>目前网上许多的设置方法，仅仅标注了设置 ssh 代理的方法，并未标注平台，某些使用 linux ，某些使用 windows。导致有的设置不生效或报错<br>仅对设置方法做整合，以上设置都是自用的</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis-plus 三种SQL拼接方式</title>
    <link href="/1804476068.html"/>
    <url>/1804476068.html</url>
    
    <content type="html"><![CDATA[<h1 id="mybatis-plus-三种SQL拼接方式"><a href="#mybatis-plus-三种SQL拼接方式" class="headerlink" title="mybatis-plus 三种SQL拼接方式"></a>mybatis-plus 三种SQL拼接方式</h1><p>mybatis-plus有三种传参方式，最终效果就是拼接sql参数分别如下。</p><p>sql的三种拼接方式</p><ul><li>标准模式，使用类似于 new QueryWrapper&lt;&gt;().eq(“request_no”,”aaa”)</li><li>lambda模式，类似于 new QueryWrapper<TbClearingCostDelay>().lambda().eq(TbClearingCostDelay::getRequestNo, “”)</li><li>实体类模式 new QueryWrapper&lt;&gt;(new TbClearingCostDelay());</li></ul><p>模式1和模式2没有本质区别，主要是要取得字段名称和字段值，生成sql片段。<br>lambda方式使用了java序列化的特殊方法的到的字段名 (可以搜索下获取使用序列化接口获取lambda的方法名), 而模式1直接传递的字段名。<br>这两种种方式内部会使用 MergeSegments 对象存储设置的字段和值，MergeSegments 对象内部会拼接成sql片段</p><p>模式3直接存储实体类在wrapper中，而启动时,框架会将所有的 mybatis 接口对应的方式生成与之对应的 xml 脚本，脚本类似于下面这样。<br>其中ew对象就是wrapper对象，启动时遍历所有字段帮我们把类似原生写法的xml生成好。  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span><br><span class="language-xml"><span class="language-handlebars">DELETE FROM tb_clearing_cost_delay </span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew != null&quot;</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-comment">&lt;!-- 实体类 --&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew.entity != null&quot;</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew.entity[&#x27;requestNo&#x27;] != null&quot;</span>&gt;</span> AND request_no=#&#123;ew.entity.requestNo&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew.entity[&#x27;clearingType&#x27;] != null&quot;</span>&gt;</span> AND clearing_type=#&#123;ew.entity.clearingType&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew.entity[&#x27;failTime&#x27;] != null&quot;</span>&gt;</span> AND fail_time=#&#123;ew.entity.failTime&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew.entity[&#x27;requestTime&#x27;] != null&quot;</span>&gt;</span> AND request_time=#&#123;ew.entity.requestTime&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew.entity[&#x27;bizIdentify&#x27;] != null&quot;</span>&gt;</span> AND biz_identify=#&#123;ew.entity.bizIdentify&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew.entity[&#x27;productCode&#x27;] != null&quot;</span>&gt;</span> AND product_code=#&#123;ew.entity.productCode&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew.entity[&#x27;transStep&#x27;] != null&quot;</span>&gt;</span> AND trans_step=#&#123;ew.entity.transStep&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew.entity[&#x27;fluxAction&#x27;] != null&quot;</span>&gt;</span> AND flux_action=#&#123;ew.entity.fluxAction&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew.entity[&#x27;bizExtend&#x27;] != null&quot;</span>&gt;</span> AND biz_extend=#&#123;ew.entity.bizExtend&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew.entity[&#x27;clearingDetails&#x27;] != null&quot;</span>&gt;</span> AND clearing_details=#&#123;ew.entity.clearingDetails&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew.entity[&#x27;clearingStatus&#x27;] != null&quot;</span>&gt;</span> AND clearing_status=#&#123;ew.entity.clearingStatus&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew.entity[&#x27;remark&#x27;] != null&quot;</span>&gt;</span> AND remark=#&#123;ew.entity.remark&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew.entity[&#x27;lastValidTime&#x27;] != null&quot;</span>&gt;</span> AND last_valid_time=#&#123;ew.entity.lastValidTime&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew.entity[&#x27;utcCreateTime&#x27;] != null&quot;</span>&gt;</span> AND utc_create_time=#&#123;ew.entity.utcCreateTime&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew.entity[&#x27;utcModifyTime&#x27;] != null&quot;</span>&gt;</span> AND utc_modify_time=#&#123;ew.entity.utcModifyTime&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-comment">&lt;!-- 如果前面有任何条件，则 --&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew.sqlSegment != null and ew.sqlSegment != &#x27;&#x27; and ew.nonEmptyOfWhere&quot;</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew.nonEmptyOfEntity and ew.nonEmptyOfNormal&quot;</span>&gt;</span> AND<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">         $&#123;ew.sqlSegment&#125;</span></span><br><span class="language-xml"><span class="language-handlebars">     <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-comment">&lt;!-- 没有实体、没有lambda、没有正常条件的情况下，以segment为准 --&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew.sqlSegment != null and ew.sqlSegment != &#x27;&#x27; and ew.emptyOfWhere&quot;</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">        $&#123;ew.sqlSegment&#125;</span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span> </span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-comment">&lt;!--sql备注 --&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;ew != null and ew.sqlComment != null&quot;</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">    $&#123;ew.sqlComment&#125;</span></span><br><span class="language-xml"><span class="language-handlebars">    <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>从上面xml可以看出，entity写法和标准写法是相互不关心的，两种可以共存，两种写法操作同一个字段也不会自动去重，而是条件使用and连接。<br>同时会对字段做null判断但不会做blank判断</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>mybatis-plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea调试debug javascript不生效</title>
    <link href="/2318249654.html"/>
    <url>/2318249654.html</url>
    
    <content type="html"><![CDATA[<h1 id="idea调试debug-javascript不生效"><a href="#idea调试debug-javascript不生效" class="headerlink" title="idea调试debug javascript不生效"></a>idea调试debug javascript不生效</h1><h2 id="问题现象："><a href="#问题现象：" class="headerlink" title="问题现象："></a>问题现象：</h2><p>​使用idea调试js，能够打开空白chrome，但不能自动进入网页，并且idea控制台不能关联浏览器控制台，断点也不生效。</p><p>排查思路：</p><h2 id="解决方法问题一"><a href="#解决方法问题一" class="headerlink" title="解决方法问题一"></a>解决方法问题一</h2><p>打开idea 右下角 event log窗口，查看是否有 <code>Waiting for connection to localhost:52421. Please ensure that the browser was started successfully with remote debugging port opened. Port cannot be opened if Chrome having the same User Data Directory is already launched.</code> 这样的错误日志</p><p><strong>如果出现上面的错误日志，考虑是端口被占用，window上可能是端口被占用了，使用<code>netsh interface ipv4 show excludedportrange protocol=tcp</code>命令查看报错的端口是否包含在内。如果被占用了，可以更换一个端口。</strong></p><p><strong>打开<code>C:\Users\user\AppData\Roaming\JetBrains\IntelliJIdea2020.2\options\other.xml</code>文件，找到<code>js.chrome.debugger.port</code>内容，修改后面的端口并重启idea。（有时候idea启动时会自动修改回去，所以重启时马上改端口才能生效，不行就多重启几次或重启下电脑）</strong></p><p>参考文档：<a href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/360009567459-Webstorm-2020-2-1-Remote-Debugging-do-not-work">https://intellij-support.jetbrains.com/hc/en-us/community/posts/360009567459-Webstorm-2020-2-1-Remote-Debugging-do-not-work</a></p><h2 id="解决方法问题二"><a href="#解决方法问题二" class="headerlink" title="解决方法问题二"></a>解决方法问题二</h2><p>如果不是上面的问题，或按照上面修改后不生效，考虑是chrome版本太新，按照论坛中说明，需增加chrome启动参数，添加方法如下。</p><p><strong>打开<code>Settle -&gt; Tools -&gt; Web Browsers -&gt; 选中chrome -&gt; 右边编辑按钮 -&gt; command Line options</code>中输入 <code>--remote-allow-origins=*</code>。 见截图</strong></p><p><strong>![image-20230607193336200](&#x2F;img&#x2F;in&#x2F;2023-06-07-idea调试debug javascript不生效&#x2F;image-20230607193336200.png)</strong></p><hr><p><strong>保存后重启idea 我这边就能js debug就能正常生效了。</strong></p><p>参考文档： <a href="https://youtrack.jetbrains.com/issue/WEB-59211/Cant-attach-debugger-to-Chrome-Dev-111-Invalid-handshake-response-getStatus-403-Forbidden">https://youtrack.jetbrains.com/issue/WEB-59211/Cant-attach-debugger-to-Chrome-Dev-111-Invalid-handshake-response-getStatus-403-Forbidden</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>idea</tag>
      
      <tag>javaScript</tag>
      
      <tag>js debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记</title>
    <link href="/1633824014.html"/>
    <url>/1633824014.html</url>
    
    <content type="html"><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><h2 id="dubbo查找需要暴漏的服务"><a href="#dubbo查找需要暴漏的服务" class="headerlink" title="dubbo查找需要暴漏的服务"></a>dubbo查找需要暴漏的服务</h2><p>DubboService 注解上描述的很清楚，将该注解增加到facade的实现类上</p><p>可以配合dubbo.scan.base-packages &#x3D; x.y.z  标注在哪个包下查找实现类，以此加快查找速度</p>]]></content>
    
    
    
    <tags>
      
      <tag>dubbo</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring的Qualifier注解</title>
    <link href="/1170055610.html"/>
    <url>/1170055610.html</url>
    
    <content type="html"><![CDATA[<h1 id="Spring的Qualifier注解"><a href="#Spring的Qualifier注解" class="headerlink" title="Spring的Qualifier注解"></a>Spring的Qualifier注解</h1><p>​spring 的依赖注入功能依赖 <code>@Autowired</code> 注解，该注解可以标记在单个字段上，表示注入单个值。也可以标记在 list&#x2F;array&#x2F;map 上，表示注入多个值</p><p>​<code>@Qualifier </code>注解是在 @Autowired 的基础上提供了选择的功能，有如下使用场景</p><ol><li><p>需要注入一个对象，但容器内存在多个相同类型的对象，容器无法选择具体注入哪一个</p></li><li><p>容器内存在 5 个相同类型的对象，需要指定注入其中 3 个到一个 List 中</p></li></ol><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>​@Qualifier 有两种用法，一种直接在需要注入的地方添加 @Qualifier 注解，一种添加注解时顺便指定值，例如@Qualifier(value&#x3D;’a1’) 表示筛选名称为a1对象或同样添加 @Qualifier(value&#x3D;’a1’) 的 bean。</p><p>​</p><p>​@Qualifier 的这两种用法是有区别如下：</p><p>如果只添加 @Qualifier 注解，没有指定值，则查找的依据为是否同样添加 @Qualifier 。只有添加了 @Qualifier 注解（ps: 注解上不能有值）才能满足筛选条件。</p><p>如果添加的 @Qualifier(value&#x3D;’a1’) ,则存在两种类型的bean是符合条件的。</p><ul><li><p>bean 的定义中同样添加了 @Qualifier(value&#x3D;’a1’)</p></li><li><p>bean 的 name&#x3D;a1</p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>​ @Qualifier 注解没有参数的情况下，会查找 bean 定义时增加 @Qualifier 的 bean，此时注入的是a 2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Component(&quot;a1&quot;)</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Qualifier</span><br>    <span class="hljs-meta">@Component(&quot;a2&quot;)</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Qualifier</span><br>    <span class="hljs-meta">@Autowired</span><br>    A a<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>​</p><p>​@Qualifier 注解上指定了 bean 的名字为 a1，所以即使 a2 上存在 @Qualifier 注解也不会选中，此时注入的bean 是 a1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Component(&quot;a1&quot;)</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Qualifier</span><br>    <span class="hljs-meta">@Component(&quot;a2&quot;)</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Qualifier(&quot;a1&quot;)</span><br>    <span class="hljs-meta">@Autowired</span><br>    A a<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>​a1 bean 满足注入条件，因为 @Qualifier 上指定了 bean 的名字是 a1，同时 a2 bean 也满足注入条件，因为他与需要注入的字段上增加的 <code>@Qualifier(&quot;a1&quot;)</code> 是一样的。此时两个 bean 都满足条件，启动会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>      <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br><br>      &#125;<br><br>      <span class="hljs-meta">@Component(&quot;a1&quot;)</span><br>      <span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span> &#123;<br><br>      &#125;<br><br>      <span class="hljs-meta">@Qualifier</span><br>      <span class="hljs-meta">@Component(&quot;a1&quot;)</span><br>      <span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span> &#123;<br><br>      &#125;<br><br>      <span class="hljs-meta">@Qualifier(&quot;a1&quot;)</span><br>      <span class="hljs-meta">@Autowired</span><br>      A a<br>      <br>  &#125;<br></code></pre></td></tr></table></figure><p>​注入列表与注入字段一样的，此时注入到 list 中的对象只有 a2，因为它上面添加了 @Qualifier 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Component(&quot;a1&quot;)</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Qualifier</span><br>    <span class="hljs-meta">@Component</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Qualifier</span><br>    <span class="hljs-meta">@Autowired</span><br>    List&lt;A &gt; a<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>​再看一下最后一种情况，这种情况下两个 bean 都不会被注入，a1 上没有 @Qualifier 注解不满足条件，a2 上的 @Qualifier(“a2”) 注解与需要注入的字段上的 @Qualifier 注解不一致也不满足条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Component</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Qualifier(&quot;a2&quot;)</span><br>    <span class="hljs-meta">@Component</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Qualifier</span><br>    <span class="hljs-meta">@Autowired</span><br>    List&lt;A &gt; a<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>Qualifier</tag>
      
      <tag>Spring注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次prometheus指标重复的问题</title>
    <link href="/3974163911.html"/>
    <url>/3974163911.html</url>
    
    <content type="html"><![CDATA[<h1 id="记一次prometheus指标重复的问题"><a href="#记一次prometheus指标重复的问题" class="headerlink" title="记一次prometheus指标重复的问题"></a>记一次prometheus指标重复的问题</h1><p>​</p><p>使用的reslience4j做熔断器，使用prometheus统计熔断器的指标监控，其中有一项指标是访问次数，用来绘制tps折线图。后来发现访问一次会导致指标增加两次。</p><p>​</p><p>​使用如下方式配置熔断器，并将其绑定到micrometer上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.micrometer.core.instrument.MeterRegistry;<br><span class="hljs-keyword">import</span> io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CircuitConfig</span> &#123;<br><br>    <span class="hljs-comment">//micrometer提供,本质上底层还是代理到prometheus上</span><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> MeterRegistry meterRegistry;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CircuitBreakerRegistry <span class="hljs-title function_">circuitBreakerRegistry</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">CircuitBreakerRegistry</span> <span class="hljs-variable">cr</span> <span class="hljs-operator">=</span> CircuitBreakerRegistry.of(circuitConfig());<br>        TaggedCircuitBreakerMetrics.ofCircuitBreakerRegistry(cr).bindTo(meterRegistry);<br>        <span class="hljs-keyword">return</span> cr;<br>    &#125;<br></code></pre></td></tr></table></figure><p>​同时系统引入了spring.cloud的相关组件，其中有一段是这样的。注意看红圈地方，有做了一次绑定，其中的factory中获取到的CircuitBreakerRegistry就是上面代码中配置的CircuitBreakerRegistry。也就是该CircuitBreakerRegistry绑定了两次MeterRegistry。</p><p>​这也就导致了发生一次调用，指标统计两次。</p><p><img src="/img/in/2022-10-27-%E8%AE%B0%E4%B8%80%E6%AC%A1prometheus%E6%8C%87%E6%A0%87%E9%87%8D%E5%A4%8D%E7%9A%84%E9%97%AE%E9%A2%98/image-20221027191017888.png" alt="image-20221027191017888"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​因为springboot的组件，检测到我们相应类存在时，会自动装配。其中就包含将熔断器绑定到指标监控的参数，而我又做了一次，导致的该问题，后续我将自己绑定的部分去掉了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>单元测试</tag>
      
      <tag>Spring</tag>
      
      <tag>Spock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spock测试框架中的mock类型</title>
    <link href="/967757660.html"/>
    <url>/967757660.html</url>
    
    <content type="html"><![CDATA[<h1 id="Spock测试框架中的mock类型"><a href="#Spock测试框架中的mock类型" class="headerlink" title="Spock测试框架中的mock类型"></a>Spock测试框架中的mock类型</h1><p>​最近使用Spock做单元测试比较多，但是对其中的Mock理解的比较混乱，今天抽些时间对其中的测试类型做测试，以此来揭示其中的区别。</p><h2 id="认识mocking-和-stubing-和-Spying"><a href="#认识mocking-和-stubing-和-Spying" class="headerlink" title="认识mocking 和 stubing 和 Spying"></a>认识mocking 和 stubing 和 Spying</h2><p>​mocking翻译成中文就是 “模拟”，stubing翻译成中文就是”存根”，spying翻译成中文就是”间谍”。</p><ul><li>模拟拥有的能力是：对方法调用进行验证，在spock中表现形式如下。</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-number">1</span> * subscriber.receive(<span class="hljs-string">&quot;hello&quot;</span>)<br><br><span class="hljs-number">1</span> * subscriber.receive(<span class="hljs-string">&quot;hello&quot;</span>)<br>|   |          |       |<br>    |   |          |       目标参数<br>|   |          目标方法<br>|   目标 Mock 对象<br>调用次数<br></code></pre></td></tr></table></figure><p>​这就是’模拟’的能力，它的关注点是方法调用次数，调用参数等等的判断，这里不做赘述。</p><ul><li>存根拥有的能力是：控制对象的返回值，在spock中的表现形式如下。</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy">subscriber.receive(<span class="hljs-string">&quot;message1&quot;</span>) &gt;&gt; <span class="hljs-string">&quot;ok&quot;</span><br>subscriber.receive(<span class="hljs-string">&quot;message2&quot;</span>) &gt;&gt; <span class="hljs-string">&quot;fail&quot;</span><br></code></pre></td></tr></table></figure><p>​这就是存根的能力，spock使用 <code>&gt;&gt;</code>作为特征，后面可以返回固定值，或者闭包，或者链式多个值。</p><ul><li>间谍的能力是：工作在真实对象和调用方之间</li></ul><p>间谍这个词比较形象，在编程里就是一层代理类，间谍代理真实对象，在调用链路中间做一些事情。</p><p>​模拟+存根</p><p>同时使用模拟+存根也是可以的，在spock中是下面这种写法。这种写法下模拟和存根的效果是同时生效的。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-number">1</span> * subscriber.receive(<span class="hljs-string">&quot;message1&quot;</span>) &gt;&gt; <span class="hljs-string">&quot;ok&quot;</span><br></code></pre></td></tr></table></figure><h2 id="spock中的模拟和存根"><a href="#spock中的模拟和存根" class="headerlink" title="spock中的模拟和存根"></a>spock中的模拟和存根</h2><p>​spock提供三个方法用于生成mock对象，分别是Mock()，Stub()，Spay()。</p><p><strong>不要被他们的名字迷惑了，不要以为Mock对应上面的”模拟”能力，Stub对应”存根”能力，Spay对应”间谍”能力，这是不对的。</strong></p><p>​</p><p>​这三个方法都能返回一个对象，</p><p>其中Mock()生成的对象，它拥有上面所说的 “模拟”，“存根”两种能力，</p><p>Stub()生成的对象，只拥有上面说的”存根”一种能力</p><p>Spay()生成的对象具有”模拟”，“存根”，“间谍”三种能力</p><h2 id="spock配置类源码解读"><a href="#spock配置类源码解读" class="headerlink" title="spock配置类源码解读"></a>spock配置类源码解读</h2><p>​请看这三种类型在源码中的枚举定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">MockNature</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * A mock object whose method calls are verified, which instantiates class-based mock objects with Objenesis,</span><br><span class="hljs-comment">   * and whose strategy for responding to unexpected method calls is &#123;<span class="hljs-doctag">@link</span> ZeroOrNullResponse&#125;.</span><br><span class="hljs-comment">   */</span><br>  MOCK(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, ZeroOrNullResponse.INSTANCE),<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * A mock object whose method calls are not verified, which instantiates class-based mock objects with Objenesis,</span><br><span class="hljs-comment">   * and whose strategy for responding to unexpected method calls is &#123;<span class="hljs-doctag">@link</span> EmptyOrDummyResponse&#125;.</span><br><span class="hljs-comment">   */</span><br>  STUB(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, EmptyOrDummyResponse.INSTANCE),<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * A mock object whose method calls are verified, which instantiates class-based mock objects by calling a</span><br><span class="hljs-comment">   * real constructor, and whose strategy for responding to unexpected method calls is &#123;<span class="hljs-doctag">@link</span> CallRealMethodResponse&#125;.</span><br><span class="hljs-comment">   */</span><br>  SPY(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, CallRealMethodResponse.INSTANCE);<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> verified;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> useObjenesis;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IDefaultResponse defaultResponse;<br><br>  MockNature(<span class="hljs-type">boolean</span> verified, <span class="hljs-type">boolean</span> useObjenesis, IDefaultResponse defaultResponse) &#123;<br>    <span class="hljs-built_in">this</span>.verified = verified;<br>    <span class="hljs-built_in">this</span>.useObjenesis = useObjenesis;<br>    <span class="hljs-built_in">this</span>.defaultResponse = defaultResponse;<br>  &#125;<br></code></pre></td></tr></table></figure><p><code>MockNature</code>对象有三个参数，这三个参数的组合决定了这三种类型的特性。</p><p><code>verified</code>：表示是否识别调用次数，调用参数验证。即是否能够使用 <code>1 * foo.doSome()</code> 这种样子的断言验证</p><p><code>useObjenesis</code>：表示使用是否使用Objenesis工具创建mock对象。PS：有些类没有默认构造方法，所以通过反射无法创建出来，使用Objenesis工具能绕过构造方法直接创建对象。其中Spy是直接new的，其余两个使用Objenesis工具</p><p><code>defaultResponse</code>：表示生成的mock对象的默认返回策略。Mock尽量返回0或null，Stub尽量返回对象的默认值，Spy透传给真实类。例如方法返回值是字符串类型的，Mock会返回null，Stub会返回空字符串，Spy会透传给真实对象。</p><h2 id="做个表"><a href="#做个表" class="headerlink" title="做个表"></a>做个表</h2><table><thead><tr><th>方式</th><th>支持调用验证</th><th>支持方法mock</th><th>mock策略</th><th>返回值策略</th></tr></thead><tbody><tr><td>Mock</td><td>Y</td><td>Y</td><td>使用Objenesis忽略构造方法创建对象</td><td>尽量返回0或者null</td></tr><tr><td>Stub</td><td>N</td><td>Y</td><td>使用Objenesis忽略构造方法创建对象</td><td>尽量返回默认值，如空字符串，空集合等</td></tr><tr><td>Spy</td><td>Y</td><td>Y</td><td>使用构造方法new对象</td><td>委托给真实对象获取返回值</td></tr></tbody></table><p>​如上面所说，Stub的<code>verified</code>参数是false，所以它没有”模拟的能力”。Spy的<code>useObjenesis</code>是false，因为要使用构造方法创建被代理对象。</p><p>​同时他们对待返回值处理策略也不相同，Mock尽量返回null值，Stub尽量返回默认值，Spay不自己处理返回值。</p><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="方法mock"><a href="#方法mock" class="headerlink" title="方法mock"></a>方法mock</h3><p>​单元测试时，我们要对某个方法进行mock，也就是上面说到的”存根”能力。</p><p>​请看下面的测试案例，when块和then块中均对test方法进行了mock。按照正常人思维要么会报错，要么第一个生效。其实并不是这样。</p><p>​ 按照官方的说法，程序编译时会优先解析then块中的mock，所以then块中优先级更高，when块中的mock不会生效。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-meta">@Slf</span>4j<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSpockNoSpring</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Specification</span> &#123;<br><br>    SpockTestService spockTestService = Mock()<br><br>    <span class="hljs-meta">@IgnoreRest</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-string">&quot;test&quot;</span>() &#123;<br>        <span class="hljs-symbol">when:</span><br>        spockTestService.test() &gt;&gt; <span class="hljs-string">&#x27;mock&#x27;</span><span class="hljs-comment">//这里优先级比then块中的低</span><br><br>        <span class="hljs-keyword">def</span> doTest = spockTestService.test()<br>        log.info(<span class="hljs-string">&#x27;CallDoTest:&#123;&#125;&#x27;</span>, String.valueOf(doTest))<br><br>        <span class="hljs-symbol">then:</span><br>        spockTestService.test()  &gt;&gt; <span class="hljs-string">&#x27;mock at then&#x27;</span><span class="hljs-comment">//这里的mock生效</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="隐式的mock"><a href="#隐式的mock" class="headerlink" title="隐式的mock"></a>隐式的mock</h3><p>​看下面这里案例，看起来应该是when中的”存根”能力生效了，then块中的”模拟”能力剩下了，但其实并不是这样。</p><p>​还记得上面提到，spock支持”模拟”+”存根”同时使用吗，then块中虽然只使用了”模拟”能力，其实隐式的使用了”存根”，then块中的语句隐式转换成了这样 <code>1 * spockTestService.test() &gt;&gt; null</code>。结合上面提到的优先级，所以when块中的mock失效。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-meta">@Slf</span>4j<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSpockNoSpring</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Specification</span> &#123;<br><br>    SpockTestService spockTestService = Mock()<br><br>    <span class="hljs-meta">@IgnoreRest</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-string">&quot;test&quot;</span>() &#123;<br><br>        <span class="hljs-symbol">when:</span><br>        spockTestService.test() &gt;&gt; <span class="hljs-string">&#x27;mock&#x27;</span><span class="hljs-comment">//此mock失效</span><br><br>        <span class="hljs-keyword">def</span> doTest = spockTestService.test()<br>        log.info(<span class="hljs-string">&#x27;CallDoTest:&#123;&#125;&#x27;</span>, String.valueOf(doTest))<br><br>        <span class="hljs-symbol">then:</span><br>        <span class="hljs-number">1</span> * spockTestService.test()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>单元测试</tag>
      
      <tag>Spring</tag>
      
      <tag>Spock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project reactor中的Mono.from操作符</title>
    <link href="/3972953360.html"/>
    <url>/3972953360.html</url>
    
    <content type="html"><![CDATA[<h1 id="project-reactor中的Mono-from操作符"><a href="#project-reactor中的Mono-from操作符" class="headerlink" title="project reactor中的Mono.from操作符"></a>project reactor中的Mono.from操作符</h1><p>​reactor项目中经常会用到Mono.from操作符，主要包含下面四个，他们的返回值如下</p><ul><li><pre><code class="hljs">Mono.fromFuture();  --&gt; MonoCompletionStage</code></pre></li><li><pre><code class="hljs">Mono.fromCallable();       --&gt;MonoCallable</code></pre></li><li><pre><code class="hljs">Mono.fromRunnable();    --&gt;MonoRunnable</code></pre></li><li><pre><code class="hljs">Mono.fromSupplier();      --&gt;MonoSupplier</code></pre></li></ul><p>​这几个类的逻辑非常相似，他们有一个共同特点，就是如果supplier返回null时，不会向下游传递，而是直接complete。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subscribe</span><span class="hljs-params">(CoreSubscriber&lt;? <span class="hljs-built_in">super</span> T&gt; actual)</span> &#123;<br>Operators.MonoSubscriber&lt;T, T&gt;<br>sds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Operators</span>.MonoSubscriber&lt;&gt;(actual);<br><br>actual.onSubscribe(sds);<br><br><span class="hljs-keyword">if</span> (sds.isCancelled()) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">//获取真实值，如果值为null则直接完成，否则将值传递给下游后完成</span><br><span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> supplier.get();<br><span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123;<br>sds.onComplete();<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>sds.complete(t);<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>actual.onError(Operators.onOperatorError(e, actual.currentContext()));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​这个特点很有用，特别是搭配Flux嵌套Mono时，可以不用考虑null值的情况。因为Flux是不允许null值的</p><p>​</p>]]></content>
    
    
    
    <tags>
      
      <tag>reactor</tag>
      
      <tag>Mono.fromCallable</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql 密码算法</title>
    <link href="/2950077868.html"/>
    <url>/2950077868.html</url>
    
    <content type="html"><![CDATA[<h1 id="mysql-密码算法"><a href="#mysql-密码算法" class="headerlink" title="mysql 密码算法"></a>mysql 密码算法</h1><p>mysql 5.x版本后，密码算法有变更，在此记录下来。</p><p>首先看mysql连接时，服务端发送的握手报文，这里主要是保存两个salt</p><p>![image-20220511150444355](&#x2F;img&#x2F;in&#x2F;2022-05-11-mysql 密码算法&#x2F;image-20220511150444355.png)</p><p>然后再看客户端返回的数据包，重要的部分就是用户名密码部分。</p><p>![image-20220511150621224](&#x2F;img&#x2F;in&#x2F;2022-05-11-mysql 密码算法&#x2F;image-20220511150621224.png)</p><p>下面看如何根据上面的信息构建密码。</p><p>其中pass为真实密码，salt为两个salt相加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] scramble(<span class="hljs-type">byte</span>[] pass, <span class="hljs-type">byte</span>[] salt) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">MessageDigest</span> <span class="hljs-variable">md</span> <span class="hljs-operator">=</span> MessageDigest.getInstance(<span class="hljs-string">&quot;SHA-1&quot;</span>); <span class="hljs-comment">//sha1(password)</span><br>        <span class="hljs-type">byte</span>[] passwdShar1 = md.digest(pass);<br>        md.reset();<br><br>        <span class="hljs-type">byte</span>[] d2 = md.digest(passwdShar1); <span class="hljs-comment">// sha1(sha1(password))</span><br>        md.reset();<br>        <span class="hljs-type">byte</span>[] d3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[salt.length + d2.length]; <span class="hljs-comment">//salt + sha1(sha1(password))</span><br>        System.arraycopy(salt, <span class="hljs-number">0</span>, d3, <span class="hljs-number">0</span>, salt.length);<br>        System.arraycopy(d2, <span class="hljs-number">0</span>, d3, salt.length, d2.length);<br>        <span class="hljs-type">byte</span>[] d4 = md.digest(d3); <span class="hljs-comment">//sha1(salt &lt;concat&gt; sha1(sha1(password)))</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; passwdShar1.length; i++) &#123;   <span class="hljs-comment">// XOR</span><br>            passwdShar1[i] = (<span class="hljs-type">byte</span>) (passwdShar1[i] ^ d4[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> passwdShar1;<br>    &#125; <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>伪代码为：</p><p>SHA1( password ) XOR  SHA1(“20-bytes random data from server” <concat> SHA1( SHA1( password ) ) )</p><p>当然该算法在5.7版本试验成功，其他旧版本或新版本均没试过，已抓包结果为准。</p><p>参考链接</p><p><a href="https://stackoverflow.com/questions/48477121/wireshark-password-capture-of-mysql-traffic">https://stackoverflow.com/questions/48477121/wireshark-password-capture-of-mysql-traffic</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring @lazy注解的使用</title>
    <link href="/3264249864.html"/>
    <url>/3264249864.html</url>
    
    <content type="html"><![CDATA[<h1 id="spring-lazy注解的使用"><a href="#spring-lazy注解的使用" class="headerlink" title="spring  @lazy注解的使用"></a>spring  @lazy注解的使用</h1><p>在spring中@lazy注解表达延迟的含义，但在不同情况下，这里的延迟并不是同一层意思。下面将描述我发现的两层含义。</p><h2 id="1-延迟初始化bean"><a href="#1-延迟初始化bean" class="headerlink" title="1. 延迟初始化bean"></a>1. 延迟初始化bean</h2><p>​首先我们知道，容器启动之前会扫描所有的class文件，并将需要加载到容器中的类，整理成BeanDefinition存储。容器启动时将依次将BeanDefinition构建成bean，构建过程中同时解决依赖注入和循环引用的问题。</p><p>​但并不是所有的BeanDefinition都会被构建成bean，观察源码中下面方法 <code>org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</code></p><p>​此为容器启动过程时，从BeanDefinition构建成bean的入口。这里有三种情况不会进行初始化，</p><ol><li><p>非抽象类 </p></li><li><p>是单例模式的bean</p></li><li><p>非Lazy模式的</p><p><strong>所以这里就体现了Lazy的第一层含义，添加Lazy的注解的bean不会在容器启动时主动创建</strong>。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>        logger.trace(<span class="hljs-string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span><br>    <span class="hljs-comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span><br>    List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">this</span>.beanDefinitionNames);<br><br>    <span class="hljs-comment">// Trigger initialization of all non-lazy singleton beans...</span><br>    <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>        <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br>        <span class="hljs-keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;<br>            <span class="hljs-keyword">if</span> (isFactoryBean(beanName)) &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);<br>                <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> FactoryBean) &#123;<br>                    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;<br>                    <span class="hljs-type">boolean</span> isEagerInit;<br>                    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span> &amp;&amp; factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean) &#123;<br>                        isEagerInit = AccessController.doPrivileged(<br>                            (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,<br>                            getAccessControlContext());<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        isEagerInit = (factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean &amp;&amp;<br>                                       ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (isEagerInit) &#123;<br>                        getBean(beanName);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                getBean(beanName);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>有两种方式添加Lazy注解，一种直接在类上加@Lazy注解。一种是如果使用@Bean模式创建的bean，在方法上添加@Lazy注解。</p><p>​但这里Lazy的含义仅仅是不在容器启动时主动生成bean，但可能会被动生成bean。如果bean A被 bean B依赖，A是lazy的，在启动时虽然A不会被主动创建，但在创建B时，需要依赖A，此时A就会被动的创建。</p><p>​所以仅对某个bean的创建添加Lazy意义不是特别大，因为bean相互之间都是有依赖关系的，即使不主动创建也会被被动创建！</p><h2 id="2-延迟依赖注入"><a href="#2-延迟依赖注入" class="headerlink" title="2. 延迟依赖注入"></a>2. 延迟依赖注入</h2><p>第二种Lazy的方式就比较有用了，如下面的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;   <br>    <span class="hljs-meta">@Lazy</span><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> A a;<br>&#125;<br></code></pre></td></tr></table></figure><p>​这个例子中B依赖A。在构建B时需要将A注入，但是我们添加了@Lazy注解，注入时并不会真的从容器中查找A，而是注入一个A的动态代理。在运行阶段，调用动态代理类的方法时，才会真的从容器中查找A。</p><p>​下面代码是<code>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor</code></p><p>的内部类，这里是负责依赖注入时查找依赖的部分，<code>getResourceToInject</code>方法里进行判断，如我上面讲的，如果是lazy的依赖则会生成动态代理，否则才会从容器中真实获取。</p><p>​<code>lazyLookup</code>变量的在<code>ResourceElement</code>的构造方法里获取的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LookupElement</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> lazyLookup;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ResourceElement</span><span class="hljs-params">(Member member, AnnotatedElement ae, <span class="hljs-meta">@Nullable</span> PropertyDescriptor pd)</span> &#123;<br>        <span class="hljs-built_in">super</span>(member, pd);<br>        <span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> ae.getAnnotation(Resource.class);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">resourceName</span> <span class="hljs-operator">=</span> resource.name();<br>        Class&lt;?&gt; resourceType = resource.type();<br>        <span class="hljs-built_in">this</span>.isDefaultName = !StringUtils.hasLength(resourceName);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isDefaultName) &#123;<br>            resourceName = <span class="hljs-built_in">this</span>.member.getName();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.member <span class="hljs-keyword">instanceof</span> Method &amp;&amp; resourceName.startsWith(<span class="hljs-string">&quot;set&quot;</span>) &amp;&amp; resourceName.length() &gt; <span class="hljs-number">3</span>) &#123;<br>                resourceName = Introspector.decapitalize(resourceName.substring(<span class="hljs-number">3</span>));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (embeddedValueResolver != <span class="hljs-literal">null</span>) &#123;<br>            resourceName = embeddedValueResolver.resolveStringValue(resourceName);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Object.class != resourceType) &#123;<br>            checkResourceType(resourceType);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// No resource type specified... check field/method.</span><br>            resourceType = getResourceType();<br>        &#125;<br>        <span class="hljs-built_in">this</span>.name = (resourceName != <span class="hljs-literal">null</span> ? resourceName : <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-built_in">this</span>.lookupType = resourceType;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">lookupValue</span> <span class="hljs-operator">=</span> resource.lookup();<br>        <span class="hljs-built_in">this</span>.mappedName = (StringUtils.hasLength(lookupValue) ? lookupValue : resource.mappedName());<br>        <span class="hljs-type">Lazy</span> <span class="hljs-variable">lazy</span> <span class="hljs-operator">=</span> ae.getAnnotation(Lazy.class);<br>        <span class="hljs-built_in">this</span>.lazyLookup = (lazy != <span class="hljs-literal">null</span> &amp;&amp; lazy.value());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getResourceToInject</span><span class="hljs-params">(Object target, <span class="hljs-meta">@Nullable</span> String requestingBeanName)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.lazyLookup ? buildLazyResourceProxy(<span class="hljs-built_in">this</span>, requestingBeanName) :<br>                getResource(<span class="hljs-built_in">this</span>, requestingBeanName));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-配合使用"><a href="#3-配合使用" class="headerlink" title="3.配合使用"></a>3.配合使用</h2><p>综上所述，如果将@Lazy 添加在类上，虽不会主动创建，但被依赖时还会被创建。</p><p>如果将@Lazy添加到注入的字段上，可以推迟注入的时间到运行时，但依赖已经被创建了，只是没注入而已，该耗费的时间也已经耗费了。</p><p>将两者配合使用，即可达到运行时再创建需要的对象，如果不需要可一直不创建。</p>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>技巧</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jackson序列化优先级和注解顺序</title>
    <link href="/2508935463.html"/>
    <url>/2508935463.html</url>
    
    <content type="html"><![CDATA[<h1 id="jackson序列化优先级和注解顺序"><a href="#jackson序列化优先级和注解顺序" class="headerlink" title="jackson序列化优先级和注解顺序"></a>jackson序列化优先级和注解顺序</h1><p>先说结论：<br>序列化时getter方法优先于字段，注解添加到字段上或添加在getter方法上同样生效。</p><h2 id="1-创建serializerProvider调用serializeValue方法"><a href="#1-创建serializerProvider调用serializeValue方法" class="headerlink" title="1. 创建serializerProvider调用serializeValue方法"></a>1. 创建serializerProvider调用serializeValue方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">_writeValueAndClose</span><span class="hljs-params">(JsonGenerator g, Object value)</span><br>    <span class="hljs-keyword">throws</span> IOException<br>&#123;<br>    <span class="hljs-type">SerializationConfig</span> <span class="hljs-variable">cfg</span> <span class="hljs-operator">=</span> getSerializationConfig();<br>    <span class="hljs-keyword">if</span> (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) &amp;&amp; (value <span class="hljs-keyword">instanceof</span> Closeable)) &#123;<br>        _writeCloseable(g, value, cfg);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        _serializerProvider(cfg).serializeValue(g, value);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        ClassUtil.closeOnFailAndThrowAsIOE(g, e);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    g.close();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-获取JsonSerializer，并使用它进行序列化"><a href="#2-获取JsonSerializer，并使用它进行序列化" class="headerlink" title="2. 获取JsonSerializer，并使用它进行序列化"></a>2. 获取JsonSerializer，并使用它进行序列化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serializeValue</span><span class="hljs-params">(JsonGenerator gen, Object value)</span> <span class="hljs-keyword">throws</span> IOException<br>&#123;<br>    _generator = gen;<br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>        _serializeNull(gen);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> Class&lt;?&gt; cls = value.getClass();<br>    <span class="hljs-comment">// true, since we do want to cache root-level typed serializers (ditto for null property)</span><br>    <span class="hljs-keyword">final</span> JsonSerializer&lt;Object&gt; ser = findTypedValueSerializer(cls, <span class="hljs-literal">true</span>, <span class="hljs-literal">null</span>);<br>    <span class="hljs-type">PropertyName</span> <span class="hljs-variable">rootName</span> <span class="hljs-operator">=</span> _config.getFullRootName();<br>    <span class="hljs-keyword">if</span> (rootName == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// not explicitly specified</span><br>        <span class="hljs-keyword">if</span> (_config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE)) &#123;<br>            _serialize(gen, value, ser, _config.findRootName(cls));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!rootName.isEmpty()) &#123;<br>        _serialize(gen, value, ser, rootName);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    _serialize(gen, value, ser);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-此方法核心在第二行，会创建BeanDescription"><a href="#3-此方法核心在第二行，会创建BeanDescription" class="headerlink" title="3. 此方法核心在第二行，会创建BeanDescription"></a>3. 此方法核心在第二行，会创建BeanDescription</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> JsonSerializer&lt;Object&gt; <span class="hljs-title function_">createSerializer</span><span class="hljs-params">(SerializerProvider prov,</span><br><span class="hljs-params">            JavaType origType)</span><br>        <span class="hljs-keyword">throws</span> JsonMappingException<br>    &#123;<br>        <span class="hljs-comment">// Very first thing, let&#x27;s check if there is explicit serializer annotation:</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">SerializationConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> prov.getConfig();<br>        <span class="hljs-type">BeanDescription</span> <span class="hljs-variable">beanDesc</span> <span class="hljs-operator">=</span> config.introspect(origType);<br>        JsonSerializer&lt;?&gt; ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());<br>        <span class="hljs-keyword">if</span> (ser != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> (JsonSerializer&lt;Object&gt;) ser;<br>        &#125;<br>        <span class="hljs-type">boolean</span> staticTyping;<br>        <span class="hljs-comment">// Next: we may have annotations that further indicate actual type to use (a super type)</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">AnnotationIntrospector</span> <span class="hljs-variable">intr</span> <span class="hljs-operator">=</span> config.getAnnotationIntrospector();<br>        JavaType type;<br><br>        <span class="hljs-keyword">if</span> (intr == <span class="hljs-literal">null</span>) &#123;<br>            type = origType;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                type = intr.refineSerializationType(config, beanDesc.getClassInfo(), origType);<br>            &#125; <span class="hljs-keyword">catch</span> (JsonMappingException e) &#123;<br>                <span class="hljs-keyword">return</span> prov.reportBadTypeDefinition(beanDesc, e.getMessage());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (type == origType) &#123; <span class="hljs-comment">// no changes, won&#x27;t force static typing</span><br>            staticTyping = <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// changes; assume static typing; plus, need to re-introspect if class differs</span><br>            staticTyping = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (!type.hasRawClass(origType.getRawClass())) &#123;<br>                beanDesc = config.introspect(type);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// Slight detour: do we have a Converter to consider?</span><br>        Converter&lt;Object,Object&gt; conv = beanDesc.findSerializationConverter();<br>        <span class="hljs-keyword">if</span> (conv == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// no, simple</span><br>            <span class="hljs-keyword">return</span> (JsonSerializer&lt;Object&gt;) _createSerializer2(prov, type, beanDesc, staticTyping);<br>        &#125;<br>        <span class="hljs-type">JavaType</span> <span class="hljs-variable">delegateType</span> <span class="hljs-operator">=</span> conv.getOutputType(prov.getTypeFactory());<br>        <br>        <span class="hljs-comment">// One more twist, as per [databind#288]; probably need to get new BeanDesc</span><br>        <span class="hljs-keyword">if</span> (!delegateType.hasRawClass(type.getRawClass())) &#123;<br>            beanDesc = config.introspect(delegateType);<br>            <span class="hljs-comment">// [#359]: explicitly check (again) for @JsonSerializer...</span><br>            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());<br>        &#125;<br>        <span class="hljs-comment">// [databind#731]: Should skip if nominally java.lang.Object</span><br>        <span class="hljs-keyword">if</span> (ser == <span class="hljs-literal">null</span> &amp;&amp; !delegateType.isJavaLangObject()) &#123;<br>            ser = _createSerializer2(prov, delegateType, beanDesc, <span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StdDelegatingSerializer</span>(conv, delegateType, ser);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="4-BeanDescription内的findProperties方法，"><a href="#4-BeanDescription内的findProperties方法，" class="headerlink" title="4. BeanDescription内的findProperties方法，"></a>4. BeanDescription内的findProperties方法，</h2><blockquote><p>此方法触发时将对class进行解析，解析过程如下，<strong>这里就解释了注解加在字段上或方法上同样生效的</strong>。 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">collectAll</span><span class="hljs-params">()</span><br>&#123;<br>    LinkedHashMap&lt;String, POJOPropertyBuilder&gt; props = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;String, POJOPropertyBuilder&gt;();<br><br>    <span class="hljs-comment">//使用反射获取字段</span><br>    _addFields(props); <br><br>    <span class="hljs-comment">//使用反射获取getter，setter方法</span><br>    _addMethods(props);<br><br>    <span class="hljs-comment">//合并注解，此处会将方法上的注解和字段上的注解进行合并在一起，这就解释了注解加在字段和方法上同样有效</span><br>    <span class="hljs-keyword">for</span> (POJOPropertyBuilder property : props.values()) &#123;<br>        property.mergeAnnotations(_forSerialization);<br>    &#125;<br>    _properties = props;<br>    _collected = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-为何方法优于字段"><a href="#5-为何方法优于字段" class="headerlink" title="5. 为何方法优于字段"></a>5. 为何方法优于字段</h2><blockquote><p>在BeanSerializerFactory方法中存在下面方法，会从BeanPropertyDefinition中构建AnnotatedMember，而getAccessor()方法是优先检测getter方法再检测field，<strong>故序列化时方法优先于字段</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> List&lt;BeanPropertyWriter&gt; <span class="hljs-title function_">findBeanProperties</span><span class="hljs-params">(SerializerProvider prov,</span><br><span class="hljs-params">            BeanDescription beanDesc, BeanSerializerBuilder builder)</span><br>        <span class="hljs-keyword">throws</span> JsonMappingException<br>    &#123;<br>        List&lt;BeanPropertyDefinition&gt; properties = beanDesc.findProperties();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">SerializationConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> prov.getConfig();<br><br>        <span class="hljs-comment">// ignore specified types</span><br>        removeIgnorableTypes(config, beanDesc, properties);<br>        <br>        <span class="hljs-comment">// and possibly remove ones without matching mutator...</span><br>        <span class="hljs-keyword">if</span> (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) &#123;<br>            removeSetterlessGetters(config, beanDesc, properties);<br>        &#125;<br>        <br>        <span class="hljs-comment">// nothing? can&#x27;t proceed (caller may or may not throw an exception)</span><br>        <span class="hljs-keyword">if</span> (properties.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// null is for value type serializer, which we don&#x27;t have access to from here (ditto for bean prop)</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">staticTyping</span> <span class="hljs-operator">=</span> usesStaticTyping(config, beanDesc, <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">PropertyBuilder</span> <span class="hljs-variable">pb</span> <span class="hljs-operator">=</span> constructPropertyBuilder(config, beanDesc);<br>        <br>        ArrayList&lt;BeanPropertyWriter&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;BeanPropertyWriter&gt;(properties.size());<br>        <span class="hljs-keyword">for</span> (BeanPropertyDefinition property : properties) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">AnnotatedMember</span> <span class="hljs-variable">accessor</span> <span class="hljs-operator">=</span> property.getAccessor();<br>            <span class="hljs-comment">// Type id? Requires special handling:</span><br>            <span class="hljs-keyword">if</span> (property.isTypeId()) &#123;<br>                <span class="hljs-keyword">if</span> (accessor != <span class="hljs-literal">null</span>) &#123;<br>                    builder.setTypeId(accessor);<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// suppress writing of back references</span><br>            AnnotationIntrospector.<span class="hljs-type">ReferenceProperty</span> <span class="hljs-variable">refType</span> <span class="hljs-operator">=</span> property.findReferenceType();<br>            <span class="hljs-keyword">if</span> (refType != <span class="hljs-literal">null</span> &amp;&amp; refType.isBackReference()) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (accessor <span class="hljs-keyword">instanceof</span> AnnotatedMethod) &#123;<br>                result.add(_constructWriter(prov, property, pb, staticTyping, (AnnotatedMethod) accessor));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result.add(_constructWriter(prov, property, pb, staticTyping, (AnnotatedField) accessor));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> AnnotatedMember <span class="hljs-title function_">getAccessor</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">AnnotatedMember</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> getGetter();<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-literal">null</span>) &#123;<br>            m = getField();<br>        &#125;<br>        <span class="hljs-keyword">return</span> m;<br>    &#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>jackson</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring中ObjectFactory , ObjectProvider 和 FactoryBean</title>
    <link href="/2725444583.html"/>
    <url>/2725444583.html</url>
    
    <content type="html"><![CDATA[<h1 id="spring中ObjectFactory-ObjectProvider-和-FactoryBean"><a href="#spring中ObjectFactory-ObjectProvider-和-FactoryBean" class="headerlink" title="spring中ObjectFactory , ObjectProvider 和 FactoryBean"></a>spring中ObjectFactory , ObjectProvider 和 FactoryBean</h1><h2 id="ObjectFactory-ObjectProvider"><a href="#ObjectFactory-ObjectProvider" class="headerlink" title="ObjectFactory , ObjectProvider"></a>ObjectFactory , ObjectProvider</h2><p>这两个类是spring的提供的工厂方法的辅助类，<br>ObjectFactory在 1.0.2版本添加进去的，他只有一个getObject方法<br>ObjectProvider在4.3版本添加，它继承了ObjectFactory接口，添加了更多方法，如<code>getIfAvailable</code>，这种可选方法。</p><p>请看下面的相关源码，这里是解析自动注入依赖的方法，他会检测到依赖注入的是Optional,ObjectFactory,ObjectProvider,Provider进行特殊处理。</p><p><code>org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveDependency</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">resolveDependency</span><span class="hljs-params">(DependencyDescriptor descriptor, <span class="hljs-meta">@Nullable</span> String requestingBeanName,</span><br><span class="hljs-params">        <span class="hljs-meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="hljs-meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><br>    descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());<br>    <span class="hljs-keyword">if</span> (Optional.class == descriptor.getDependencyType()) &#123;<br>        <span class="hljs-keyword">return</span> createOptionalDependency(descriptor, requestingBeanName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ObjectFactory.class == descriptor.getDependencyType() ||<br>            ObjectProvider.class == descriptor.getDependencyType()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DependencyObjectProvider</span>(descriptor, requestingBeanName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jsr330Factory</span>().createDependencyProvider(descriptor, requestingBeanName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(<br>                descriptor, requestingBeanName);<br>        <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>            result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了上面两个类之外，还可以使用 <code>javax.inject.Provider</code>类代替，但功能比较简单和ObjectFactory一致。<br>ObjectFactory , ObjectProvider主要在依赖注入时使用，如注入不一定存在的bean，或者注入非单例的bean，这样每次都能获取到新的对象。</p><p>如何使用这两个类呢，下面是一个示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SchoolService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    ObjectFactory&lt;StudentService&gt; studentServiceObjectFactory;<br>    <br>    <span class="hljs-meta">@Resource</span><br>    ObjectProvider&lt;StudentService&gt; studentServiceObjectProvider;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>        <br>        <span class="hljs-comment">//1. 使用ObjectFactory，从容器中获取bean</span><br>        <span class="hljs-type">StudentService</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> studentServiceObjectFactory.getObject();<br>        <br><br>        <span class="hljs-comment">//2. 使用ObjectProvider获取bean</span><br>        <span class="hljs-type">StudentService</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> studentServiceObjectProvider.getObject();<br>        <br>        <span class="hljs-comment">//3. 使用ObjectProvider获取bean，如果不存在返回null</span><br>        <span class="hljs-type">StudentService</span> <span class="hljs-variable">ifAvailable</span> <span class="hljs-operator">=</span> studentServiceObjectProvider.getIfAvailable();<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><p>factoryBean与上面两个没有太大联系，他属于bean的生产者，有时我们要手工控制bean的创建过程，可以使用这个。如下示例：</p><p>该示例创建一个StudentServiceFactory，用于生产StudentService，默认生产的对象会被缓存。<br>如果其他类需要使用StudentService时，会先从容器中获取到该工厂，然后使用工厂生产一个StudentService。<br>再说一遍，生产的此对象默认会被缓存，下次再获取时就不会再生产了，可通过从写FactoryBean的方法控制是否单例模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentServiceFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span>&lt;StudentService&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> StudentService <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StudentService</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;<br>        <span class="hljs-keyword">return</span> StudentService.class;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个FactoryBean可以实现对象更复杂的创建过程，如根据接口动态代理生成一个Bean（没错Mybatis的mapper就是这个原理）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ObjectFactory , ObjectProvider 和 FactoryBean虽然名称相似，但是作用却不同。</p><p>ObjectFactory是初版提供的，用于实现非单例模式的依赖注入时多次获取不同对象。</p><p>ObjectProvider是4.x版本提供的，与ObjectFactory功能类似，但提供了更多方法，如<code>getIfAvailable()</code>这样的方法.</p><p>FactoryBean是控制复杂对象的创建用的，与上面两个并没有关系。</p>]]></content>
    
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>ObjectFactory</tag>
      
      <tag>ObjectProvider</tag>
      
      <tag>FactoryBean</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>project reactor中的onErrorXxx操作符</title>
    <link href="/479676580.html"/>
    <url>/479676580.html</url>
    
    <content type="html"><![CDATA[<h1 id="project-reactor中的onErrorXxx操作符"><a href="#project-reactor中的onErrorXxx操作符" class="headerlink" title="project reactor中的onErrorXxx操作符"></a>project reactor中的onErrorXxx操作符</h1><p>​reactor项目中存在很多操作符其中一些与处理异常有关的操作符，它们都以onError开头，一共五个下面我们逐个分析他们。</p><ul><li>onErrorMap</li><li>onErrorResume</li><li>onErrorReturn</li><li>onErrorContinue</li><li>onErrorStop</li></ul><h2 id="三个是用来处理上游传递的错误信号"><a href="#三个是用来处理上游传递的错误信号" class="headerlink" title="三个是用来处理上游传递的错误信号"></a>三个是用来处理上游传递的错误信号</h2><p>这三个是一组的，他们原理类似，分别是：</p><ul><li>onErrorMap</li><li>onErrorReturn</li><li>onErrorResume</li></ul><p>onErrorMap 需要传递一个 <code>Function&lt;? super Throwable, ? extends Throwable&gt; mapper</code>，他表示将upStream传递的错误转换成另一种错误返回，即替换upStream中产生的错误。要求Function函数返回值必须非空，否则报空指针。</p><p>onErrorReturn需要传递一个值，即fallback。它会将upStream传递的error信号吞掉，用给定的值替换向下传递，并且upStream已经发出error信号，也就是已经终止了。对于下游订阅者来说，感知不到错误信号，且此时fallback值就是是最后一个元素了。</p><p>onErrorResume 使用一个fallback 流代替upStream，即对于下游订阅者来说，原始流发出error信号后会被吞掉，然后接着从fallback流中订阅。即fallback流连接在upStream发生错误的位置继续产生元素。</p><p>​这三个都是下游对错误信号的处理操作符，当接收到错误信号时如何向下游传递。默认情况下没有这三个操作符时，错误信号是透传给下游的，这三个操作符提供在中间拦截的能力。其中onErrorResume可以实现onErrorMap和onErrorReturn的功能。</p><p>​这三个的实现原理如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//当上游传递错误信号时</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(Throwable t)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!second) &#123;<br>        second = <span class="hljs-literal">true</span>;<br><br>        Publisher&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; p;<br><br>        <span class="hljs-comment">//使用给定的Function创建一个新的生产者</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            p = Objects.requireNonNull(nextFactory.apply(t),<br>                                       <span class="hljs-string">&quot;The nextFactory returned a null Publisher&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            <span class="hljs-type">Throwable</span> <span class="hljs-variable">_e</span> <span class="hljs-operator">=</span> Operators.onOperatorError(e, actual.currentContext());<br>            _e = Exceptions.addSuppressed(_e, t);<br>            actual.onError(_e);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//继续订阅新的生产者。对下游来说没有感知到发生了错误信号</span><br>        p.subscribe(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        actual.onError(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="两个用来指示上游如何处理发生的错误"><a href="#两个用来指示上游如何处理发生的错误" class="headerlink" title="两个用来指示上游如何处理发生的错误"></a>两个用来指示上游如何处理发生的错误</h2><p>​这两个是一组，他们与上面三个原理不同。</p><ul><li>onErrorContinue</li><li>onErrorStop</li></ul><p>​        他们会给Context设置上错误处理策略，当upStream产生错误准备调用下游的onError时，可以从context中获取该策略对错误进行处理。如设置的策略是onErrorContinue，则可以跳过此错误当作此元素没发生过一样继续处理下一个元素。如设置的策略是OnErrorStop则会将错误向下游传递，并取消上游的订阅。</p><p>​虽然我们设置了错误处理策略，但只是对upStream的建议，upStream会不会使用它，downStream无法决定，只有一部分操作符会使用Context内设置的错误处理策略。</p><p>这两个操作符的原理如下:</p><p>​调用<code>onErrorContinue</code>时，将OnNextFailureStrategy 设置到Context中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//方法调用时，将OnNextFailureStrategy 设置到Context中</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Mono&lt;T&gt; <span class="hljs-title function_">onErrorContinue</span><span class="hljs-params">(BiConsumer&lt;Throwable, Object&gt; errorConsumer)</span> &#123;<br>    BiConsumer&lt;Throwable, Object&gt; genericConsumer = errorConsumer;<br>    <span class="hljs-keyword">return</span> subscriberContext(Context.of(<br>        OnNextFailureStrategy.KEY_ON_NEXT_ERROR_STRATEGY,<br>        OnNextFailureStrategy.resume(genericConsumer)<br>    ));<br>&#125;<br></code></pre></td></tr></table></figure><p>​在某个操作符内部发生错误，如map操作符内调用onNext发生错误。</p><p>此时会使用<code>Operators.onNextError</code>处理该错误，如果处理过后返回值为null，则忽略错误向upStream请求下一个元素，如果返回值非null，则将错误传递下去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNext</span><span class="hljs-params">(T t)</span> &#123;<br><span class="hljs-keyword">if</span> (done) &#123;<br>Operators.onNextDropped(t, actual.currentContext());<br><span class="hljs-keyword">return</span>;<br>&#125;<br>R v;<br><span class="hljs-keyword">try</span> &#123;<br>v = Objects.requireNonNull(mapper.apply(t),<br><span class="hljs-string">&quot;The mapper returned a null value.&quot;</span>);<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        <span class="hljs-comment">//发生错误，使用此方法处理</span><br><span class="hljs-type">Throwable</span> <span class="hljs-variable">e_</span> <span class="hljs-operator">=</span> Operators.onNextError(t, e, actual.currentContext(), s);<br><span class="hljs-comment">//如果返回值有值，将错误向下传递。如果返回null，则忽略错误继续从上游生产者中订阅</span><br>        <span class="hljs-keyword">if</span> (e_ != <span class="hljs-literal">null</span>) &#123;<br>onError(e_);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>s.request(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>actual.onNext(v);<br>&#125;<br></code></pre></td></tr></table></figure><p>​Operators.onNextError 这里会先获取错误处理策略，根据策略做处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Throwable <span class="hljs-title function_">onNextError</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> T value, Throwable error, Context context,</span><br><span class="hljs-params">Subscription subscriptionForCancel)</span> &#123;<br>error = unwrapOnNextError(error);<br><span class="hljs-type">OnNextFailureStrategy</span> <span class="hljs-variable">strategy</span> <span class="hljs-operator">=</span> onNextErrorStrategy(context);<br><span class="hljs-keyword">if</span> (strategy.test(error, value)) &#123;<br><span class="hljs-comment">//some strategies could still return an exception, eg. if the consumer throws</span><br><span class="hljs-type">Throwable</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> strategy.process(error, value, context);<br><span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>subscriptionForCancel.cancel();<br>&#125;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//falls back to operator errors</span><br><span class="hljs-keyword">return</span> onOperatorError(subscriptionForCancel, error, value, context);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​默认我们不配置任何策略时，处理策略是 <code>OnNextFailureStrategy.STOP</code>，即取消订阅upStream，并将错误向下传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> OnNextFailureStrategy <span class="hljs-title function_">onNextErrorStrategy</span><span class="hljs-params">(Context context)</span> &#123;<br><span class="hljs-type">OnNextFailureStrategy</span> <span class="hljs-variable">strategy</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>BiFunction&lt;? <span class="hljs-built_in">super</span> Throwable, Object, ? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; fn = context.getOrDefault(<br>OnNextFailureStrategy.KEY_ON_NEXT_ERROR_STRATEGY, <span class="hljs-literal">null</span>);<br><span class="hljs-keyword">if</span> (fn <span class="hljs-keyword">instanceof</span> OnNextFailureStrategy) &#123;<br>strategy = (OnNextFailureStrategy) fn;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fn != <span class="hljs-literal">null</span>) &#123;<br>strategy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OnNextFailureStrategy</span>.LambdaOnNextErrorStrategy(fn);<br>&#125;<br><span class="hljs-keyword">if</span> (strategy == <span class="hljs-literal">null</span>) strategy = Hooks.onNextErrorHook;<br><span class="hljs-keyword">if</span> (strategy == <span class="hljs-literal">null</span>) strategy = OnNextFailureStrategy.STOP;<br><span class="hljs-keyword">return</span> strategy;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>onErrorMap</p><p>onErrorResume</p><p>onErrorReturn</p><p>onErrorContinue</p><p>onErrorStop</p><p>​这五个操作符虽然都是以onError开头，但根据原理可以分为两类。一类是如何处理上游传递的error信号，但无论怎么处理，error信号产生后upStream就算完结了。另一类将错误处理策略设置在Context内，上游产生错误后可以根据策略决定是否终止生产。</p><p>​并且onErrorMap，onErrorResume，onErrorReturn只对上游产生的错误负责，该操作符下游产生的错误无法被处理。</p><p>​而onErrorContinue，onErrorStop操作符是在被订阅时将处理策略放置在Context内，而Context是同一个对象，也就说订阅过程中操作符下游发生错误，此时还没将策略放置到Context内，此操作符不生效。而订阅过程中上游发生错误，会以后处理数据时发生错误，因为该操作符被订阅时已经将处理策略放置到Context内了，所以策略总是生效的。</p><p>​所以这两个操作符建议放在比较靠后的位置。</p>]]></content>
    
    
    
    <tags>
      
      <tag>reactor</tag>
      
      <tag>onErrorMap</tag>
      
      <tag>onErrorResume</tag>
      
      <tag>onErrorReturn</tag>
      
      <tag>onErrorContinue</tag>
      
      <tag>onErrorStop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis dynamic查询指定字段</title>
    <link href="/3230586475.html"/>
    <url>/3230586475.html</url>
    
    <content type="html"><![CDATA[<h1 id="mybatis-dynamic查询指定字段"><a href="#mybatis-dynamic查询指定字段" class="headerlink" title="mybatis dynamic查询指定字段"></a>mybatis dynamic查询指定字段</h1><p>​使用mybatis dynamic做查询是，通常情况下会查询所有字段，因为多查几个字段对性能影响不会很大。但是有些情况下，查询记录数量较多，多查的字段就有很大的影响了。<br>此时我们希望只查询指定的字段。</p><h2 id="第一种写法"><a href="#第一种写法" class="headerlink" title="第一种写法"></a>第一种写法</h2><p>一般写法是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">testMapper.selectMany(MyBatis3Utils.select(columns,test, dsl-&gt;&#123;<br>            dsl.where(reconSerialNo,SqlBuilder.isEqualTo(<span class="hljs-string">&quot;xxx&quot;</span>))<br>        &#125;))<br></code></pre></td></tr></table></figure><p>我们需要传递三个参数，第一个参数为想要查询的列数组，第二个参数为想要查询的表，第三个参数为SelectDSLCompleter 查询条件。</p><p>其原理就是使用Mybatis3Utils构建一个SelectStatementProvider对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SelectStatementProvider <span class="hljs-title function_">select</span><span class="hljs-params">(BasicColumn[] selectList, SqlTable table,        SelectDSLCompleter completer)</span> &#123;   <br>    <span class="hljs-keyword">return</span> select(SqlBuilder.select(selectList).from(table), completer);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第二种写法"><a href="#第二种写法" class="headerlink" title="第二种写法"></a>第二种写法</h2><p>除此之外，我么还可以像下面这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">testMapper.select(dsl-&gt;&#123;    <br>    SqlBuilder.select(columns).from(test).where(reconSerialNo, SqlBuilder.isEqualTo(<span class="hljs-string">&quot;xxx&quot;</span>))<br>&#125;)<br></code></pre></td></tr></table></figure><p>​第二种写法不通过参数传递字段和表名，而是在dsl覆盖掉字段和表名。按照第一种写法查看其源码，SelectDSLCompleter的参数dsl本身就是 <code>SqlBuilder.select(columns).from(test)</code>，我们没有使用它，而是在dsl内部重写了，忽略回调传递的参数，从而实现查询指定字段。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mybatis</tag>
      
      <tag>mybatis dynamic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flux parallel操作符的用法</title>
    <link href="/2205464017.html"/>
    <url>/2205464017.html</url>
    
    <content type="html"><![CDATA[<h1 id="Flux-parallel操作符"><a href="#Flux-parallel操作符" class="headerlink" title="Flux parallel操作符"></a>Flux parallel操作符</h1><h2 id="1-parallel操作符"><a href="#1-parallel操作符" class="headerlink" title="1. parallel操作符"></a>1. parallel操作符</h2><p>​parallel操作符执行过后，会生成一个新的flux 即parallelFLux。他能够接受多个订阅者，他会从原始flux中请求perfetch个元素，将上游传递push过来的元素依次按顺序分配给子订阅者。</p><p>​分配上游元素过程是：依次分配给下游每个订阅者，当某个子订阅者请求数已经满足时，将跳过此订阅者继续向下一个子订阅者分配。</p><p>​他有两个个参数 parallelism 和 prefetch，第一个参数表示划分子流的数量默认等于cpu核心数，prefetch表示向原始流预取的数量。</p><h2 id="2-parallel操作符后接map操作符"><a href="#2-parallel操作符后接map操作符" class="headerlink" title="2. parallel操作符后接map操作符"></a>2. parallel操作符后接map操作符</h2><pre><code class="hljs">map操作符会将真实订阅者生成代理，他将上游onNext的值使用map操作符进行转换。在parallelFlux场景下，它会将每个子订阅者包装起来进行转换。</code></pre><h2 id="3-parallel后面可以接Sequential操作符"><a href="#3-parallel后面可以接Sequential操作符" class="headerlink" title="3. parallel后面可以接Sequential操作符"></a>3. parallel后面可以接Sequential操作符</h2><p>​可以将parallelFlux转成普通flux，他的原理是创建parallel需要的子订阅者，使用子订阅者订阅parallelFlux，然后将数据依次从每个子订阅者中获取到数据，向下游发送。<br>​在sequential操作执行时，数据可能来自多个线程，这里采用的是哪个线程先到则负责将其他子订阅者队列中的值向下发，没获取到锁的线程存入队列直接退出。允许传递参数，表示每个子订阅者身上能存储的元素最大数。<br>（这里想到支持并发的websocket也是这个原理）</p><h2 id="4-parallel后接runOn操作符"><a href="#4-parallel后接runOn操作符" class="headerlink" title="4.parallel后接runOn操作符"></a>4.parallel后接runOn操作符</h2><p>​本质上是包装每个子订阅者，将接受到的数据存入子订阅者的queue中，然后使用线程池处理queue内的数据。<br>处理的逻辑也是和上面Sequential类似，使用AtomicInteger限制每个子订阅者同时只会有一个线程在执行，如果当前已经存在一个线程在执行，后来的数据存入queue后会直接退出。</p><p>​它还可以传递第二个参数表示每个子订阅者预取的数量，这里为什么要预取呢，是因为如果下游订阅者请求了非常大的数量，而runOn将任务分配到线程池中本身是非堵塞的，也就是任务全部堆积在线程池中，可能导致内存溢出。所以使用预取参数分批次满足下游的请求数量。</p>]]></content>
    
    
    
    <tags>
      
      <tag>flux</tag>
      
      <tag>parallel</tag>
      
      <tag>reactor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reactor中的线程池</title>
    <link href="/933416019.html"/>
    <url>/933416019.html</url>
    
    <content type="html"><![CDATA[<h1 id="reactor中的线程池"><a href="#reactor中的线程池" class="headerlink" title="reactor中的线程池"></a>reactor中的线程池</h1><h2 id="1-DelegateServiceScheduler"><a href="#1-DelegateServiceScheduler" class="headerlink" title="1.DelegateServiceScheduler"></a>1.DelegateServiceScheduler</h2><p>将任务委托给底层单个线程池，和直接使用线程池无本质区别。</p><h2 id="2-SingleScheduler"><a href="#2-SingleScheduler" class="headerlink" title="2.SingleScheduler"></a>2.SingleScheduler</h2><p>单线程的scheduler，和java自带的一致。<br>​</p><h2 id="3-ImmediateScheduler"><a href="#3-ImmediateScheduler" class="headerlink" title="3.ImmediateScheduler"></a>3.ImmediateScheduler</h2><p>在主线程执行的scheduler。</p><h2 id="4-ParallelScheduler"><a href="#4-ParallelScheduler" class="headerlink" title="4.ParallelScheduler"></a>4.ParallelScheduler</h2><p>此scheduler会将任务均匀分配给内部的单线程线程池执行，核心逻辑十分简单，就是均匀的分配，不对任务的执行时间进行区分。<br>运气不好时会将耗时长的任务放置到同一个线程内，导致该线程执行时间过长，所以理论上用来执行非堵塞的任务比较好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledExecutorService <span class="hljs-title function_">pick</span><span class="hljs-params">()</span> &#123;<br>    ScheduledExecutorService[] a = executors;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span>) &#123;<br>        start();<br>        a = executors;<br>        <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;executors uninitialized after implicit start()&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a != SHUTDOWN) &#123;<br>        <span class="hljs-comment">// ignoring the race condition here, its already random who gets which executor</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> roundRobin;<br>        <span class="hljs-keyword">if</span> (idx == n) &#123;<br>            idx = <span class="hljs-number">0</span>;<br>            roundRobin = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            roundRobin = idx + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a[idx];<br>    &#125;<br>    <span class="hljs-keyword">return</span> TERMINATED;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-BoundedElasticScheduler"><a href="#5-BoundedElasticScheduler" class="headerlink" title="5.BoundedElasticScheduler"></a>5.BoundedElasticScheduler</h2><p>   类似于ParallelScheduler，底层也是若干个单线程线程池，但是在任务分配上做了优化。底层会判断哪个线程池当前任务量最少，优先将任务分配给任务量最少的线程池。<br>判断哪个线程池当前任务量最少使用的是优先级队列，每次获取队列头的线程池。并且当子线程池没有任务时，将进入idleQueue中，一段时间不使用会进行回收。<br>适合执行堵塞的任务，不宜执行大量非堵塞的任务，因为非堵塞任务执行很快，使用下面复杂的pick过程反而更耗时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java">BoundedState <span class="hljs-title function_">pick</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> get();<br><span class="hljs-keyword">if</span> (a == DISPOSED) &#123;<br><span class="hljs-keyword">return</span> CREATING; <span class="hljs-comment">//synonym for shutdown, since the underlying executor is shut down</span><br>&#125;<br><br><span class="hljs-keyword">if</span> (!idleQueue.isEmpty()) &#123;<br><span class="hljs-comment">//try to find an idle resource</span><br><span class="hljs-type">BoundedState</span> <span class="hljs-variable">bs</span> <span class="hljs-operator">=</span> idleQueue.pollLast();<br><span class="hljs-keyword">if</span> (bs != <span class="hljs-literal">null</span> &amp;&amp; bs.markPicked()) &#123;<br>busyQueue.add(bs);<br><span class="hljs-keyword">return</span> bs;<br>&#125;<br><span class="hljs-comment">//else optimistically retry (implicit continue here)</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a &lt; parent.maxThreads) &#123;<br><span class="hljs-comment">//try to build a new resource</span><br><span class="hljs-keyword">if</span> (compareAndSet(a, a + <span class="hljs-number">1</span>)) &#123;<br><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Schedulers.decorateExecutorService(parent, parent.createBoundedExecutorService());<br><span class="hljs-type">BoundedState</span> <span class="hljs-variable">newState</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BoundedState</span>(<span class="hljs-built_in">this</span>, s);<br><span class="hljs-keyword">if</span> (newState.markPicked()) &#123;<br>busyQueue.add(newState);<br><span class="hljs-keyword">return</span> newState;<br>&#125;<br>&#125;<br><span class="hljs-comment">//else optimistically retry (implicit continue here)</span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//pick the least busy one</span><br><span class="hljs-type">BoundedState</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> busyQueue.poll();<br><span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span> &amp;&amp; s.markPicked()) &#123;<br>busyQueue.add(s); <span class="hljs-comment">//put it back in the queue with updated priority</span><br><span class="hljs-keyword">return</span> s;<br>&#125;<br><span class="hljs-comment">//else optimistically retry (implicit continue here)</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>   还有一点需要注意的是，Schedulers.newBoundedElastic() 的第二个参数<code>queuedTaskCap</code> 表示底层的每个子线程池的最大容量，而不是BoundedElasticScheduler本身的最大容量。</p><p>   SingleScheduler和ParallelScheduler是不允许执行堵塞任务的，这一点在reactor内部如执行block()操作符时就会报错。我们将堵塞任务放入这两个线程池内执行虽然不会报错，但也是很不规范的，可能会导致内部操作变慢。</p>]]></content>
    
    
    
    <tags>
      
      <tag>flux</tag>
      
      <tag>reactor</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis实现真流式查询mysql</title>
    <link href="/775901284.html"/>
    <url>/775901284.html</url>
    
    <content type="html"><![CDATA[<h1 id="mybatis实现mysql流式查询的原理"><a href="#mybatis实现mysql流式查询的原理" class="headerlink" title="mybatis实现mysql流式查询的原理"></a>mybatis实现mysql流式查询的原理</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>如果使用mybatis查询mysql，查询结果集非常大时，可能发生oom，我们可以使用mysql的流式查询，按需逐行查询每条数据，实现低内存占用。<br>下面分析其原理。</p><h2 id="jdbc驱动如何支持流式查询的"><a href="#jdbc驱动如何支持流式查询的" class="headerlink" title="jdbc驱动如何支持流式查询的"></a>jdbc驱动如何支持流式查询的</h2><h3 id="jdbc驱动的基本原理"><a href="#jdbc驱动的基本原理" class="headerlink" title="jdbc驱动的基本原理"></a>jdbc驱动的基本原理</h3><p>  jdbc驱动与mysql之间建立tcp连接，将sql语句发送到mysql服务端后，并从mysql服务端读取数据，并封装成resultSet的形式返回。</p><h3 id="resultSet"><a href="#resultSet" class="headerlink" title="resultSet"></a>resultSet</h3><p>我们使用resultSet时，调用resultSet的next方法是否存在下一行数据，resultSet内部包装了ResultsetRows对象，他将请求委托给ResultsetRows对象来处理。resultSet本身只是一个包装类，本质还是被委托到ResultsetRows对象。</p><h3 id="resultRows"><a href="#resultRows" class="headerlink" title="resultRows"></a>resultRows</h3><p>ResultsetRows 有两个实现类，ResultsetRowsStreaming和ResultsetRowsStatic。<br>ResultsetRowsStreaming发送完请求后，不会读取响应数据，他会等到调用next方法时才会从mysql读取。<br>ResultsetRowsStatic会使用while循环读取所有的数据存储到list中。</p><p>  下面是创建resultSet对象的过程过程如下，其中有一个核心逻辑是判断参数中的streamResults字段，决定是生成哪一种类型的ResultsetRows。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//  com.mysql.cj.protocol.a.TextResultsetReader</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Resultset <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> maxRows, <span class="hljs-type">boolean</span> streamResults, NativePacketPayload resultPacket, ColumnDefinition metadata,</span><br><span class="hljs-params">            ProtocolEntityFactory&lt;Resultset, NativePacketPayload&gt; resultSetFactory)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-type">Resultset</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//try &#123;</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">columnCount</span> <span class="hljs-operator">=</span> resultPacket.readInteger(IntegerDataType.INT_LENENC);<br><br>        <span class="hljs-keyword">if</span> (columnCount &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// Build a result set with rows.</span><br><br>            <span class="hljs-comment">// Read in the column information</span><br>            <span class="hljs-type">ColumnDefinition</span> <span class="hljs-variable">cdef</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.protocol.read(ColumnDefinition.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ColumnDefinitionFactory</span>(columnCount, metadata));<br><br>            <span class="hljs-comment">// There is no EOF packet after fields when CLIENT_DEPRECATE_EOF is set</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.protocol.getServerSession().isEOFDeprecated()) &#123;<br>                <span class="hljs-built_in">this</span>.protocol.skipPacket();<br>                <span class="hljs-comment">//this.protocol.readServerStatusForResultSets(this.protocol.readPacket(this.protocol.getReusablePacket()), true);</span><br>            &#125;<br><br>            <span class="hljs-type">ResultsetRows</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>            <span class="hljs-keyword">if</span> (!streamResults) &#123;<br>                <span class="hljs-type">TextRowFactory</span> <span class="hljs-variable">trf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextRowFactory</span>(<span class="hljs-built_in">this</span>.protocol, cdef, resultSetFactory.getResultSetConcurrency(), <span class="hljs-literal">false</span>);<br>                ArrayList&lt;ResultsetRow&gt; rowList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>                <span class="hljs-type">ResultsetRow</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.protocol.read(ResultsetRow.class, trf);<br>                <span class="hljs-keyword">while</span> (row != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> ((maxRows == -<span class="hljs-number">1</span>) || (rowList.size() &lt; maxRows)) &#123;<br>                        rowList.add(row);<br>                    &#125;<br>                    row = <span class="hljs-built_in">this</span>.protocol.read(ResultsetRow.class, trf);<br>                &#125;<br><br>                rows = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResultsetRowsStatic</span>(rowList, cdef);<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                rows = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResultsetRowsStreaming</span>&lt;&gt;(<span class="hljs-built_in">this</span>.protocol, cdef, <span class="hljs-literal">false</span>, resultSetFactory);<br>                <span class="hljs-built_in">this</span>.protocol.setStreamingData(rows);<br>            &#125;<br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Build ResultSet from ResultsetRows</span><br><span class="hljs-comment">             */</span><br>            rs = resultSetFactory.createFromProtocolEntity(rows);<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// check for file request</span><br>            <span class="hljs-keyword">if</span> (columnCount == NativePacketPayload.NULL_LENGTH) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">charEncoding</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.protocol.getPropertySet().getStringProperty(PropertyKey.characterEncoding).getValue();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> resultPacket.readString(StringSelfDataType.STRING_TERM, <span class="hljs-built_in">this</span>.protocol.doesPlatformDbCharsetMatches() ? charEncoding : <span class="hljs-literal">null</span>);<br>                resultPacket = <span class="hljs-built_in">this</span>.protocol.sendFileToServer(fileName);<br>            &#125;<br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Build ResultSet with no ResultsetRows</span><br><span class="hljs-comment">             */</span><br><br>            <span class="hljs-comment">// read and parse OK packet</span><br>            <span class="hljs-type">OkPacket</span> <span class="hljs-variable">ok</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.protocol.readServerStatusForResultSets(resultPacket, <span class="hljs-literal">false</span>); <span class="hljs-comment">// oldStatus set in sendCommand()</span><br><br>            rs = resultSetFactory.createFromProtocolEntity(ok);<br>        &#125;<br>        <span class="hljs-keyword">return</span> rs;<br><br>        <span class="hljs-comment">//&#125; catch (IOException ioEx) &#123;</span><br>        <span class="hljs-comment">//    throw SQLError.createCommunicationsException(this.protocol.getConnection(), this.protocol.getPacketSentTimeHolder().getLastPacketSentTime(),</span><br>        <span class="hljs-comment">//            this.protocol.getPacketReceivedTimeHolder().getLastPacketReceivedTime(), ioEx, this.protocol.getExceptionInterceptor());</span><br>        <span class="hljs-comment">//&#125;</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>决定是否启用流式的开关是使用下面的方法判断的。</p><p>其中有一个重要的判断参数是fetchSize &#x3D;&#x3D; Integer.MIN_VALUE。<br>也就是说我们要设置statement的fetchSize为Integer.MIN_VALUE才能启用流式查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">createStreamingResultSet</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> ((<span class="hljs-built_in">this</span>.query.getResultType() == Type.FORWARD_ONLY) &amp;&amp; (<span class="hljs-built_in">this</span>.resultSetConcurrency == java.sql.ResultSet.CONCUR_READ_ONLY)<br>            &amp;&amp; (<span class="hljs-built_in">this</span>.query.getResultFetchSize() == Integer.MIN_VALUE));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mybatis如何处理流式查询的"><a href="#mybatis如何处理流式查询的" class="headerlink" title="mybatis如何处理流式查询的"></a>mybatis如何处理流式查询的</h2><p>mybatis查询mysql后会获取到resultSet对象，其会对resultSet中的数据进行逐行next()处理。<br>如果resultHandler为null，则创建一个默认的resultHandler，否则使用我们提供的resultHandler。<br>默认的resultHandler源码如下，他会将结果存储到list中作为结果返回，如果使用我们提供的resultHandler，则返回的是空集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// org.apache.ibatis.executor.resultset.DefaultResultSetHandler#handleResultSet</span><br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleResultSet</span><span class="hljs-params">(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">if</span> (parentMapping != <span class="hljs-literal">null</span>) &#123;<br>        handleRowValues(rsw, resultMap, <span class="hljs-literal">null</span>, RowBounds.DEFAULT, parentMapping);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (resultHandler == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-type">DefaultResultHandler</span> <span class="hljs-variable">defaultResultHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultResultHandler</span>(objectFactory);<br>          handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, <span class="hljs-literal">null</span>);<br>          multipleResults.add(defaultResultHandler.getResultList());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          handleRowValues(rsw, resultMap, resultHandler, rowBounds, <span class="hljs-literal">null</span>);<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">// issue #228 (close resultsets)</span><br>      closeResultSet(rsw.getResultSet());<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>可以看到默认的resultHandler是将结果聚集到list中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultResultHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ResultHandler</span>&lt;Object&gt; &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Object&gt; list;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultResultHandler</span><span class="hljs-params">()</span> &#123;<br>    list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>  &#125;<br><br>  <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultResultHandler</span><span class="hljs-params">(ObjectFactory objectFactory)</span> &#123;<br>    list = objectFactory.create(List.class);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleResult</span><span class="hljs-params">(ResultContext&lt;?&gt; context)</span> &#123;<br>    list.add(context.getResultObject());<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title function_">getResultList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> list;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>处理resultSet的逻辑就是调用resultSet的next方法获取下一条，将每一条都解析成对象后回调resultHandler。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRowValuesForSimpleResultMap</span><span class="hljs-params">(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler&lt;?&gt; resultHandler, RowBounds rowBounds, ResultMapping parentMapping)</span><br>    <span class="hljs-keyword">throws</span> SQLException &#123;<br>  DefaultResultContext&lt;Object&gt; resultContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultResultContext</span>&lt;&gt;();<br>  <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> rsw.getResultSet();<br>  skipRows(resultSet, rowBounds);<br>  <span class="hljs-keyword">while</span> (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; !resultSet.isClosed() &amp;&amp; resultSet.next()) &#123;<br>    <span class="hljs-type">ResultMap</span> <span class="hljs-variable">discriminatedResultMap</span> <span class="hljs-operator">=</span> resolveDiscriminatedResultMap(resultSet, resultMap, <span class="hljs-literal">null</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">rowValue</span> <span class="hljs-operator">=</span> getRowValue(rsw, discriminatedResultMap, <span class="hljs-literal">null</span>);<br>    storeObject(resultHandler, resultContext, rowValue, parentMapping, resultSet);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="mybatis实现流式读取的正确的写法"><a href="#mybatis实现流式读取的正确的写法" class="headerlink" title="mybatis实现流式读取的正确的写法"></a>mybatis实现流式读取的正确的写法</h2><ol><li>mapper接口这样写，提供第二个参数，即resultHandler,因为提供resultHandler后，mybatis就不会有返回值了，这里直接返回void</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CustomSettleInChannelRecordMapper</span> &#123;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">query</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;request&quot;)</span> SettleRequest request, ResultHandler&lt;SettleRecord&gt; handler)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>xml文件应该这样写，一定要写 fetchSize&#x3D;”-2147483648”，不然到达jdbc那里返回的并不是流式的结果集。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;query&quot;</span> </span><br><span class="hljs-tag">        <span class="hljs-attr">fetchSize</span>=<span class="hljs-string">&quot;-2147483648&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;bastResultMap&quot;</span>&gt;</span><br>    select<br>    id,currency,pay_amount,status,payment_status<br>    from settle_record<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;request.reconCompleteTimeEnd != null&quot;</span>&gt;</span><br>            and txn_complete_time <span class="hljs-symbol">&amp;lt;</span>= #&#123;request.reconCompleteTimeEnd&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;request.bizType != null&quot;</span>&gt;</span><br>            and biz_type = #&#123;request.bizType&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>mybatis本身支持在mapper里面提供resultHandler用来流式处理每个结果。其实它内部本身就是创建一个默认的resultHandler将结果汇集后返回给我们的。</p><p>mybatis本身属于框架上层服务，他只负责从jdbc出取得resultSet，将resultSet每一行读取出来包装成流式的形式。<br>而resultSet本身是不是流式的，mybatis无法决定。<br>resultSet是真流式还是伪流式，需要判断一个重要的参数fetchSize，<br>要想实现真流式一定要将fetchSize设置为Integer.MIN_VALUE 底层才是真流式，否则只是mybatis包装的伪流式而已。</p><p>验证的话可以debug查看resultSet内部的resultRows是什么类型的，如果是ResultsetRowsStreaming则是真流式，如果是ResultsetRowsStatic则是假流式。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>mybatis</tag>
      
      <tag>技巧</tag>
      
      <tag>mysql流式查询技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>批处理当前脚本目录和当前命令行目录</title>
    <link href="/1058900669.html"/>
    <url>/1058900669.html</url>
    
    <content type="html"><![CDATA[<h1 id="批处理当前脚本目录和当前命令行目录"><a href="#批处理当前脚本目录和当前命令行目录" class="headerlink" title="批处理当前脚本目录和当前命令行目录"></a>批处理当前脚本目录和当前命令行目录</h1><p>当前脚本目录使用<code>%~dp0</code>获取，无论在哪里执行，此值是不变的。<br>当前命令行目录使用<code>%cd%</code> 获取相当于shell中的pwd命令，返回当前命令所在目录</p><p>参考下面脚本的结果，保存脚本时请使用ANSI编码保存，否则中文乱码</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><br>@<span class="hljs-keyword">echo</span> off <br><span class="hljs-keyword">set</span> root=%~dp0<br><span class="hljs-keyword">echo</span> 当前脚本目录:  %root%<br><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">pwd</span>=%<span class="hljs-keyword">cd</span>%<br><span class="hljs-keyword">echo</span> 当前命令行目录:  %<span class="hljs-keyword">pwd</span>%<br><br><span class="hljs-keyword">echo</span> 切换到c盘<br><span class="hljs-keyword">cd</span> <span class="hljs-string">/D</span> c:<br><span class="hljs-keyword">set</span> <span class="hljs-keyword">pwd</span>=%<span class="hljs-keyword">cd</span>%<br><span class="hljs-keyword">echo</span> 当前命令行目录:  %<span class="hljs-keyword">pwd</span>%<br><br>pause<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>cmd</tag>
      
      <tag>批处理</tag>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>groovy静态编译容易引发的问题</title>
    <link href="/3892320602.html"/>
    <url>/3892320602.html</url>
    
    <content type="html"><![CDATA[<h1 id="groovy静态编译容易引发的问题"><a href="#groovy静态编译容易引发的问题" class="headerlink" title="groovy静态编译容易引发的问题"></a>groovy静态编译容易引发的问题</h1><p>groovy为了提高性能，有一个静态编译的注解<code>@CompileStatic</code>,在类上添加该注解后，编译出来的class文件会更加静态化，更像java文件编译出来的class字节码。<br>但是因此会导致一些问题，今天我就遇到一个，下面将其记录下来。</p><p>众所周知，groovy是动态类型的，如下面重载的函数，使用java调用和groovy调用结果是不同的。</p><h2 id="1-测试groovy非静态编译"><a href="#1-测试groovy非静态编译" class="headerlink" title="1. 测试groovy非静态编译"></a>1. 测试groovy非静态编译</h2><p>在groovy中，定义变量时使用的是Object，是在调用时决定调用哪一个方法的，下面两次调用test方法，均能正确识别出对应的方法。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br>        Object param = <span class="hljs-string">&quot;a&quot;</span><br>        test(param)   <span class="hljs-comment">//---&gt; String</span><br><br>        Object param2 = <span class="hljs-number">1</span><br>        test(param2)   <span class="hljs-comment">//---&gt; Integer</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> test(Object b) &#123;<br>        println <span class="hljs-string">&quot;Object&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> test(String a) &#123;<br>        println <span class="hljs-string">&quot;String&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> test(Integer b) &#123;<br>        println <span class="hljs-string">&quot;Integer&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-测试java"><a href="#2-测试java" class="headerlink" title="2.测试java"></a>2.测试java</h2><p>上面同样的代码，使用java写就会变得不一样，因为java是在编译期间就决定应该调用哪个方法的，下面三个方法中，只会调用参数为Object的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">param</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br>        test(param);   <span class="hljs-comment">//---&gt; Object</span><br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">param2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        test(param2);   <span class="hljs-comment">//---&gt; Object</span><br><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Object a)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Object&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String b)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;String&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Integer b)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Integer&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-测试groovy静态编译"><a href="#3-测试groovy静态编译" class="headerlink" title="3.测试groovy静态编译"></a>3.测试groovy静态编译</h2><p>现在已经明白groovy和java调用的区别了，那如果将groovy进行静态编译后，结果是什么样子呢？<br>使用下面代码测试后，发现，groovy启用静态编译后仍然能够识别到对应的方法。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-meta">@CompileStatic</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br>        Object param = <span class="hljs-string">&quot;a&quot;</span><br>        test(param)   <span class="hljs-comment">//---&gt; String</span><br><br>        Object param2 = <span class="hljs-number">1</span><br>        test(param2)   <span class="hljs-comment">//---&gt; Integer</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> test(Object b) &#123;<br>        println <span class="hljs-string">&quot;Object&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> test(String a) &#123;<br>        println <span class="hljs-string">&quot;String&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> test(Integer b) &#123;<br>        println <span class="hljs-string">&quot;Integer&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-加大难度测试groovy静态编译"><a href="#4-加大难度测试groovy静态编译" class="headerlink" title="4.加大难度测试groovy静态编译"></a>4.加大难度测试groovy静态编译</h2><p>既然添加静态编译注解后，为啥编译出来的代码的运行行为仍然和非静态编译的groovy效果一样呢？我怀疑是代码太简单了，groovy能识别出类型，我将情况弄得再复杂一些。<br>为了给groovy编译器增加难度，我将参数先存储到list里，再取出，看groovy能否识别。<br>经过下面的测试结果，完全出乎我的预期，groovy将Integer强转成String了，他做了转换。即使参数是Date对象，他仍然将其转成了字符串，这种转换在大部分情况下都是不符合正常人预期的。<br>大部分情况下会导致问题。而移除<code>@CompileStatic</code>注解后，因为是在运行时判断类型的，所以能够识别出正确的方法。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-meta">@CompileStatic</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br>        List list = Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>,<span class="hljs-keyword">new</span> Date())<br>        test(list.get(<span class="hljs-number">0</span>))   <span class="hljs-comment">//---&gt; String</span><br><br>        test(list.get(<span class="hljs-number">1</span>))   <span class="hljs-comment">//---&gt; String</span><br>        <br>        test(list.get(<span class="hljs-number">2</span>))   <span class="hljs-comment">//---&gt; String</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> test(Object b) &#123;<br>        println <span class="hljs-string">&quot;Object&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> test(String a) &#123;<br>        println <span class="hljs-string">&quot;String&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> test(Integer b) &#123;<br>        println <span class="hljs-string">&quot;Integer&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这种不符合预期的方法查找就是产生bug的根源，并且idea 点击ctrl左键跳转的方法，与实际选择的方法不一致，这也增加了查找bug的难度。所以我建议减少使用静态编译注解的使用，虽然其能够提高点性能，但可能结果是无法预期的。</p><h2 id="5-测试java中正确，groovy中不正确的例子。内层闭包使用外层闭包变量，无法正确识别变量类型"><a href="#5-测试java中正确，groovy中不正确的例子。内层闭包使用外层闭包变量，无法正确识别变量类型" class="headerlink" title="5.测试java中正确，groovy中不正确的例子。内层闭包使用外层闭包变量，无法正确识别变量类型"></a>5.测试java中正确，groovy中不正确的例子。内层闭包使用外层闭包变量，无法正确识别变量类型</h2><p>   下面的代码中，我们使用了静态编译，其中map操作符中的pop参数是String类型的，然而真实调用时，触发testFunction的却是参数为Object的。<br>这是因为我们在使用pop参数时，没有在当前闭包中使用，而是再创建了一个闭包，我们在内层闭包中使用pop时，没有将pop识别成String类型，而在java中因为是强类型，是可以识别的</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-meta">@CompileStatic</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br>        List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>)<br><br>        Object response = list.stream()<br>                .map(&#123; pop -&gt;<br>                    <span class="hljs-keyword">return</span> &#123;<br>                        testFunction(pop)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;sss&quot;</span><br>                    &#125;.call()<br>                &#125;)<br>                .collect(Collectors.toList());<br><br>        System.out.println(response)<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> testFunction(Object a) &#123;   <span class="hljs-comment">//此函数被调用</span><br>        System.out.println(<span class="hljs-string">&quot;object&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> testFunction(String a) &#123;<br>        System.out.println(<span class="hljs-string">&quot;String&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>将上面的代码中添加一行，在第一个闭包中使用一下pop变量，那么就能正确识别到变量pop是String类型，从而调用参数为String的testFunction方法</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-meta">@CompileStatic</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br>        List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>)<br><br>        Object response = list.stream()<br>                .map(&#123; pop -&gt;<br>                    <span class="hljs-keyword">def</span> a =  pop    <span class="hljs-comment">//在外层闭包中使用一次pop变量</span><br>                    <span class="hljs-keyword">return</span> &#123;<br>                        testFunction(pop)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;sss&quot;</span><br>                    &#125;.call()<br>                &#125;)<br>                .collect(Collectors.toList());<br><br>        System.out.println(response)<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> testFunction(Object a) &#123;<br>        System.out.println(<span class="hljs-string">&quot;object&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> testFunction(String a) &#123;  <span class="hljs-comment">//此函数被调用</span><br>        System.out.println(<span class="hljs-string">&quot;String&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>第五条描述的现象（静态编译下，内层闭包直接使用外层闭包参数，导致参数类型无法识别）也是我今天第一次发现。我还没有查找资料，我猜应该是bug吧，毕竟这样与java差距太大，不符合常人预期，后面有发现我再继续更新。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>groovy</tag>
      
      <tag>静态编译</tag>
      
      <tag>双层闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>excel格式讲解</title>
    <link href="/3943646943.html"/>
    <url>/3943646943.html</url>
    
    <content type="html"><![CDATA[<h1 id="excel格式讲解"><a href="#excel格式讲解" class="headerlink" title="excel格式讲解"></a>excel格式讲解</h1><p>新版的excel文件，本质是一个zip压缩包，将其解压后，能看到其内部结构。</p><h2 id="解压文件目录"><a href="#解压文件目录" class="headerlink" title="解压文件目录"></a>解压文件目录</h2><p>找一个excel.xlsx文件，将其进行解压，目录结构如下</p><p><img src="/img/in/2021-10-12-excel%E6%A0%BC%E5%BC%8F%E8%AE%B2%E8%A7%A3/image-20211012155547651.png" alt="image-20211012155547651"></p><p>打开xl文件夹，styles.xml存储了全局的样式，worksheets内的sheet存储了每个sheet的数据，theme存储主题，shardStrings.xml存储的字符串池。</p><p><img src="/img/in/2021-10-12-excel%E6%A0%BC%E5%BC%8F%E8%AE%B2%E8%A7%A3/image-20211012155701566.png" alt="image-20211012155701566"></p><h2 id="打开sheet-xml，其结构如下"><a href="#打开sheet-xml，其结构如下" class="headerlink" title="打开sheet.xml，其结构如下"></a>打开sheet.xml，其结构如下</h2><p><img src="/img/in/2021-10-12-excel%E6%A0%BC%E5%BC%8F%E8%AE%B2%E8%A7%A3/image-20211012155855353.png" alt="image-20211012155855353"></p><p>row ： 表示一行的内容<br>c ：表示cell单元格<br>属性r&#x3D;”A3” ： 表示单元格的定位坐标<br>属性t&#x3D;”s”： 表示cellType,单元格类型。没有默认是NUMBER</p><p>​可选值如下【b&#x3D;BOOLEAN,e&#x3D;ERROR,inlineStr&#x3D;INLINE_STRING,s&#x3D;SST_STRING,str&#x3D;FORMULA】<br>属性s&#x3D;”1”： 表示cellStyleStr，单元格样式字符串，使用此格式到style.xml中查找样式</p><p>​因为excel经常用于处理数字，所以t属性不写默认就是NUMBER。通过添加s属性，约束数字展示成什么样式，如日期底层存储的也是数字，但通过样式约束后，可以展示为不同的时间样式。</p><h2 id="style-xml格式如下"><a href="#style-xml格式如下" class="headerlink" title="style.xml格式如下"></a>style.xml格式如下</h2><p><img src="/img/in/2021-10-12-excel%E6%A0%BC%E5%BC%8F%E8%AE%B2%E8%A7%A3/image-20211012160202283.png" alt="image-20211012160202283"></p><p>​上面sheet.xml中的 <code>s=&quot;1&quot;</code>，即到样式表的 cellXfs中查找第1个 （从0开始），可以看到第一个的numFmtId &#x3D; 11 表示时间格式化采用第11个格式化类型，xfId&#x3D;0表示去cellStyleXfs中查找第0个样式。还有一些边框，字体之类的就不太重要了。</p><p>​</p><h2 id="内置的一些格式样式，下面是poi源码中的注释"><a href="#内置的一些格式样式，下面是poi源码中的注释" class="headerlink" title="内置的一些格式样式，下面是poi源码中的注释"></a>内置的一些格式样式，下面是poi源码中的注释</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs vim">BuiltinFormats.class<br>/**<br> *       <span class="hljs-number">0</span>, <span class="hljs-string">&quot;General&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">1</span>, <span class="hljs-string">&quot;0&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">2</span>, <span class="hljs-string">&quot;0.00&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">3</span>, <span class="hljs-string">&quot;#,##0&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">4</span>, <span class="hljs-string">&quot;#,##0.00&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">5</span>, <span class="hljs-string">&quot;$#,##0_);($#,##0)&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">6</span>, <span class="hljs-string">&quot;$#,##0_);[Red]($#,##0)&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">7</span>, <span class="hljs-string">&quot;$#,##0.00);($#,##0.00)&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">8</span>, <span class="hljs-string">&quot;$#,##0.00_);[Red]($#,##0.00)&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">9</span>, <span class="hljs-string">&quot;0%&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span><span class="hljs-keyword">xa</span>, <span class="hljs-string">&quot;0.00%&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>xb, <span class="hljs-string">&quot;0.00E+00&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>xc, <span class="hljs-string">&quot;# ?/?&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>xd, <span class="hljs-string">&quot;# ??/??&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>xe, <span class="hljs-string">&quot;m/d/yy&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>xf, <span class="hljs-string">&quot;d-mmm-yy&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x10, <span class="hljs-string">&quot;d-mmm&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x11, <span class="hljs-string">&quot;mmm-yy&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x12, <span class="hljs-string">&quot;h:mm AM/PM&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x13, <span class="hljs-string">&quot;h:mm:ss AM/PM&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x14, <span class="hljs-string">&quot;h:mm&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x15, <span class="hljs-string">&quot;h:mm:ss&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x16, <span class="hljs-string">&quot;m/d/yy h:mm&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *<br> *       // <span class="hljs-number">0</span>x17 - <span class="hljs-number">0</span>x24 reserved <span class="hljs-keyword">for</span> international <span class="hljs-built_in">and</span> undocumented<br> *       <span class="hljs-number">0</span>x25, <span class="hljs-string">&quot;#,##0_);(#,##0)&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x26, <span class="hljs-string">&quot;#,##0_);[Red](#,##0)&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x27, <span class="hljs-string">&quot;#,##0.00_);(#,##0.00)&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x28, <span class="hljs-string">&quot;#,##0.00_);[Red](#,##0.00)&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x29, <span class="hljs-string">&quot;_(* #,##0_);_(* (#,##0);_(* \&quot;-\&quot;_);_(@_)&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x2a, <span class="hljs-string">&quot;_($* #,##0_);_($* (#,##0);_($* \&quot;-\&quot;_);_(@_)&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x2b, <span class="hljs-string">&quot;_(* #,##0.00_);_(* (#,##0.00);_(* \&quot;-\&quot;??_);_(@_)&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x2c, <span class="hljs-string">&quot;_($* #,##0.00_);_($* (#,##0.00);_($* \&quot;-\&quot;??_);_(@_)&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x2d, <span class="hljs-string">&quot;mm:ss&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x2e, <span class="hljs-string">&quot;[h]:mm:ss&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x2f, <span class="hljs-string">&quot;mm:ss.0&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x30, <span class="hljs-string">&quot;##0.0E+0&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x31, <span class="hljs-string">&quot;@&quot;</span> - This <span class="hljs-keyword">is</span> text format.<span class="hljs-symbol">&lt;br&gt;</span><br> *       <span class="hljs-number">0</span>x31  <span class="hljs-string">&quot;text&quot;</span> - Alias <span class="hljs-keyword">for</span> <span class="hljs-string">&quot;@&quot;</span><span class="hljs-symbol">&lt;br&gt;</span><br> * <br> */<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>excel直接打开看到的日期格式和poi读取到的日期格式不一样</title>
    <link href="/1160588511.html"/>
    <url>/1160588511.html</url>
    
    <content type="html"><![CDATA[<h1 id="excel直接打开看到的日期格式和poi读取到的日期格式不一样"><a href="#excel直接打开看到的日期格式和poi读取到的日期格式不一样" class="headerlink" title="excel直接打开看到的日期格式和poi读取到的日期格式不一样"></a>excel直接打开看到的日期格式和poi读取到的日期格式不一样</h1><h2 id="现象"><a href="#现象" class="headerlink" title="现象:"></a>现象:</h2><ol><li>创建一个excel.xlsx文件，输入一个日期，将其格式选择为自定义类型 yyyy&#x2F;m&#x2F;d h:mm 并保存</li><li>可以看到，日期格式确实变成了类似于2021&#x2F;1&#x2F;10 1:15的样子</li><li>使用poi读取该文件，发现读取到的该单元格的数据为m&#x2F;d&#x2F;yy h:mm格式，并不是上面在excel中看到的yyyy&#x2F;m&#x2F;d h:mm格式。</li></ol><p>poi版本 4.1.2<br>excel版本 2019<br>重现几率 100%</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ol><li>解压缩上述excel文件，在sheet1.xml中可以找到对应的cell数据,在style.xml中找到cellXfs对应的样式，可以看到其 numFmtId&#x3D;”22”</li><li>查看poi源码，找到BuiltinFormats类，查看其注释上有如下列表，可以看到22对应16进制0x16的时间样式为m&#x2F;d&#x2F;yy h:mm</li><li>poi会使用22查找样式，这样找到的是m&#x2F;d&#x2F;yy h:mm，而不是我们设置的yyyy&#x2F;m&#x2F;d h:mm类型，这就解释了为啥poi读到的和我们看到的不一致了。</li></ol><p>&#x2F;**</p><ul><li><pre><code class="hljs">  0, &quot;General&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  1, &quot;0&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  2, &quot;0.00&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  3, &quot;#,##0&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  4, &quot;#,##0.00&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  5, &quot;$#,##0_);($#,##0)&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  6, &quot;$#,##0_);[Red]($#,##0)&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  7, &quot;$#,##0.00);($#,##0.00)&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  8, &quot;$#,##0.00_);[Red]($#,##0.00)&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  9, &quot;0%&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0xa, &quot;0.00%&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0xb, &quot;0.00E+00&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0xc, &quot;# ?/?&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0xd, &quot;# ??/??&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0xe, &quot;m/d/yy&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0xf, &quot;d-mmm-yy&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x10, &quot;d-mmm&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x11, &quot;mmm-yy&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x12, &quot;h:mm AM/PM&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x13, &quot;h:mm:ss AM/PM&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x14, &quot;h:mm&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x15, &quot;h:mm:ss&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x16, &quot;m/d/yy h:mm&quot;&lt;br&gt;</code></pre></li></ul><p> *<p></p><ul><li><pre><code class="hljs">  // 0x17 - 0x24 reserved for international and undocumented</code></pre></li><li><pre><code class="hljs">  0x25, &quot;#,##0_);(#,##0)&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x26, &quot;#,##0_);[Red](#,##0)&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x27, &quot;#,##0.00_);(#,##0.00)&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x28, &quot;#,##0.00_);[Red](#,##0.00)&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x29, &quot;_(* #,##0_);_(* (#,##0);_(* \&quot;-\&quot;_);_(@_)&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x2a, &quot;_($* #,##0_);_($* (#,##0);_($* \&quot;-\&quot;_);_(@_)&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x2b, &quot;_(* #,##0.00_);_(* (#,##0.00);_(* \&quot;-\&quot;??_);_(@_)&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x2c, &quot;_($* #,##0.00_);_($* (#,##0.00);_($* \&quot;-\&quot;??_);_(@_)&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x2d, &quot;mm:ss&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x2e, &quot;[h]:mm:ss&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x2f, &quot;mm:ss.0&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x30, &quot;##0.0E+0&quot;&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x31, &quot;@&quot; - This is text format.&lt;br&gt;</code></pre></li><li><pre><code class="hljs">  0x31  &quot;text&quot; - Alias for &quot;@&quot;&lt;br&gt;</code></pre></li><li><p> */</li></ul><h2 id="猜测"><a href="#猜测" class="headerlink" title="猜测"></a>猜测</h2><p>猜测可能和国家地区有关，poi应该只对应美国地区，而excel在中国电脑上安装的，有本地化适配。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>excel</tag>
      
      <tag>poi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aws s3 预签名上传文件,下载文件</title>
    <link href="/3834588872.html"/>
    <url>/3834588872.html</url>
    
    <content type="html"><![CDATA[<h1 id="aws-s3-预签名上传文件-下载文件"><a href="#aws-s3-预签名上传文件-下载文件" class="headerlink" title="aws s3 预签名上传文件,下载文件"></a>aws s3 预签名上传文件,下载文件</h1><p>需求是生成预签名下载链接，将链接发送给没有s3权限的用户，其也能正常下载而不需要登录到aws。<br>上传也是同理，生成预签名上传链接，用户上传时无需登录aws。</p><h2 id="1-引入jar包"><a href="#1-引入jar包" class="headerlink" title="1.引入jar包"></a>1.引入jar包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>software.amazon.awssdk<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>bom<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.17.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>software.amazon.awssdk<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>s3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="2-下载文件，上传文件，判断文件是否存在，读取文件"><a href="#2-下载文件，上传文件，判断文件是否存在，读取文件" class="headerlink" title="2. 下载文件，上传文件，判断文件是否存在，读取文件"></a>2. 下载文件，上传文件，判断文件是否存在，读取文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">package</span> test.util;<br><br><span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> org.springframework.util.Assert;<br><span class="hljs-keyword">import</span> org.springframework.web.util.UriComponents;<br><span class="hljs-keyword">import</span> org.springframework.web.util.UriComponentsBuilder;<br><span class="hljs-keyword">import</span> software.amazon.awssdk.auth.credentials.InstanceProfileCredentialsProvider;<br><span class="hljs-keyword">import</span> software.amazon.awssdk.regions.Region;<br><span class="hljs-keyword">import</span> software.amazon.awssdk.services.s3.S3Client;<br><span class="hljs-keyword">import</span> software.amazon.awssdk.services.s3.internal.presigner.DefaultS3Presigner;<br><span class="hljs-keyword">import</span> software.amazon.awssdk.services.s3.model.GetObjectRequest;<br><span class="hljs-keyword">import</span> software.amazon.awssdk.services.s3.model.HeadObjectRequest;<br><span class="hljs-keyword">import</span> software.amazon.awssdk.services.s3.model.HeadObjectResponse;<br><span class="hljs-keyword">import</span> software.amazon.awssdk.services.s3.model.NoSuchKeyException;<br><span class="hljs-keyword">import</span> software.amazon.awssdk.services.s3.model.PutObjectRequest;<br><span class="hljs-keyword">import</span> software.amazon.awssdk.services.s3.presigner.S3Presigner;<br><span class="hljs-keyword">import</span> software.amazon.awssdk.services.s3.presigner.model.PresignedGetObjectRequest;<br><span class="hljs-keyword">import</span> software.amazon.awssdk.services.s3.presigner.model.PresignedPutObjectRequest;<br><span class="hljs-keyword">import</span> software.amazon.awssdk.services.s3.presigner.model.PutObjectPresignRequest;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.time.Duration;<br><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">S3Utils</span> &#123;<br><br>    <span class="hljs-keyword">static</span> S3Presigner s3Presigner;<br>    <span class="hljs-keyword">static</span> S3Client s3Client;<br><br>    <span class="hljs-meta">@Resource</span><br>    ReconFeature reconFeature;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        s3Presigner = DefaultS3Presigner<br>                .builder()<br>                .region(Region.AP_SOUTH_1)<br>                .credentialsProvider(InstanceProfileCredentialsProvider.create())<br>                .build();<br><br>        s3Client = S3Client.builder()<br>                .region(Region.AP_SOUTH_1)<br>                .credentialsProvider(InstanceProfileCredentialsProvider.create())<br>                .build();<br>    &#125;<br><br>    <span class="hljs-comment">/* 生成下载文件的预签名地址</span><br><span class="hljs-comment">     * s3Path = s3://bucket/a/b/c/</span><br><span class="hljs-comment">     * fileName = 123.txt</span><br><span class="hljs-comment">     * effectiveDay = 有效期</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">signGetObject</span><span class="hljs-params">(String s3Path, String fileName, <span class="hljs-type">int</span> effectiveDay)</span> &#123;<br>        <span class="hljs-type">UriComponents</span> <span class="hljs-variable">build</span> <span class="hljs-operator">=</span> UriComponentsBuilder.fromUriString(s3Path)<br>                .path(<span class="hljs-string">&quot;/&quot;</span>)<br>                .path(fileName)<br>                .build();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">bucket</span> <span class="hljs-operator">=</span> build.getHost();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> build.getPath();<br>        Assert.notNull(key, <span class="hljs-string">&quot;can not singFile for s3Path:&quot;</span> + s3Path + <span class="hljs-string">&quot; fileName:&quot;</span> + fileName);<br><br>        <span class="hljs-keyword">if</span> (key.startsWith(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>            key = key.substring(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">GetObjectRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> GetObjectRequest.builder()<br>                .bucket(bucket)<br>                .key(key)<br>                .build();<br>        <span class="hljs-type">PresignedGetObjectRequest</span> <span class="hljs-variable">presignedGetObjectRequest</span> <span class="hljs-operator">=</span> s3Presigner.presignGetObject(b -&gt; &#123;<br>            b.getObjectRequest(request);<br>            b.signatureDuration(Duration.ofDays(effectiveDay));<br>        &#125;);<br>        <span class="hljs-keyword">return</span> presignedGetObjectRequest.url().toString();<br>    &#125;<br><br><br><br>    <span class="hljs-comment">/* 生成上传文件的预签名地址</span><br><span class="hljs-comment">     * s3FullPath = s3://bucket/a/b/c/123.txt</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">signPutObject</span><span class="hljs-params">(String s3FullPath)</span> &#123;<br>        Assert.isTrue(s3FullPath.startsWith(<span class="hljs-string">&quot;s3://&quot;</span>), <span class="hljs-string">&quot;s3全路径不正确&quot;</span>);<br>        <span class="hljs-type">UriComponents</span> <span class="hljs-variable">build</span> <span class="hljs-operator">=</span> UriComponentsBuilder.fromUriString(s3FullPath)<br>                .build();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">bucket</span> <span class="hljs-operator">=</span> build.getHost();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> build.getPath().substring(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">PutObjectRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> PutObjectRequest.builder()<br>                .bucket(bucket)<br>                .key(key)<br>                .build();<br>        <span class="hljs-type">PutObjectPresignRequest</span> <span class="hljs-variable">preRequest</span> <span class="hljs-operator">=</span> PutObjectPresignRequest.builder()<br>                .signatureDuration(Duration.ofMinutes(<span class="hljs-number">15</span>))<br>                .putObjectRequest(request)<br>                .build();<br>        <span class="hljs-type">PresignedPutObjectRequest</span> <span class="hljs-variable">presignedPutObjectRequest</span> <span class="hljs-operator">=</span> s3Presigner.presignPutObject(preRequest);<br><br>        <span class="hljs-keyword">return</span> presignedPutObjectRequest.url().toString();<br>    &#125;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *判断文件是否存在在s3上</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HeadObjectResponse <span class="hljs-title function_">fileExist</span><span class="hljs-params">(String s3Path, String fileName)</span> &#123;<br>        <span class="hljs-type">UriComponents</span> <span class="hljs-variable">build</span> <span class="hljs-operator">=</span> UriComponentsBuilder.fromUriString(s3Path)<br>                .path(fileName)<br>                .build();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> Objects.requireNonNull(build.getPath()).substring(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">HeadObjectRequest</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> HeadObjectRequest.builder()<br>                .bucket(build.getHost())<br>                .key(key)<br>                .build();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> s3Client.headObject(req);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchKeyException e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 读取s3的文件，以文件流形式返回（注意使用完一定要关闭流，否则会导致连接池连接占用完）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InputStream <span class="hljs-title function_">readFile</span><span class="hljs-params">(String s3Path, String fileName)</span> &#123;<br>        <span class="hljs-type">UriComponents</span> <span class="hljs-variable">build</span> <span class="hljs-operator">=</span> UriComponentsBuilder.fromUriString(s3Path)<br>                .path(fileName)<br>                .build();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> Objects.requireNonNull(build.getPath()).substring(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">GetObjectRequest</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> GetObjectRequest.builder()<br>                .bucket(build.getHost())<br>                .key(key)<br>                .build();<br>        <span class="hljs-keyword">return</span> s3Client.getObject(req);<br>    &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>aws</tag>
      
      <tag>s3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>groovy闭包 list传参</title>
    <link href="/1894068305.html"/>
    <url>/1894068305.html</url>
    
    <content type="html"><![CDATA[<h1 id="groovy闭包-list传参"><a href="#groovy闭包-list传参" class="headerlink" title="groovy闭包 list传参"></a>groovy闭包 list传参</h1><p>​</p><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>如下代码，定义一个闭包接受两个参数，传递参数时可以传递 size &#x3D; 2 的 List 作为参数， 使用 length &#x3D; 2 的数组不可以，使用 size &#x3D; 2 的 Set 也不可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br><br>       <span class="hljs-type">def</span> <span class="hljs-variable">closure</span> <span class="hljs-operator">=</span> &#123; a, b -&gt; a == <span class="hljs-string">&#x27;1&#x27;</span> ? b.toUpperCase() : b.toLowerCase() &#125;<br><br>       <span class="hljs-type">List</span> <span class="hljs-variable">param1</span> <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&#x27;AbCd&#x27;</span>]<br>       <span class="hljs-keyword">assert</span> <span class="hljs-string">&#x27;ABCD&#x27;</span> == closure(param1)<br><br>       String[] param2 = [<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&#x27;AbCd&#x27;</span>]<br>       <span class="hljs-keyword">assert</span> <span class="hljs-string">&#x27;ABCD&#x27;</span> == closure(param2)  <span class="hljs-comment">//数组不可以</span><br>       <br>   &#125;<br><br></code></pre></td></tr></table></figure><p>翻看文档未找到相关介绍，那为什么可以使用 List 呢？</p><p>当然 Groovy 支持 使用*List 的方式，将 List 展平作为参数，这里我并没有使用星号</p><p>试了一下单个参数的闭包调用情况</p><p>test3 闭包接受一个String类型的参数，传递一个List，会将List数据取出来作为参数传入。 test4闭包未指定参数类型，会将List本身作为参数传入，不会取出数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">def</span> <span class="hljs-variable">closure</span> <span class="hljs-operator">=</span> &#123; String a -&gt; a == <span class="hljs-string">&#x27;1&#x27;</span> ? a + <span class="hljs-string">&#x27;A&#x27;</span> : a + <span class="hljs-string">&#x27;B&#x27;</span> &#125;<br><br>    <span class="hljs-type">List</span> <span class="hljs-variable">param1</span> <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;1&quot;</span>]<br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&#x27;1A&#x27;</span> == closure(param1)<br>&#125;<br><br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">def</span> <span class="hljs-variable">closure</span> <span class="hljs-operator">=</span> &#123; a -&gt; a == <span class="hljs-string">&#x27;1&#x27;</span> ? a + <span class="hljs-string">&#x27;A&#x27;</span> : a + <span class="hljs-string">&#x27;B&#x27;</span> &#125;<br><br>    <span class="hljs-type">List</span> <span class="hljs-variable">param1</span> <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;1&quot;</span>]<br>    <span class="hljs-keyword">assert</span> [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>] == closure(param1)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>查看其源码，下面是核心方法<br>org.codehaus.groovy.runtime.metaclass.ClosureMetaClass#invokeMethod</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java">Object <span class="hljs-title function_">invokeMethod</span><span class="hljs-params">(Class sender, Object object, String methodName, Object[] originalArguments, <span class="hljs-type">boolean</span> isCallToSuper, <span class="hljs-type">boolean</span> fromInsideClass)</span> &#123;<br><br><span class="hljs-comment">//获取参数和参数的类型</span><br>        <span class="hljs-keyword">final</span> Object[] arguments = makeArguments(originalArguments, methodName);<br>        <span class="hljs-keyword">final</span> Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);<br><br>        <span class="hljs-type">MetaMethod</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Closure</span> <span class="hljs-variable">closure</span> <span class="hljs-operator">=</span> (Closure) object;<br><br>        <span class="hljs-keyword">if</span> (CLOSURE_DO_CALL_METHOD.equals(methodName) || CLOSURE_CALL_METHOD.equals(methodName)) &#123;<br>            <span class="hljs-comment">//选择闭包的method，因为这里的参数类型不满足闭包的参数类型，所以这里返会null</span><br>method = pickClosureMethod(argClasses);<br><span class="hljs-comment">//判断参数只有一个且是List，则尝试将参数list内部数据取出，使用此类型从闭包中查找方法</span><br>            <span class="hljs-keyword">if</span> (method == <span class="hljs-literal">null</span> &amp;&amp; arguments.length == <span class="hljs-number">1</span> &amp;&amp; arguments[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> List) &#123;<br>                Object[] newArguments = ((List) arguments[<span class="hljs-number">0</span>]).toArray();<br>                Class[] newArgClasses = MetaClassHelper.convertToTypeArray(newArguments);<br><span class="hljs-comment">//这里参数类型匹配成功，将查找到的method使用TransformMetaMethod包装起来</span><br>                method = createTransformMetaMethod(pickClosureMethod(newArgClasses));<br>        &#125;<br><br><br><br><br><span class="hljs-comment">//这里将method包装起来，重写invoke方法，因为确定参数是List了,将其内部数据取出组成数组调用真实method</span><br>    <span class="hljs-keyword">protected</span> MetaMethod <span class="hljs-title function_">createTransformMetaMethod</span><span class="hljs-params">(MetaMethod method)</span> &#123;<br>        <span class="hljs-keyword">if</span> (method == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformMetaMethod</span>(method) &#123;<br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object object, Object[] arguments)</span> &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">firstArgument</span> <span class="hljs-operator">=</span> arguments[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> (List) firstArgument;<br>                arguments = list.toArray();<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.invoke(object, arguments);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>这应该是闭包的特殊逻辑，其他正常方法是没有这种逻辑的，如果想要将List展平作为参数，仍需使用星号的形式。<br>以后如果不知道闭包具体参数数量可以直接传递List即可。在dsl中使用会很方便。</p>]]></content>
    
    
    
    <tags>
      
      <tag>groovy</tag>
      
      <tag>闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis-generator多个数据库存在相同的表</title>
    <link href="/875549236.html"/>
    <url>/875549236.html</url>
    
    <content type="html"><![CDATA[<h1 id="mybatis-generator多个数据库存在相同的表"><a href="#mybatis-generator多个数据库存在相同的表" class="headerlink" title="mybatis-generator多个数据库存在相同的表"></a>mybatis-generator多个数据库存在相同的表</h1><p>​</p><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>使用mybatis时难免会使用其提供的mybatis-generator生成默认的xml和实体类，今天我发现如果本地安装一个mysql，里面创建两个不同的数据库，而他们有相同的表，生成的实体类中可能是随机的。<br>比如我有一个数据库 ‘a’ 里面有一张表 ‘user’，我现在在建一个库‘b’，里面也有一张表‘user’，这样我生成代码时，虽然jdbcUrl配置的是a库，但生成的User实体类可能是b库里面的。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>查看其源码，下面是核心方法<br>org.mybatis.generator.internal.db.DatabaseIntrospector#getColumns</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Map&lt;ActualTableName, List&lt;IntrospectedColumn&gt;&gt; <span class="hljs-title function_">getColumns</span><span class="hljs-params">(</span><br><span class="hljs-params">        TableConfiguration tc)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    String localCatalog;<br>    String localSchema;<br>    String localTableName;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">delimitIdentifiers</span> <span class="hljs-operator">=</span> tc.isDelimitIdentifiers()<br>            || stringContainsSpace(tc.getCatalog())<br>            || stringContainsSpace(tc.getSchema())<br>            || stringContainsSpace(tc.getTableName());<br><br>    <span class="hljs-keyword">if</span> (delimitIdentifiers) &#123;<br>        localCatalog = tc.getCatalog();<br>        localSchema = tc.getSchema();<br>        localTableName = tc.getTableName();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (databaseMetaData.storesLowerCaseIdentifiers()) &#123;<br>        localCatalog = tc.getCatalog() == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : tc.getCatalog()<br>                .toLowerCase();<br>        localSchema = tc.getSchema() == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : tc.getSchema()<br>                .toLowerCase();<br>        localTableName = tc.getTableName().toLowerCase();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (databaseMetaData.storesUpperCaseIdentifiers()) &#123;<br>        localCatalog = tc.getCatalog() == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : tc.getCatalog()<br>                .toUpperCase();<br>        localSchema = tc.getSchema() == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : tc.getSchema()<br>                .toUpperCase();<br>        localTableName = tc.getTableName().toUpperCase();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        localCatalog = tc.getCatalog();<br>        localSchema = tc.getSchema();<br>        localTableName = tc.getTableName();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (tc.isWildcardEscapingEnabled()) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">escapeString</span> <span class="hljs-operator">=</span> databaseMetaData.getSearchStringEscape();<br><br>        <span class="hljs-keyword">if</span> (localSchema != <span class="hljs-literal">null</span>) &#123;<br>            localSchema = escapeName(localSchema, escapeString);<br>        &#125;<br><br>        localTableName = escapeName(localTableName, escapeString);<br>    &#125;<br><br>    Map&lt;ActualTableName, List&lt;IntrospectedColumn&gt;&gt; answer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fullTableName</span> <span class="hljs-operator">=</span> composeFullyQualifiedTableName(localCatalog, localSchema,<br>                        localTableName, <span class="hljs-string">&#x27;.&#x27;</span>);<br>        logger.debug(getString(<span class="hljs-string">&quot;Tracing.1&quot;</span>, fullTableName)); <span class="hljs-comment">//$NON-NLS-1$</span><br>    &#125;<br><br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> databaseMetaData.getColumns(localCatalog, localSchema,<br>            localTableName, <span class="hljs-string">&quot;%&quot;</span>); <span class="hljs-comment">//$NON-NLS-1$</span><br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">supportsIsAutoIncrement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">supportsIsGeneratedColumn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">ResultSetMetaData</span> <span class="hljs-variable">rsmd</span> <span class="hljs-operator">=</span> rs.getMetaData();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">colCount</span> <span class="hljs-operator">=</span> rsmd.getColumnCount();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= colCount; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;IS_AUTOINCREMENT&quot;</span>.equals(rsmd.getColumnName(i))) &#123; <span class="hljs-comment">//$NON-NLS-1$</span><br>            supportsIsAutoIncrement = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;IS_GENERATEDCOLUMN&quot;</span>.equals(rsmd.getColumnName(i))) &#123; <span class="hljs-comment">//$NON-NLS-1$</span><br>            supportsIsGeneratedColumn = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (rs.next()) &#123;<br>        <span class="hljs-type">IntrospectedColumn</span> <span class="hljs-variable">introspectedColumn</span> <span class="hljs-operator">=</span> ObjectFactory<br>                .createIntrospectedColumn(context);<br><br>        introspectedColumn.setTableAlias(tc.getAlias());<br>        introspectedColumn.setJdbcType(rs.getInt(<span class="hljs-string">&quot;DATA_TYPE&quot;</span>)); <span class="hljs-comment">//$NON-NLS-1$</span><br>        introspectedColumn.setActualTypeName(rs.getString(<span class="hljs-string">&quot;TYPE_NAME&quot;</span>)); <span class="hljs-comment">//$NON-NLS-1$</span><br>        introspectedColumn.setLength(rs.getInt(<span class="hljs-string">&quot;COLUMN_SIZE&quot;</span>)); <span class="hljs-comment">//$NON-NLS-1$</span><br>        introspectedColumn.setActualColumnName(rs.getString(<span class="hljs-string">&quot;COLUMN_NAME&quot;</span>)); <span class="hljs-comment">//$NON-NLS-1$</span><br>        introspectedColumn<br>                .setNullable(rs.getInt(<span class="hljs-string">&quot;NULLABLE&quot;</span>) == DatabaseMetaData.columnNullable); <span class="hljs-comment">//$NON-NLS-1$</span><br>        introspectedColumn.setScale(rs.getInt(<span class="hljs-string">&quot;DECIMAL_DIGITS&quot;</span>)); <span class="hljs-comment">//$NON-NLS-1$</span><br>        introspectedColumn.setRemarks(rs.getString(<span class="hljs-string">&quot;REMARKS&quot;</span>)); <span class="hljs-comment">//$NON-NLS-1$</span><br>        introspectedColumn.setDefaultValue(rs.getString(<span class="hljs-string">&quot;COLUMN_DEF&quot;</span>)); <span class="hljs-comment">//$NON-NLS-1$</span><br><br>        <span class="hljs-keyword">if</span> (supportsIsAutoIncrement) &#123;<br>            introspectedColumn.setAutoIncrement(<br>                    <span class="hljs-string">&quot;YES&quot;</span>.equals(rs.getString(<span class="hljs-string">&quot;IS_AUTOINCREMENT&quot;</span>))); <span class="hljs-comment">//$NON-NLS-1$ //$NON-NLS-2$</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (supportsIsGeneratedColumn) &#123;<br>            introspectedColumn.setGeneratedColumn(<br>                    <span class="hljs-string">&quot;YES&quot;</span>.equals(rs.getString(<span class="hljs-string">&quot;IS_GENERATEDCOLUMN&quot;</span>))); <span class="hljs-comment">//$NON-NLS-1$ //$NON-NLS-2$</span><br>        &#125;<br><br>        <span class="hljs-type">ActualTableName</span> <span class="hljs-variable">atn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActualTableName</span>(<br>                rs.getString(<span class="hljs-string">&quot;TABLE_CAT&quot;</span>), <span class="hljs-comment">//$NON-NLS-1$</span><br>                rs.getString(<span class="hljs-string">&quot;TABLE_SCHEM&quot;</span>), <span class="hljs-comment">//$NON-NLS-1$</span><br>                rs.getString(<span class="hljs-string">&quot;TABLE_NAME&quot;</span>)); <span class="hljs-comment">//$NON-NLS-1$</span><br><br>        List&lt;IntrospectedColumn&gt; columns = answer.computeIfAbsent(atn, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br><br>        columns.add(introspectedColumn);<br><br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            logger.debug(getString(<br>                    <span class="hljs-string">&quot;Tracing.2&quot;</span>, <span class="hljs-comment">//$NON-NLS-1$</span><br>                    introspectedColumn.getActualColumnName(), Integer<br>                            .toString(introspectedColumn.getJdbcType()),<br>                    atn.toString()));<br>        &#125;<br>    &#125;<br><br>    closeResultSet(rs);<br><br>    <span class="hljs-keyword">if</span> (answer.size() &gt; <span class="hljs-number">1</span><br>            &amp;&amp; !stringContainsSQLWildcard(localSchema)<br>            &amp;&amp; !stringContainsSQLWildcard(localTableName)) &#123;<br>        <span class="hljs-comment">// issue a warning if there is more than one table and</span><br>        <span class="hljs-comment">// no wildcards were used</span><br>        <span class="hljs-type">ActualTableName</span> <span class="hljs-variable">inputAtn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActualTableName</span>(tc.getCatalog(), tc<br>                .getSchema(), tc.getTableName());<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">comma</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (ActualTableName atn : answer.keySet()) &#123;<br>            <span class="hljs-keyword">if</span> (comma) &#123;<br>                sb.append(<span class="hljs-string">&#x27;,&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                comma = <span class="hljs-literal">true</span>;<br>            &#125;<br>            sb.append(atn.toString());<br>        &#125;<br><br>        warnings.add(getString(<span class="hljs-string">&quot;Warning.25&quot;</span>, <span class="hljs-comment">//$NON-NLS-1$</span><br>                inputAtn.toString(), sb.toString()));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> answer;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面方法内容有点多，核心逻辑就是</p><ol><li><p>根据CataLog，Schema，TableName三个属性从databaseMetaData里面获取ResultSet。</p><p> ResultSet rs &#x3D; databaseMetaData.getColumns(localCatalog, localSchema,localTableName, “%”);</p></li><li><p>遍历上面的结果集，按照结果集返回值里面的 TABLE_CAT ， TABLE_SCHEM  ， TABLE_NAME 存入到answer里。</p><p> ActualTableName atn &#x3D; new ActualTableName(<br>             rs.getString(“TABLE_CAT”), &#x2F;&#x2F;$NON-NLS-1$<br>             rs.getString(“TABLE_SCHEM”), &#x2F;&#x2F;$NON-NLS-1$<br>             rs.getString(“TABLE_NAME”)); &#x2F;&#x2F;$NON-NLS-1$</p></li><li><p>返回 answer对象。</p><p> 因为我们我先前没有指定catalog 和 scheme，这里的REsultSet里会获取a库和b库中的user表，即两张表都会返回。</p></li></ol><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>添加 <property name="nullCatalogMeansCurrent" value="true"/> 属性，不要从metadata中获取其他数据库的表</p><p>改动前</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>改动后</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;nullCatalogMeansCurrent&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mybatis.org/generator/usage/mysql.html">https://mybatis.org/generator/usage/mysql.html</a></p><p><a href="https://github.com/mybatis/generator/issues/622">https://github.com/mybatis/generator/issues/622</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>mybatis</tag>
      
      <tag>bug</tag>
      
      <tag>generator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql使用updatetime作为乐观锁</title>
    <link href="/1509978234.html"/>
    <url>/1509978234.html</url>
    
    <content type="html"><![CDATA[<h1 id="mysql使用updatetime作为乐观锁"><a href="#mysql使用updatetime作为乐观锁" class="headerlink" title="mysql使用updatetime作为乐观锁"></a>mysql使用updatetime作为乐观锁</h1><p>本文记录一下，我是用mysql的updatetime字段作为乐观锁版本号遇到的问题。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>首先标准的乐观锁，应该存在一个version字段，每次更新时人工自增此字段，但是这样每次更新时都要多维护一个字段很麻烦。<br>所以我使用数据库中的update_time字段作为乐观锁的version使用，将update_time字段设为每次有更新时自动刷新，使用此字段当作version使用，免去了每次自己维度版本号的问题。</p><p>如下面sql:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">`update_time` datetime <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;更新时间&#x27;</span><br></code></pre></td></tr></table></figure><p>使用乐观锁时是这样的:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">set</span>  field <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;field&#x27;</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> update_time <span class="hljs-operator">=</span> update_time<br></code></pre></td></tr></table></figure><h2 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h2><p>但是这又引入了新的问题，默认情况下datetime的精度是秒级的，如果同一秒的两次更新，乐观锁是不生效的。</p><p>为了解决这个问题，我将update_time字段的精度设置为小数点后6位，缩小精度后，乐观锁只有在同时0.000001秒内同时执行才会失效。<br>这样改动后在我需要的场景下，是可以满足要求的，一方面是因为与数据库的网络交互本身就比0.000001秒长，另一方面我的场景不需要乐观锁百分百生效</p><p>如下是我使用了的sql更新表结构。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">`update_time` datetime(<span class="hljs-number">6</span>) <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>(<span class="hljs-number">6</span>) COMMENT <span class="hljs-string">&#x27;更新时间&#x27;</span><br></code></pre></td></tr></table></figure><p>改动后手动更新一条数据，发现update_time字段果然保留了小数点后6位，于是我将代码部署到测试环境进行测试。</p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>部署测试环境开始测试后，发现我的更新语句失效了，更新条数是0条。于是我在本地进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用id = 1 从数据库中查询一条记录</span><br><span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> queryById(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">//更新id = 1的记录，并在where条件中加上update_time</span><br><span class="hljs-type">int</span> <span class="hljs-variable">updateCount</span> <span class="hljs-operator">=</span> updateOrder(<span class="hljs-number">1</span>,order.getUpdateTime)<br><br><span class="hljs-comment">//更新的条数，竟然是0条</span><br><span class="hljs-keyword">assert</span> updateCount == <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><p>查询数据，然后再更新竟然不行，更新失败了？？？</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>其实原因是，java里面的Date存储的是Long型的毫秒值，精度只到毫秒单位，而数据库里面的update_time是小数点后6位，已经到纳秒级别了，所以从数据库查询数据时，毫秒后面的被忽略了。<br>所以更新的时候才导致无法更新。</p><p>解决这个问题的话，将数据库update_time精度设为小数点后3位即可。毫秒级别也已经很小了，毕竟一次数据库网络传输也要1-20毫秒</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">`update_time` datetime(<span class="hljs-number">3</span>) <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>(<span class="hljs-number">3</span>) COMMENT <span class="hljs-string">&#x27;更新时间&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>bug</tag>
      
      <tag>乐观锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spock测试零基础教程</title>
    <link href="/1272392355.html"/>
    <url>/1272392355.html</url>
    
    <content type="html"><![CDATA[<h1 id="spock测试零基础教程"><a href="#spock测试零基础教程" class="headerlink" title="spock测试零基础教程"></a>spock测试零基础教程</h1><p>​昨天研究了一下spock单元测试，确实特别好用，这也是我第一次接触spock，作为一个新手，网上很多教程讲的太深了，折腾了好几个小时才搞明白。<br>​所以我想写一个从0开始的简单教程，一步一步做把Demo跑起来，再去看其他人的教程，这样更有效率。</p><p>下面我将基于spock2.x版本进行演示。可以新建一个空SpringBoot项目进行测试，防止项目内的其他依赖冲突，Demo跑不起来。</p><h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h2><p>这里引入了spock2.x的包，默认情况下spock会自动将groovy引入进来，我这里主动声明了groovy的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.spockframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spock-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0-groovy-3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.spockframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spock-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0-groovy-3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-创建测试类"><a href="#2-创建测试类" class="headerlink" title="2.创建测试类"></a>2.创建测试类</h2><p>在测试目录下，右键选择Spock Specification，会自动创建一个类继承了Specification。</p><p><img src="/img/in/2021-07-01-spock%E6%B5%8B%E8%AF%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/image-20210701180417247.png" alt="image-20210701180417247"></p><p><img src="/img/in/2021-07-01-spock%E6%B5%8B%E8%AF%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/image-20210701180837107.png" alt="image-20210701180837107"></p><p>上面这一步也可以选择创建一个普通Groovy Class，我们手动继承Specification也是一样的。</p><h2 id="3-编写测试方法"><a href="#3-编写测试方法" class="headerlink" title="3.编写测试方法"></a>3.编写测试方法</h2><p>下面就是我们编写的测试方法，我们定义 a &#x3D; 1+1，然后断言 a &#x3D;&#x3D; 2</p><p><img src="/img/in/2021-07-01-spock%E6%B5%8B%E8%AF%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/image-20210701180955534.png" alt="image-20210701180955534"></p><p>上图中的步骤</p><ol><li>我们定义一个方法，其中方法名是双引号引起来的，Groovy中是允许这样的，这也是Spock的一个规范，不用双引号引起来也是可以的。</li><li>使用when: 标识下面的代码块是我们需要执行验证的代码</li><li>我们真正要测试的代码，如果这里面抛出异常，不会导致方法退出，when:代码块内部是被try catch的，框架帮我们try catch住了</li><li>then:代码块，必须和when: 成对出现，两者必须成对，且要写在when:后面</li><li>我们可以在then:代码块中进行断言，不需要assert这样的关键字，直接写语句就可以，使用返回值为boolean的语句,会被当成断言使用</li></ol><h2 id="4-执行"><a href="#4-执行" class="headerlink" title="4.执行"></a>4.执行</h2><p>​就像使用junit一样，点击1处执行测试，我的idea里面有时点击2处的执行不太好使，但1处总是可以的，如果有和我一样的情况，可以尝试使用1处的执行按钮。</p><p><img src="/img/in/2021-07-01-spock%E6%B5%8B%E8%AF%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/image-20210701181926632.png" alt="image-20210701181926632"></p><p>执行通过了。</p><p><img src="/img/in/2021-07-01-spock%E6%B5%8B%E8%AF%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/image-20210701182059634.png" alt="image-20210701182059634"></p><h2 id="5-还有哪些代码块"><a href="#5-还有哪些代码块" class="headerlink" title="5.还有哪些代码块"></a>5.还有哪些代码块</h2><p>上面我们看到，我们在when 中执行我们的逻辑，在then中验证我们的逻辑。除此之外还有下面几个块</p><p><img src="/img/in/2021-07-01-spock%E6%B5%8B%E8%AF%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/image-20210701182812721.png" alt="image-20210701182812721"></p><p>首先</p><p>1 处given，一般是第一个代码块，我们在此准备需要验证的数据</p><p>2 处的when 和 3处的then 是必须配合使用的，when用来执行操作，then用来验证操作</p><p>4 处的and用来分隔，一般写点注释性语句</p><p>5 处的expect相当于 when 和 then 的结合，独立出现，可以在里面执行一些语句，如果语句返回值是boolean，则会被当作断言进行判断。</p><h2 id="6-更强大的where块"><a href="#6-更强大的where块" class="headerlink" title="6.更强大的where块"></a>6.更强大的where块</h2><p>有时我们想测试多组数据，如我们想测试四组数据</p><p>2 &#x3D;&#x3D; Math.max(1,2)</p><p>5 &#x3D;&#x3D; Math.max(4,5)</p><p>10 &#x3D;&#x3D; Math.max(10,5)</p><p>2 &#x3D;&#x3D; Math.max(2,3)</p><p>我们可以使用where块解决此问题</p><p><img src="/img/in/2021-07-01-spock%E6%B5%8B%E8%AF%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/image-20210701183548811.png" alt="image-20210701183548811"></p><ol><li>在代码中使用到了变量 a,b,c但我们并没有在使用之前定义它们</li><li>where块中，我们使用竖线作为分隔符，c a b 作为表头，写了一个表格，这样spock会依次拿表格中的每一行带入到c  a  b的变量总进行测试，上述表格中有四条数据，所以总共测试四次</li></ol><p>执行结果也明确表示，第四条测试没通过：</p><p><img src="/img/in/2021-07-01-spock%E6%B5%8B%E8%AF%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/image-20210701183909934.png" alt="image-20210701183909934"></p><h2 id="7-配合springboot-进行测试"><a href="#7-配合springboot-进行测试" class="headerlink" title="7.配合springboot 进行测试"></a>7.配合springboot 进行测试</h2><p>​在上面基础上，添加spring-boot-starter-test的依赖，排除掉<code>junit-vintage-engine</code>，因为我们需要junit5版本的依赖，而这个是junit4版本的，我们将其排除掉。</p><p>​spock2需要junit5，springboot2自带的就是junit5，spock1需要junit4，springboot1自带的就是junit4。</p><p>​如果需要交叉版本使用，需要自己处理好依赖版本关系。我这里使用的是spock2+springboot2的组合</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hamcrest<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hamcrest-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用方式如下：</p><p><img src="/img/in/2021-07-01-spock%E6%B5%8B%E8%AF%95%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/image-20210701190437780.png" alt="image-20210701190437780"></p><p>1 使用@SpringBootTest注解标识类</p><p>2 自动注入是可以使用的，我们这里注入一个DataSource</p><p>3 验证数据源可用</p><p>4 断言没有抛出任何异常</p><p>5 断言resultSet 非空</p><p>6 点击这里的三角号执行，而不是方法旁边的三角号 （这里也可能是我的idea版本问题，如果下面可以使用，使用下面的也可以的）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​以上就是使用spock的入门教程，一步一步来的话能将spock运行起来，配合springboot也是完全可以的。深入了解的话，可以继续看其他深入点的教程，或直接看官方文档。</p>]]></content>
    
    
    
    <tags>
      
      <tag>spock</tag>
      
      <tag>单元测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring非单例模式</title>
    <link href="/1947246411.html"/>
    <url>/1947246411.html</url>
    
    <content type="html"><![CDATA[<h1 id="spring非单例模式"><a href="#spring非单例模式" class="headerlink" title="spring非单例模式"></a>spring非单例模式</h1><p>​一般情况下，使用spring的bean都是单例模式的，默认情况下就是如此。单例模式的bean都是无状态的，但是面对复杂场景下，希望bean内能存储状态，这种情况下就不能够使用单例模式了。</p><p>spring提供了 <code>@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</code> 注解，可以选择是单例模式还是每次使用都创建一个，用法如下。</p><p>下面提供的AService作用域是prototype的,其会在每次使用时创建一个新的，Controller1 Controller2内注入的AService是两个不同的示例，AService的构造方法也没调用两次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AService</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AService</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;AService 被创建&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Controller1</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    AService aService;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Controller2</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    AService aService;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面是一种场景，他将AService注入不同类时，都创建一个新的实例，但是一旦注入完成后，AService对象就不会再改变了，如果想要方法级别每次使用时都创建一个新的，可以向下面这样做。</p><h1 id="做法1-手动获取"><a href="#做法1-手动获取" class="headerlink" title="做法1,手动获取"></a>做法1,手动获取</h1><p>这种做法不太好，向类中注入一个BeanFactory，每次方法中使用时，从BeanFactory中获取，因为我们的作用域是原型模式，所以每次获取的都会新建一个，满足我们的要求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Controller1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryAware</span> &#123;<br><br>    BeanFactory beanFactory;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">AService</span> <span class="hljs-variable">aService</span> <span class="hljs-operator">=</span> beanFactory.getBean(AService.class);<br>        System.out.println(aService);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-built_in">this</span>.beanFactory = beanFactory;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="做法2，通过ObjectProvider获取"><a href="#做法2，通过ObjectProvider获取" class="headerlink" title="做法2，通过ObjectProvider获取"></a>做法2，通过ObjectProvider获取</h1><p> 注入泛型类型为AService的ObjectProvider，想要使用时，调用其getObject()方法，其内部会像上面手动获取一样，从容器中获取，也能满足我们的要求。<br> 此种方式更优雅一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Controller1</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    ObjectProvider&lt;AService&gt; objectProvider;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">AService</span> <span class="hljs-variable">aService</span> <span class="hljs-operator">=</span> objectProvider.getObject();<br>        System.out.println(aService);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要想解决的问题是，某个类想要被Spring管理，但又是非单例的，我们如何优雅使用该类。<br>我们需要了解的是Spring的作用域，他又两种，一种是单例模式，一种是原型模式，原型模式每次从容器中获取时都会创建一个新的实例。<br>如果只是使用@Resource注入，那么注入后对象就不会再改变，不能实现每次使用都创建新的对象。<br>我们可以注入BeanFactory每次使用时手动获取来实现目的。<br>配合ObjectProvider使用，ObjectProvider帮助我们从容器中获取，可以使代码更优雅。</p>]]></content>
    
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>原型</tag>
      
      <tag>prototype</tag>
      
      <tag>objectProvider</tag>
      
      <tag>objectFactory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring项目，外部文件读取</title>
    <link href="/1679439756.html"/>
    <url>/1679439756.html</url>
    
    <content type="html"><![CDATA[<h1 id="spring，文件读取"><a href="#spring，文件读取" class="headerlink" title="spring，文件读取"></a>spring，文件读取</h1><p>spring内置了不错的文件读取工具类，下面讲一下其用法</p><h2 id="1-读取classpath下文件"><a href="#1-读取classpath下文件" class="headerlink" title="1.读取classpath下文件"></a>1.读取classpath下文件</h2><p>   文件路径以classpath:开头，这种方式可以读取resources文件夹下的资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;classpath:aa.properties&quot;</span>;<br>        org.springframework.core.io.<span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSystemResourceLoader</span>().getResource(filePath);<br>        <br>        System.out.println(resource.exists());<br>        System.out.println(resource.getInputStream());<br>    &#125;<br><br>```    <br>    <br><br>## <span class="hljs-number">2.</span>读取项目相对路径下的文件<br><br>路径直接写相对路径即可，相对于项目执行路径<br><br>```java<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;./1.txt&quot;</span>;<br>        org.springframework.core.io.<span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSystemResourceLoader</span>().getResource(filePath);<br><br>        System.out.println(resource.exists());<br>        System.out.println(resource.getInputStream());<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="3-读取绝对路径下的文件"><a href="#3-读取绝对路径下的文件" class="headerlink" title="3.读取绝对路径下的文件"></a>3.读取绝对路径下的文件</h2><p>读取绝对路径时，路径以file:开头，下面两个示例分别是window和linux的操作方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;file:D:\\test\\1.txt&quot;</span>;<br>    org.springframework.core.io.<span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSystemResourceLoader</span>().getResource(filePath);<br><br>    System.out.println(resource.exists());<br>    System.out.println(resource.getInputStream());<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;file:/home/java/1.txt&quot;</span>;<br>    org.springframework.core.io.<span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSystemResourceLoader</span>().getResource(filePath);<br><br>    System.out.println(resource.exists());<br>    System.out.println(resource.getInputStream());<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>读取到的Resource类上存在一个 resource.getFile()，方法，此方法会将路径转成File，但是有些打包到jar内部的文件无法转成File，会报错，所以建议使用resource.getInputStream()转成流的方式读取文件内容。</p><p>​</p>]]></content>
    
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>FileSystemResourceLoader</tag>
      
      <tag>ResourceLoader</tag>
      
      <tag>文件读取</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>prometheus函数的理解</title>
    <link href="/1388974441.html"/>
    <url>/1388974441.html</url>
    
    <content type="html"><![CDATA[<h1 id="prometheus函数的理解"><a href="#prometheus函数的理解" class="headerlink" title="prometheus函数的理解"></a>prometheus函数的理解</h1><h2 id="最近在研究prometheus，花了一天时间理解了几个主要函数的原理，现在记录以下，给以后的自己看"><a href="#最近在研究prometheus，花了一天时间理解了几个主要函数的原理，现在记录以下，给以后的自己看" class="headerlink" title="最近在研究prometheus，花了一天时间理解了几个主要函数的原理，现在记录以下，给以后的自己看"></a>最近在研究prometheus，花了一天时间理解了几个主要函数的原理，现在记录以下，给以后的自己看</h2><h3 id="rate-函数"><a href="#rate-函数" class="headerlink" title="rate()函数"></a>rate()函数</h3><p>这个函数接受一个范围counter序列，他能返回每秒钟的qps，因为counter是单调递增的，我才他是将最后一个记录的值减去第一个记录的值，再除以时间段的总秒数<br>得到一个浮点型数字，表示每秒增长的数量。这个函数只能返回每秒的数量，如果需要每分钟的可以自己乘以60，因为是浮点类型的，所以精度应该还可以接受。</p><p>与之对应的还有一个increase()函数，他能求出参数指定的counter序列的首尾数值只差，但他其实是先计算出rate(),再乘以时间段的秒数得出来的。<br>相当于给rate()函数包一层。官方推荐得到的值只用于人工查看时方便阅读使用。</p><h3 id="sum-函数"><a href="#sum-函数" class="headerlink" title="sum()函数"></a>sum()函数</h3><p>他的用法如下</p><blockquote><p>sum by (label_a,label_b) (query)</p></blockquote><p>如果query这个查询返回的是多条序列，他能把label_a相同，且label_b也相同的序列点相加形成一个新的点，<br>如我们在两台服务器上都能提供同一个序列，使用sum函数按照相同label聚合后，将多台服务器上的只相加，产生一个新的序列。</p><p>如使用A服务器产生一个qps的折线图，B服务器也产生一个qps的折线图，按照同一个label聚合后将qps值叠加，看起来更清晰。</p><p>使用sum函数计算合并histogram时一般要带上 le 做参数，表示le相同才聚合，因为我们不能将不同le的聚合在一起，那样就没意义了。</p><h3 id="histogram-quantile-函数"><a href="#histogram-quantile-函数" class="headerlink" title="histogram_quantile() 函数"></a>histogram_quantile() 函数</h3><blockquote><p>histogram_quantile(q,v)</p></blockquote><p>q是一个 0-1之间的值，v是一个瞬时向量，且v是一个histogram，他带有一个le的标签，此函数能按照直方图的数值和数量大概猜测出耗时，<br>但是一般使用它时，是不可能将历史所有数据都放在一起计算的，我们要指定时间范围内的数据计算才准确。</p><p>所以一般用法如下面这样的</p><blockquote><p>histogram_quantile(0.9,rate(Request_Count[5m]))</p></blockquote><p>他的原理是先将最近五分钟的数据拿出来，计算出每秒钟的平均次数，其实就是一秒内的数量，使用一秒内的增长值作为直方图，用于计算响应时间。</p><p>我考虑过为什么可以拿一秒钟的次数而不是拿五分钟或十分钟的差值做计算，后来想既然rate()函数也是根据指定范围内的差值除以时间秒数得到的，<br>且结果是浮点小数，只要再乘以时间秒数 （相当于是increase()），就能得到原来的五分钟的时间差值了，所以用一秒钟的数据也不会导致精度损失。</p><h3 id="关于-瞬时向量和区间向量"><a href="#关于-瞬时向量和区间向量" class="headerlink" title="关于 瞬时向量和区间向量"></a>关于 瞬时向量和区间向量</h3><p>有点类似于python里面的数组切片，<br>query 表示一个瞬时向量<br>query[1m] 表示一个当前时间一分钟前到现在这一分钟长度的区间向量。</p><h3 id="end"><a href="#end" class="headerlink" title="end"></a>end</h3><p><a href="https://grafana.com/docs/grafana/latest/datasources/prometheus/">grafana文档</a></p><p><a href="https://prometheus.io/docs/prometheus/latest/querying/functions/#histogram_quantile">prometheus文档</a></p><h2 id="补充-grafana一些细节"><a href="#补充-grafana一些细节" class="headerlink" title="补充 grafana一些细节"></a>补充 grafana一些细节</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>定义常量类型的变量，将Type设为Constant<br>常用的变量类型是Query表示从prometheus中查询结果作为变量，还可以从查询的结果中使用正则表达式切割出想要的字符串作为变量</p><p>如下</p><p><strong>name</strong> 表示指标的名称，这里使用正则表达式匹配满足名称为<code>PaymentSubmitChannel[0-9a-zA-Z]*_bucket</code> 且job等于变量job的指标。<br>再使用正则表达式，将中间的变量部分分组出来<br>这样出来的结果就是我们想要的中间变化的部分了。</p><p>Gragana的正则表达式写法，与js正则相似，需要使用两个斜线将正则表达式包起来</p><p>Queyr : {<strong>name</strong> &#x3D;~ “PaymentSubmitChannel[0-9a-zA-Z]<em>_bucket”,job&#x3D;”$job” }<br>Regex : &#x2F;PaymentSubmitChannel([0-9a-zA-Z]</em>)_bucket&#x2F;</p><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>使用变量推荐下面两种方式<br>{job &#x3D; “$job}  或者 {job &#x3D; “${job}}<br>前一种方式不能将表达式放在字符串中间，后一种方式可以放在字符串中间</p><p>如下，将变量放置在PaymentSubmitChannel${paycode}_bucket 字符串里<br>rate(PaymentSubmitChannel${paycode}_bucket{job &#x3D; “$job”,env&#x3D;”$env”}[1m]))</p>]]></content>
    
    
    
    <tags>
      
      <tag>prometheus</tag>
      
      <tag>grafana</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git同步远程已删除的分支</title>
    <link href="/2591061718.html"/>
    <url>/2591061718.html</url>
    
    <content type="html"><![CDATA[<h1 id="git同步远程已删除的分支"><a href="#git同步远程已删除的分支" class="headerlink" title="git同步远程已删除的分支"></a>git同步远程已删除的分支</h1><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>   我们使用git协作工作时，可能同事会创建一些临时分支，会将这些临时分支push到远程防止本地丢失。<br>这些分支我们使用git fetch&#x2F;pull时会拉到我们本地，存储在我们本地的远程副本区域。<br>    当同事使用完这些分支后，他们会直接将远程分支删除，我们再次使用git fetch&#x2F;pull时，并不会因为远程分支被删除了<br>就同时将本地副本删除，而是一直保留着，这些分支对我们是没用的，如何找到并删除他们呢。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>   使用命令<code>git remote show origin</code>,可以查看到本地副本和远程分支的关联关系，其中显示tracked的表示与远程关联着，<br>显示stale表示远程被删除了，这些我们可以直接使用<code>git remote prune origin</code>删除。</p><h2 id="另一种情况"><a href="#另一种情况" class="headerlink" title="另一种情况"></a>另一种情况</h2><p>   如果同事删除了分支，又push了一份同名的分支到远程怎么办，<br>这个分支远程与本地远程副本不匹配，无法合并，我们可以使用<code>git fetch -f</code> 来强制使用远程的版本，或者不理会这个分支，等待其使用完成删除后，我们再使用上面的办法操作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring-dubbo启动过程</title>
    <link href="/3407224340.html"/>
    <url>/3407224340.html</url>
    
    <content type="html"><![CDATA[<h1 id="spring-dubbo启动过程"><a href="#spring-dubbo启动过程" class="headerlink" title="spring-dubbo启动过程"></a>spring-dubbo启动过程</h1><ol><li><p>首先@EnableDubbo注解将DubboComponentScanRegistrar引入进来</p><pre><code class="hljs">   2. DubboComponentScanRegistrar类会注册一个ServiceAnnotationBeanPostProcessor，这是一个BeanDefinitionRegistry的后置处理器。   3. 后置处理器对BeanDefinitionRegistry进行后置处理，他会使用scan扫描EnableDubbo注解上标注的包名内的类，扫描到的同时会注册进spring。</code></pre></li></ol><p><strong>org.apache.dubbo.config.spring.beans.factory.annotation.ServiceAnnotationBeanPostProcessor#registerServiceBeans</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerServiceBeans</span><span class="hljs-params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> &#123;<br><br>       <span class="hljs-type">DubboClassPathBeanDefinitionScanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span><br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">DubboClassPathBeanDefinitionScanner</span>(registry, environment, resourceLoader);<br><br>       <span class="hljs-type">BeanNameGenerator</span> <span class="hljs-variable">beanNameGenerator</span> <span class="hljs-operator">=</span> resolveBeanNameGenerator(registry);<br><br>       scanner.setBeanNameGenerator(beanNameGenerator);<br><span class="hljs-comment">//扫描带有注解的类，同时兼容阿里版本的dubbo</span><br>       scanner.addIncludeFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationTypeFilter</span>(Service.class));<br>       scanner.addIncludeFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationTypeFilter</span>(com.alibaba.dubbo.config.annotation.Service.class));<br><br>       <span class="hljs-keyword">for</span> (String packageToScan : packagesToScan) &#123;<br><br>           <span class="hljs-comment">// 扫描此包名下的类，此方法里扫描到后会直接注册到spring容器里</span><br>           scanner.scan(packageToScan);<br><br>           Set&lt;BeanDefinitionHolder&gt; beanDefinitionHolders =<br>                   findServiceBeanDefinitionHolders(scanner, packageToScan, registry, beanNameGenerator);<br><br>           <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(beanDefinitionHolders)) &#123;<br><span class="hljs-comment">//将扫描到的dubbo类包装成ServiceBean.class，也注册到spring容器</span><br>               <span class="hljs-keyword">for</span> (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) &#123;<br>                   registerServiceBean(beanDefinitionHolder, registry, scanner);<br>               &#125;<br><br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>                   logger.warn(<span class="hljs-string">&quot;No Spring Bean annotating Dubbo&#x27;s @Service was found under package[&quot;</span><br>                           + packageToScan + <span class="hljs-string">&quot;]&quot;</span>);<br>               &#125;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><p>上述使用scan扫描到的bean，注册到spring的同时，会再包装成ServiceBean也注册到spring里面</p></li><li><p>ServiceBean实现了ApplicationListener接口，其会在监听到事件后，将接口暴漏出去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isExported() &amp;&amp; !isUnexported()) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;<br>            logger.info(<span class="hljs-string">&quot;The service ready on spring started. service: &quot;</span> + getInterface());<br>        &#125;<br>        <span class="hljs-comment">//将接口暴漏出去</span><br>        export();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>​因为ServiceBean是ApplicationListener接口，spring初始化ApplicationListener时，会将ServiceBean一同初始化了，此时要求其内部的Dubbo类也要初始化，如果其没有初始化，ServiceBean在执行export时会因为找不到类而报错。</p><p>​因为Dubbo的export是由spring容器的事件触发的，如果是单容器不会有问题，但是如果容器初始化时创建了子容器，而子容器的事件会发送到父容器里面的，导致父容器还没有初始化完成就export了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea字段按照字母顺序排序</title>
    <link href="/3252428711.html"/>
    <url>/3252428711.html</url>
    
    <content type="html"><![CDATA[<p>idea自动排序，按照字母顺序排序字段。平时格式化快捷键是 ctrl + alt + L，默认情况下字段顺序是按照书写顺序的，但是想要他按照字母顺序排序如果做呢？</p><p>1 首先找到设置中的排序设置部分</p><p><img src="/img/in/2021-02-08-idea%E5%AD%97%E6%AE%B5%E6%8C%89%E7%85%A7%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%BA%8F/image-20210208144404544.png" alt="image-20210208144404544"></p><p>2 双击这个 field private的选项，将排序设成by name</p><p><img src="/img/in/2021-02-08-idea%E5%AD%97%E6%AE%B5%E6%8C%89%E7%85%A7%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%BA%8F/image-20210208144526364.png" alt="image-20210208144526364"></p><p>3 按下快捷键</p><p>ctrl + alt + shift + L ，弹出的窗口中勾选上排序</p><p><img src="/img/in/2021-02-08-idea%E5%AD%97%E6%AE%B5%E6%8C%89%E7%85%A7%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%BA%8F/image-20210208144653234.png" alt="image-20210208144653234"></p><p>4 这样下次排序时就会按照字母顺序排序了，且只对private 的字段生效，因为我们只设置了private 的字段。</p>]]></content>
    
    
    
    <tags>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot jackson默认配置</title>
    <link href="/958846089.html"/>
    <url>/958846089.html</url>
    
    <content type="html"><![CDATA[<p>​</p><h1 id="springboot-jackson默认配置"><a href="#springboot-jackson默认配置" class="headerlink" title="springboot jackson默认配置"></a>springboot jackson默认配置</h1><p>​springboot是约定大约配置，默认就会进行比较合理的配置，自动配置jackson也是如此。下面看一下springboot是如何配置jackson的反序列化特性的。</p><h2 id="配置jackson的方法"><a href="#配置jackson的方法" class="headerlink" title="配置jackson的方法"></a>配置jackson的方法</h2><p>​想要自定义配置jackson，只需实现<code>Jackson2ObjectMapperBuilderCustomizer</code>接口，并注册到spring容器里即可。</p><p>平时我们主要关注下面两个配置，一个是序列化时不返回值为null的字段，二是反序列化时遇到不认识的key不报错而是忽略此key。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JacksonConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Jackson2ObjectMapperBuilderCustomizer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customize</span><span class="hljs-params">(Jackson2ObjectMapperBuilder jacksonObjectMapperBuilder)</span> &#123;<br>        jacksonObjectMapperBuilder.serializationInclusion(JsonInclude.Include.NON_NULL);<br>        jacksonObjectMapperBuilder.failOnUnknownProperties(<span class="hljs-literal">false</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自动配置的jackson配置"><a href="#自动配置的jackson配置" class="headerlink" title="自动配置的jackson配置"></a>自动配置的jackson配置</h2><p>如果没提供自定义的配置，将只使用springboot的默认配置，在<code>JacksonAutoConfiguration</code>类中，存在如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Primary</span><br><span class="hljs-meta">@ConditionalOnMissingBean(ObjectMapper.class)</span><br><span class="hljs-keyword">public</span> ObjectMapper <span class="hljs-title function_">jacksonObjectMapper</span><span class="hljs-params">(Jackson2ObjectMapperBuilder builder)</span> &#123;<br><span class="hljs-keyword">return</span> builder.createXmlMapper(<span class="hljs-literal">false</span>).build();<br>&#125;<br></code></pre></td></tr></table></figure><p>可见其实使用<code>Jackson2ObjectMapperBuilder</code>类来创建ObjectMapper，且关闭了xml功能。</p><p><code>Jackson2ObjectMapperBuilder</code>的创建同样在此类中，因为我们没有传入任何自定义<code>Jackson2ObjectMapperBuilderCustomizer</code>，所以其使用默认的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean(Jackson2ObjectMapperBuilder.class)</span><br><span class="hljs-keyword">public</span> Jackson2ObjectMapperBuilder <span class="hljs-title function_">jacksonObjectMapperBuilder</span><span class="hljs-params">(</span><br><span class="hljs-params">List&lt;Jackson2ObjectMapperBuilderCustomizer&gt; customizers)</span> &#123;<br><span class="hljs-type">Jackson2ObjectMapperBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2ObjectMapperBuilder</span>();<br>builder.applicationContext(<span class="hljs-built_in">this</span>.applicationContext);<br>customize(builder, customizers);<br><span class="hljs-keyword">return</span> builder;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看<code>Jackson2ObjectMapperBuilder</code>类内部的build方法源码，其也是创建一个新的ObjectMapper并对其进行配置，重点就在下面源码的<code>configure(mapper)</code>方法里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ObjectMapper</span>&gt; T <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>ObjectMapper mapper;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.createXmlMapper) &#123;<br>mapper = (<span class="hljs-built_in">this</span>.defaultUseWrapper != <span class="hljs-literal">null</span> ?<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlObjectMapperInitializer</span>().create(<span class="hljs-built_in">this</span>.defaultUseWrapper) :<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlObjectMapperInitializer</span>().create());<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>mapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>&#125;<br>configure(mapper);<br><span class="hljs-keyword">return</span> (T) mapper;<br>&#125;<br></code></pre></td></tr></table></figure><p>​进入configure方法里，其将此构建器的属性进行非空判断，如果不为空就设置到ObjectMapper里。因为我们没有提供任何自定义配置，所以这些值都是空的，其中此方法里有一行调用了<code>customizeDefaultFeatures(objectMapper)</code>方法，其会设置默认配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(ObjectMapper objectMapper)</span> &#123;<br>Assert.notNull(objectMapper, <span class="hljs-string">&quot;ObjectMapper must not be null&quot;</span>);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.findModulesViaServiceLoader) &#123;<br><span class="hljs-comment">// Jackson 2.2+</span><br>objectMapper.registerModules(ObjectMapper.findModules(<span class="hljs-built_in">this</span>.moduleClassLoader));<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.findWellKnownModules) &#123;<br>registerWellKnownModulesIfAvailable(objectMapper);<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.modules != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">for</span> (Module <span class="hljs-keyword">module</span> : <span class="hljs-built_in">this</span>.modules) &#123;<br><span class="hljs-comment">// Using Jackson 2.0+ registerModule method, not Jackson 2.2+ registerModules</span><br>objectMapper.registerModule(<span class="hljs-keyword">module</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.moduleClasses != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">for</span> (Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Module</span>&gt; <span class="hljs-keyword">module</span> : <span class="hljs-built_in">this</span>.moduleClasses) &#123;<br>objectMapper.registerModule(BeanUtils.instantiate(<span class="hljs-keyword">module</span>));<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dateFormat != <span class="hljs-literal">null</span>) &#123;<br>objectMapper.setDateFormat(<span class="hljs-built_in">this</span>.dateFormat);<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.locale != <span class="hljs-literal">null</span>) &#123;<br>objectMapper.setLocale(<span class="hljs-built_in">this</span>.locale);<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.timeZone != <span class="hljs-literal">null</span>) &#123;<br>objectMapper.setTimeZone(<span class="hljs-built_in">this</span>.timeZone);<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.annotationIntrospector != <span class="hljs-literal">null</span>) &#123;<br>objectMapper.setAnnotationIntrospector(<span class="hljs-built_in">this</span>.annotationIntrospector);<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.propertyNamingStrategy != <span class="hljs-literal">null</span>) &#123;<br>objectMapper.setPropertyNamingStrategy(<span class="hljs-built_in">this</span>.propertyNamingStrategy);<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.defaultTyping != <span class="hljs-literal">null</span>) &#123;<br>objectMapper.setDefaultTyping(<span class="hljs-built_in">this</span>.defaultTyping);<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.serializationInclusion != <span class="hljs-literal">null</span>) &#123;<br>objectMapper.setSerializationInclusion(<span class="hljs-built_in">this</span>.serializationInclusion);<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.filters != <span class="hljs-literal">null</span>) &#123;<br>objectMapper.setFilterProvider(<span class="hljs-built_in">this</span>.filters);<br>&#125;<br><br><span class="hljs-keyword">for</span> (Class&lt;?&gt; target : <span class="hljs-built_in">this</span>.mixIns.keySet()) &#123;<br>objectMapper.addMixIn(target, <span class="hljs-built_in">this</span>.mixIns.get(target));<br>&#125;<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.serializers.isEmpty() || !<span class="hljs-built_in">this</span>.deserializers.isEmpty()) &#123;<br><span class="hljs-type">SimpleModule</span> <span class="hljs-variable">module</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleModule</span>();<br>addSerializers(<span class="hljs-keyword">module</span>);<br>addDeserializers(<span class="hljs-keyword">module</span>);<br>objectMapper.registerModule(<span class="hljs-keyword">module</span>);<br>&#125;<br><br>customizeDefaultFeatures(objectMapper);<br><span class="hljs-keyword">for</span> (Object feature : <span class="hljs-built_in">this</span>.features.keySet()) &#123;<br>configureFeature(objectMapper, feature, <span class="hljs-built_in">this</span>.features.get(feature));<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.handlerInstantiator != <span class="hljs-literal">null</span>) &#123;<br>objectMapper.setHandlerInstantiator(<span class="hljs-built_in">this</span>.handlerInstantiator);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.applicationContext != <span class="hljs-literal">null</span>) &#123;<br>objectMapper.setHandlerInstantiator(<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringHandlerInstantiator</span>(<span class="hljs-built_in">this</span>.applicationContext.getAutowireCapableBeanFactory()));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​可以看到当features里面不包含<code>FAIL_ON_UNKNOWN_PROPERTIES</code>时，即我们没有主动将<code>FAIL_ON_UNKNOWN_PROPERTIES</code>设为true或者false，springboot会将其设置为false，这也正符合我们平时的使用习惯。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customizeDefaultFeatures</span><span class="hljs-params">(ObjectMapper objectMapper)</span> &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.features.containsKey(MapperFeature.DEFAULT_VIEW_INCLUSION)) &#123;<br>configureFeature(objectMapper, MapperFeature.DEFAULT_VIEW_INCLUSION, <span class="hljs-literal">false</span>);<br>&#125;<br>       <span class="hljs-comment">//列表内找不到该属性，就将此属性设置为false</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.features.containsKey(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) &#123;<br>configureFeature(objectMapper, DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="hljs-literal">false</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​上面可以看出springboot会为我们自动配置好比较合理的配置，即约定大于配置，我们没有<code>FAIL_ON_UNKNOWN_PROPERTIES</code>的配置时，他会自动将其设为false。</p><p>​于是我们在下次自定义配置时，不配置此属性也是可以的，将上面的配置改为下面这样，其也是能自动设置<code>FAIL_ON_UNKNOWN_PROPERTIES=false</code>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JacksonConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Jackson2ObjectMapperBuilderCustomizer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customize</span><span class="hljs-params">(Jackson2ObjectMapperBuilder jacksonObjectMapperBuilder)</span> &#123;<br>        jacksonObjectMapperBuilder.serializationInclusion(JsonInclude.Include.NON_NULL);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​但是考虑到不是每个人都看过源码，还是推荐加上，这样其他人看到会更清晰一点。</p>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>jackson</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea选中多列，多光标</title>
    <link href="/3542669704.html"/>
    <url>/3542669704.html</url>
    
    <content type="html"><![CDATA[<p>有两个方法，一个是按住alt键，拖动鼠标，但是这种方法只能选中同一个矩形内的列。</p><p>另一个方法是按住shift+alt，使用鼠标<code>左键</code>点击，这样可以在任意多个位置插入光标。</p>]]></content>
    
    
    
    <tags>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RequestBodyAdvice ResponseBodyAdvice</title>
    <link href="/1726040131.html"/>
    <url>/1726040131.html</url>
    
    <content type="html"><![CDATA[<h2 id="RequestBodyAdvice-ResponseBodyAdvice增强类"><a href="#RequestBodyAdvice-ResponseBodyAdvice增强类" class="headerlink" title="RequestBodyAdvice ResponseBodyAdvice增强类"></a>RequestBodyAdvice ResponseBodyAdvice增强类</h2><p>RequestBodyAdvice类和ResponseBodyAdvice是spring提供的接口，它可以在请求参数解析前，和响应输出前对controller的返回值<br>进行拦截，替换。</p><p>先看RequestBodyAdvice的Api，它可以在从流中读取参数前，读取参数后进行拦截</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RequestBodyAdvice</span> &#123;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">supports</span><span class="hljs-params">(MethodParameter methodParameter, Type targetType,</span><br><span class="hljs-params">Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span>;<br><br>HttpInputMessage <span class="hljs-title function_">beforeBodyRead</span><span class="hljs-params">(HttpInputMessage inputMessage, MethodParameter parameter,</span><br><span class="hljs-params">Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> <span class="hljs-keyword">throws</span> IOException;<br><br>Object <span class="hljs-title function_">afterBodyRead</span><span class="hljs-params">(Object body, HttpInputMessage inputMessage, MethodParameter parameter,</span><br><span class="hljs-params">Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span>;<br><br><span class="hljs-meta">@Nullable</span><br>Object <span class="hljs-title function_">handleEmptyBody</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object body, HttpInputMessage inputMessage, MethodParameter parameter,</span><br><span class="hljs-params">Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>再看ResponseBodyAdvice的Api,它可以在输出返回值前，对响应进行拦截</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ResponseBodyAdvice</span>&lt;T&gt; &#123;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">supports</span><span class="hljs-params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span>;<br><br><span class="hljs-meta">@Nullable</span><br>T <span class="hljs-title function_">beforeBodyWrite</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> T body, MethodParameter returnType, MediaType selectedContentType,</span><br><span class="hljs-params">Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType,</span><br><span class="hljs-params">ServerHttpRequest request, ServerHttpResponse response)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>他的加载是在下面这个方法里面实现的</p><blockquote><p>初始化方法<br>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#afterPropertiesSet<br>被调用<br>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#initControllerAdviceCache</p></blockquote><p>他在扫描@controllerAdvice类时，如果发现@controllerAdvice的类同时也是RequestBodyAdvice或ResponseBodyAdvice<br>则将其加入集合中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initControllerAdviceCache</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (getApplicationContext() == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());<br><br>List&lt;Object&gt; requestResponseBodyAdviceBeans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">for</span> (ControllerAdviceBean adviceBean : adviceBeans) &#123;<br>Class&lt;?&gt; beanType = adviceBean.getBeanType();<br><span class="hljs-keyword">if</span> (beanType == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Unresolvable type for ControllerAdviceBean: &quot;</span> + adviceBean);<br>&#125;<br>Set&lt;Method&gt; attrMethods = MethodIntrospector.selectMethods(beanType, MODEL_ATTRIBUTE_METHODS);<br><span class="hljs-keyword">if</span> (!attrMethods.isEmpty()) &#123;<br><span class="hljs-built_in">this</span>.modelAttributeAdviceCache.put(adviceBean, attrMethods);<br>&#125;<br>Set&lt;Method&gt; binderMethods = MethodIntrospector.selectMethods(beanType, INIT_BINDER_METHODS);<br><span class="hljs-keyword">if</span> (!binderMethods.isEmpty()) &#123;<br><span class="hljs-built_in">this</span>.initBinderAdviceCache.put(adviceBean, binderMethods);<br>&#125;<br><br><span class="hljs-keyword">if</span> (RequestBodyAdvice.class.isAssignableFrom(beanType) || ResponseBodyAdvice.class.isAssignableFrom(beanType)) &#123;<br>requestResponseBodyAdviceBeans.add(adviceBean);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!requestResponseBodyAdviceBeans.isEmpty()) &#123;<br><span class="hljs-built_in">this</span>.requestResponseBodyAdvice.addAll(<span class="hljs-number">0</span>, requestResponseBodyAdviceBeans);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>加入集合存储起来，并且在创建<code>RequestResponseBodyMethodProcessor</code>时，将其传递过去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;HandlerMethodReturnValueHandler&gt; <span class="hljs-title function_">getDefaultReturnValueHandlers</span><span class="hljs-params">()</span> &#123;<br>List&lt;HandlerMethodReturnValueHandler&gt; handlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">20</span>);<br><span class="hljs-comment">// Single-purpose return value types</span><br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndViewMethodReturnValueHandler</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelMethodProcessor</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewMethodReturnValueHandler</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseBodyEmitterReturnValueHandler</span>(getMessageConverters(),<br><span class="hljs-built_in">this</span>.reactiveAdapterRegistry, <span class="hljs-built_in">this</span>.taskExecutor, <span class="hljs-built_in">this</span>.contentNegotiationManager));<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamingResponseBodyReturnValueHandler</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpEntityMethodProcessor</span>(getMessageConverters(),<br><span class="hljs-built_in">this</span>.contentNegotiationManager, <span class="hljs-built_in">this</span>.requestResponseBodyAdvice));<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHeadersReturnValueHandler</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CallableMethodReturnValueHandler</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DeferredResultMethodReturnValueHandler</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncTaskMethodReturnValueHandler</span>(<span class="hljs-built_in">this</span>.beanFactory));<br><br><span class="hljs-comment">// Annotation-based return value types</span><br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAttributeMethodProcessor</span>(<span class="hljs-literal">false</span>));<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestResponseBodyMethodProcessor</span>(getMessageConverters(),<br><span class="hljs-built_in">this</span>.contentNegotiationManager, <span class="hljs-built_in">this</span>.requestResponseBodyAdvice));<br><br><span class="hljs-comment">// Multi-purpose return value types</span><br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewNameMethodReturnValueHandler</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MapMethodProcessor</span>());<br><br><span class="hljs-comment">// Custom return value types</span><br><span class="hljs-keyword">if</span> (getCustomReturnValueHandlers() != <span class="hljs-literal">null</span>) &#123;<br>handlers.addAll(getCustomReturnValueHandlers());<br>&#125;<br><br><span class="hljs-comment">// Catch-all</span><br><span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(getModelAndViewResolvers())) &#123;<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndViewResolverMethodReturnValueHandler</span>(getModelAndViewResolvers()));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAttributeMethodProcessor</span>(<span class="hljs-literal">true</span>));<br>&#125;<br><br><span class="hljs-keyword">return</span> handlers;<br>&#125;<br></code></pre></td></tr></table></figure><p>RequestResponseBodyMethodProcessor类就是处理ResponseBody响应的返回值处理器，他在将返回值转换成json返回前调用ResponseBodyAdvice<br>，我们可以在此修改或替换返回值的内容</p><p>同理RequestBodyAdvice是在RequestResponseBodyMethodProcessor解析参数时发挥作用的。</p><p>总结一下就是，</p><ol><li>这两个类一个是在解析参数时发挥作用，一个是在输出返回值前发挥作用</li><li>这两个类的加载时机是在加载@controllerAdvice类时顺便判断的，所以要将这两个类上标注@controllerAdvice才能生效</li><li>输出响应必须使用RequestResponseBodyMethodProcessor处理器或HttpEntityMethodProcessor处理器，这两个Advice才能生效</li></ol><p>一般我用它输出请求响应的值记录到日志里，似乎也没有其他用处非得用这两个不可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ControllerAdvice参数的作用</title>
    <link href="/848881081.html"/>
    <url>/848881081.html</url>
    
    <content type="html"><![CDATA[<h1 id="本文讲一讲ControllerAdvice注解的讲解"><a href="#本文讲一讲ControllerAdvice注解的讲解" class="headerlink" title="本文讲一讲ControllerAdvice注解的讲解"></a>本文讲一讲ControllerAdvice注解的讲解</h1><p>首先看注解的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ControllerAdvice &#123;<br><br><span class="hljs-meta">@AliasFor(&quot;basePackages&quot;)</span><br>String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br><span class="hljs-meta">@AliasFor(&quot;value&quot;)</span><br>String[] basePackages() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>Class&lt;?&gt;[] basePackageClasses() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>Class&lt;?&gt;[] assignableTypes() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt;[] annotations() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>​首先，这个注解标记的类会被声明为全局异常处理器，但是它的优先级比controller中定义的ExceptionHandler注解要低。</p><p>​注解内部有五个方法，其中value和basePackages是一样的。</p><ol><li><code>basePackages</code>表示限制包名，限制controller的类的包名，必须满足匹配</li><li><code>basePackageClasses</code> 类型安全的限制包名方法，框架建议在想要限制的包名内创建一个空的类，这样比上面直接使用包名字符串要好</li><li><code>assignableTypes </code>限制controller类的继承关系</li><li><code>annotations</code> 限制controller上必须存在指定的注解</li></ol><p>如果上面四个参数都没有填写，默认是匹配的。源码在下面。</p><p>ServletInvocableHandlerMethod.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> ServletInvocableHandlerMethod <span class="hljs-title function_">getExceptionHandlerMethod</span><span class="hljs-params">(HandlerMethod handlerMethod, Exception exception)</span> &#123;<br>Class&lt;?&gt; handlerType = (handlerMethod != <span class="hljs-literal">null</span> ? handlerMethod.getBeanType() : <span class="hljs-literal">null</span>);<br><br><span class="hljs-keyword">if</span> (handlerMethod != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-type">ExceptionHandlerMethodResolver</span> <span class="hljs-variable">resolver</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.exceptionHandlerCache.get(handlerType);<br><span class="hljs-keyword">if</span> (resolver == <span class="hljs-literal">null</span>) &#123;<br>resolver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionHandlerMethodResolver</span>(handlerType);<br><span class="hljs-built_in">this</span>.exceptionHandlerCache.put(handlerType, resolver);<br>&#125;<br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> resolver.resolveMethod(exception);<br><span class="hljs-keyword">if</span> (method != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletInvocableHandlerMethod</span>(handlerMethod.getBean(), method);<br>&#125;<br>&#125;<br> <span class="hljs-comment">//上面如果找不到controller中定义的exceptionHandler，则使用全局异常处理器</span><br><span class="hljs-keyword">for</span> (Entry&lt;ControllerAdviceBean, ExceptionHandlerMethodResolver&gt; entry : <span class="hljs-built_in">this</span>.exceptionHandlerAdviceCache.entrySet()) &#123;<br><span class="hljs-comment">//全局异常处理器必须满足条件    </span><br>                <span class="hljs-keyword">if</span> (entry.getKey().isApplicableToBeanType(handlerType)) &#123;<br><span class="hljs-type">ExceptionHandlerMethodResolver</span> <span class="hljs-variable">resolver</span> <span class="hljs-operator">=</span> entry.getValue();<br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> resolver.resolveMethod(exception);<br><span class="hljs-keyword">if</span> (method != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletInvocableHandlerMethod</span>(entry.getKey().resolveBean(), method);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>匹配逻辑源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//参数beanType就是controller对应的类</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isApplicableToBeanType</span><span class="hljs-params">(Class&lt;?&gt; beanType)</span> &#123;<br><span class="hljs-comment">//如果指定的三个限制都没有，默认是匹配的        </span><br><span class="hljs-keyword">if</span> (!hasSelectors()) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanType != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//限制包名</span><br><span class="hljs-keyword">for</span> (String basePackage : <span class="hljs-built_in">this</span>.basePackages) &#123;<br><span class="hljs-keyword">if</span> (beanType.getName().startsWith(basePackage)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//限制类</span><br><span class="hljs-keyword">for</span> (Class&lt;?&gt; clazz : <span class="hljs-built_in">this</span>.assignableTypes) &#123;<br><span class="hljs-keyword">if</span> (ClassUtils.isAssignable(clazz, beanType)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//限制注解</span><br><span class="hljs-keyword">for</span> (Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; annotationClass : <span class="hljs-built_in">this</span>.annotations) &#123;<br><span class="hljs-keyword">if</span> (AnnotationUtils.findAnnotation(beanType, annotationClass) != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//检查注解上的三个参数是否存在</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasSelectors</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> (!<span class="hljs-built_in">this</span>.basePackages.isEmpty() || !<span class="hljs-built_in">this</span>.assignableTypes.isEmpty() || !<span class="hljs-built_in">this</span>.annotations.isEmpty());<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>controllerAdvice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象内内部的静态类会被扫描到吗</title>
    <link href="/2368887570.html"/>
    <url>/2368887570.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-抽象类内部的静态内部类会被spring扫描到吗？"><a href="#1-抽象类内部的静态内部类会被spring扫描到吗？" class="headerlink" title="1.抽象类内部的静态内部类会被spring扫描到吗？"></a>1.抽象类内部的静态内部类会被spring扫描到吗？</h1><p>如下面的例子,B会被spring扫描到吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><br>    <span class="hljs-meta">@Component</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>        <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>答案是会的<br>因为静态内部类在编译完成后会产生两个文件，spring扫描时是按照文件扫描的，所以写在抽象类内部的静态类会被扫描到。<br>可以把静态内部类当成一个独立的类看待，和外部类没什么关系。</p><h1 id="2-类全部经名一样的两个类，spring如何处理的？"><a href="#2-类全部经名一样的两个类，spring如何处理的？" class="headerlink" title="2.类全部经名一样的两个类，spring如何处理的？"></a>2.类全部经名一样的两个类，spring如何处理的？</h1><p>如果正式代码里和测试代码里存在同样路径，同名的类，spring是如何处理的，他会加载哪个？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title function_">doScan</span><span class="hljs-params">(String... basePackages)</span> &#123;<br>    Assert.notEmpty(basePackages, <span class="hljs-string">&quot;At least one base package must be specified&quot;</span>);<br>    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;BeanDefinitionHolder&gt;();<br>    <span class="hljs-keyword">for</span> (String basePackage : basePackages) &#123;<br>        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);<br>        <span class="hljs-keyword">for</span> (BeanDefinition candidate : candidates) &#123;<br>            <span class="hljs-type">ScopeMetadata</span> <span class="hljs-variable">scopeMetadata</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);<br>            candidate.setScope(scopeMetadata.getScopeName());<br>            <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="hljs-built_in">this</span>.registry);<br>            <span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) &#123;<br>                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) &#123;<br>                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (checkCandidate(beanName, candidate)) &#123;<br>                <span class="hljs-type">BeanDefinitionHolder</span> <span class="hljs-variable">definitionHolder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionHolder</span>(candidate, beanName);<br>                definitionHolder =<br>                        AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-built_in">this</span>.registry);<br>                beanDefinitions.add(definitionHolder);<br>                registerBeanDefinition(definitionHolder, <span class="hljs-built_in">this</span>.registry);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> beanDefinitions;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是ClassPathBeanDefinitionScanner类的源码，按照包名扫描到类，再存入Set<BeanDefinition>里面，如果后面遇到全路径名相同的类，由于是set集合，所以后面的会被忽略。<br>而扫描的顺序由类加载器决定，一般是classpath路径的先后顺序排序的，写在前面的先被加载到。</p>]]></content>
    
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea好用插件推荐</title>
    <link href="/1893635003.html"/>
    <url>/1893635003.html</url>
    
    <content type="html"><![CDATA[<h1 id="idea好用插件推荐"><a href="#idea好用插件推荐" class="headerlink" title="idea好用插件推荐"></a>idea好用插件推荐</h1><p>下面是一些我经常用到，好用的idea插件。</p><h3 id="FreeMybatisPuls"><a href="#FreeMybatisPuls" class="headerlink" title="FreeMybatisPuls"></a>FreeMybatisPuls</h3><ul><li>免费</li><li>可以生成 xml 和 mapper 的映射提示</li><li>内置mybatis生成器</li><li>但是 好久不更新了，生成器的部分功能不能用了，但仍然不影响使用</li></ul><p><img src="/img/in/2020-12-04-idea%E5%A5%BD%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/image-20201204205841282.png" alt="image-20201204205841282"></p><h2 id="GenerateAllSet"><a href="#GenerateAllSet" class="headerlink" title="GenerateAllSet"></a>GenerateAllSet</h2><p>按下alt + enter键，一键生成类的所有set方法，再也不用担心输入错误或漏掉了。</p><p><img src="/img/in/2020-12-04-idea%E5%A5%BD%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/image-20201204210300437.png" alt="image-20201204210300437"></p><h2 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h2><p>神器，好用，但别滥用</p><p><img src="/img/in/2020-12-04-idea%E5%A5%BD%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/image-20201204210352928.png" alt="image-20201204210352928"></p><h2 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a>GsonFormat</h2><p>按alt + s快捷键，根据json生成实体类，快速创建pojo</p><p><img src="/img/in/2020-12-04-idea%E5%A5%BD%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/image-20210304143641103.png" alt="image-20210304143641103"></p><h2 id="Mavne-Helper"><a href="#Mavne-Helper" class="headerlink" title="Mavne Helper"></a>Mavne Helper</h2><p>可视化分析maven依赖关系，排除依赖很方便</p><p><img src="/img/in/2020-12-04-idea%E5%A5%BD%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/image-20210304143729825.png" alt="image-20210304143729825"></p><h2 id="SQL-Params-Setter"><a href="#SQL-Params-Setter" class="headerlink" title="SQL Params Setter"></a>SQL Params Setter</h2><p>鼠标选中日志中打印的mybatis日志，右键选择 <code>Sql Params Setter</code> 自动将参数拼接到sql语句里，并复制到剪切板上。</p><p><img src="/img/in/2020-12-04-idea%E5%A5%BD%E7%94%A8%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/image-20210304143826400.png" alt="image-20210304143826400"></p>]]></content>
    
    
    
    <tags>
      
      <tag>技巧</tag>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot注册拦截器不生效</title>
    <link href="/3448019156.html"/>
    <url>/3448019156.html</url>
    
    <content type="html"><![CDATA[<h1 id="springboot注册拦截器不生效"><a href="#springboot注册拦截器不生效" class="headerlink" title="springboot注册拦截器不生效"></a>springboot注册拦截器不生效</h1><p>​通常注册filter是向下面这样注册的，但是如果使用lambda又没有写filter名字就会导致后面的不生效，因为注册时是按照名字作为key存入map里面的，如果已经注册后面同名的就会忽略。</p><p>如果没有给名字，名字就是filter的类名，而lambda的类型是object类，所以是同名的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-keyword">public</span> FilterRegistrationBean&lt;Filter&gt; <span class="hljs-title function_">timeFilter</span><span class="hljs-params">()</span> &#123;<br>       FilterRegistrationBean&lt;Filter&gt; reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterRegistrationBean</span>&lt;&gt;();<br>       reg.setFilter((request, response, chain) -&gt; &#123;<br>           <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> (HttpServletRequest) request;<br>           <span class="hljs-keyword">try</span> &#123;<br>               chain.doFilter(request, response);<br>           &#125; <span class="hljs-keyword">finally</span> &#123;<br>               log.info(<span class="hljs-string">&quot;1111&quot;</span>);<br>           &#125;<br>       &#125;);<br>       reg.addUrlPatterns(<span class="hljs-string">&quot;/*&quot;</span>);<br>       <span class="hljs-keyword">return</span> reg;<br>   &#125;<br><br><span class="hljs-meta">@Bean</span><br>   <span class="hljs-keyword">public</span> FilterRegistrationBean&lt;Filter&gt; <span class="hljs-title function_">timeFilter</span><span class="hljs-params">()</span> &#123;<br>       FilterRegistrationBean&lt;Filter&gt; reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterRegistrationBean</span>&lt;&gt;();<br>       reg.setFilter((request, response, chain) -&gt; &#123;<br>           <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> (HttpServletRequest) request;<br>           <span class="hljs-keyword">try</span> &#123;<br>               chain.doFilter(request, response);<br>           &#125; <span class="hljs-keyword">finally</span> &#123;<br>               log.info(<span class="hljs-string">&quot;222&quot;</span>);<br>           &#125;<br>       &#125;);<br>       reg.addUrlPatterns(<span class="hljs-string">&quot;/*&quot;</span>);<br>       <span class="hljs-keyword">return</span> reg;<br>   &#125;<br></code></pre></td></tr></table></figure><p>上面这样写，第二个是不生效的，正确的做法是像下面这样，给使用setName设置一个名字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br>   <span class="hljs-keyword">public</span> FilterRegistrationBean&lt;Filter&gt; <span class="hljs-title function_">timeFilter</span><span class="hljs-params">()</span> &#123;<br>       FilterRegistrationBean&lt;Filter&gt; reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterRegistrationBean</span>&lt;&gt;();<br>       reg.setFilter((request, response, chain) -&gt; &#123;<br>           <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> (HttpServletRequest) request;<br>           <span class="hljs-keyword">try</span> &#123;<br>               chain.doFilter(request, response);<br>           &#125; <span class="hljs-keyword">finally</span> &#123;<br>               log.info(<span class="hljs-string">&quot;1111&quot;</span>);<br>           &#125;<br>       &#125;);<br>       reg.addUrlPatterns(<span class="hljs-string">&quot;/*&quot;</span>);<br>       reg.setName(<span class="hljs-string">&quot;filter1&quot;</span>);<br>       <span class="hljs-keyword">return</span> reg;<br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode按照字母顺序排序</title>
    <link href="/1013025642.html"/>
    <url>/1013025642.html</url>
    
    <content type="html"><![CDATA[<h1 id="vscode按照字母顺序排序"><a href="#vscode按照字母顺序排序" class="headerlink" title="vscode按照字母顺序排序"></a>vscode按照字母顺序排序</h1><p>接收到json文件，想找到某个字段不好找，所以需要排序下。</p><ol><li>选中想要排序的行，</li><li>ctrl + shift + p 选择按照降序排序</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>技巧</tag>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>保龄球计分算法</title>
    <link href="/1932871321.html"/>
    <url>/1932871321.html</url>
    
    <content type="html"><![CDATA[<h1 id="保龄球计分算法"><a href="#保龄球计分算法" class="headerlink" title="保龄球计分算法"></a>保龄球计分算法</h1><p><strong>题目描述：</strong></p><p>​保龄球前面个会摆放10个球瓶，计分规则如下：</p><p>​如果第一球就把全部的球瓶击倒，所得的分数是10分再加下两球的倒瓶数；如果第一球没有全部击倒，就要再打一次，如果两次能把全部球瓶击倒，则分数是10分再加下一球的倒瓶数；如果两次加一块没有击倒全部球数，则分值为两次的倒瓶数和。</p><p>​请你写一个记分牌程序，统计每次的得分。</p><p>​可以参考下<a href="https://baike.baidu.com/item/%E4%BF%9D%E9%BE%84%E7%90%83/68096#2">保龄球-百度百科</a>介绍的计分规则部分，题目和真实场景下是相同的。</p><blockquote><p>保龄球项目是根据运动员投球所击倒的球瓶数量来计算得分，按运动员在规定局数中所得分数的多少决定胜负。记分规则如下：每局比赛由10格组成，前9格中运动员每格有两次投球机会：（1）如该格第一次投球击倒全部10个球瓶，则不需第二次投球，该格计为全中，该格全中所击倒的瓶数（10分）加随后两次投球所击倒的瓶数为该格所得的分数；（2）若该格第一次投球未能击倒全部10个球瓶，则可投第二次，若第二次投球将剩余的球瓶全部击倒，则该格计为补中，该格两次投球所击到的瓶数（10分）加下一次投球所击倒的瓶数为该格所得的分数；（3）若该格两次投球未能将10个球瓶全部击倒，则称为失误，该格得分为两次投球所击倒的全部瓶数。在第10格中，如果在第一或第二次投球中出现了全中或补中，则运动员可进行第三次投球，该格所得分数为该格实际击倒的球瓶数量。按上述规定将运动员10格所得分数进行累计，即为该局得分</p></blockquote><p><strong>分析：</strong></p><p>​分析此问题，首先一次击球后是无法判断出成绩的，因为一次击球如果全部击倒，则会奖励下两球的倒瓶数，如果两次能全部击倒，则会奖励下一次的倒瓶数，如果两次加一起都没有全部击倒，则直接计算分值。</p><p>所以有如下规则：</p><ul><li><p>如果第一球 &#x3D; 10，则分数等于 第一球 + 第二球 + 第三球</p></li><li><p>如果第一球 + 第二球 &#x3D; 10，则分数等于 第一球 + 第二球 + 第三球</p></li><li><p>如果第一球 + 第二球 &lt; 10，则分数等于 第一球 + 第二球</p></li></ul><p>​所以将每次的分值记录下来，等数据满足条件能够计算时再开始计算，并移除已经计算的部分。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BLQ</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     0 0 0 0 0 0 0 0 0 0 0  剩余附加次数</span><br><span class="hljs-comment">     0 0 0 0 0 0 0 0 0 0 0  附加分</span><br><span class="hljs-comment">     0 0 0 0 0 0 0 0 0 0 0  第二局得分</span><br><span class="hljs-comment">     0 0 0 0 0 0 0 0 0 0 0  第一局得分</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span>[][] scores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">11</span>][<span class="hljs-number">4</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">finish</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addScore</span><span class="hljs-params">(<span class="hljs-type">int</span> score)</span> &#123;<br>        <span class="hljs-keyword">if</span> (finish) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        scores[x][y] = score;<br>        <span class="hljs-comment">//查询前两局，是否需要附加分</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (x - i &gt; <span class="hljs-number">0</span> &amp;&amp; scores[x - i][<span class="hljs-number">3</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>                scores[x - i][<span class="hljs-number">2</span>] += score;<br>                scores[x - i][<span class="hljs-number">3</span>]--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//全中或本次对局完成，调整到下一局</span><br>        <span class="hljs-keyword">if</span> (score == <span class="hljs-number">10</span>) &#123;<br>            scores[x][<span class="hljs-number">3</span>] = <span class="hljs-number">2</span>;<br>            x++;<br>            y = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (y == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (scores[x][<span class="hljs-number">0</span>] + scores[x][<span class="hljs-number">1</span>] == <span class="hljs-number">10</span>) &#123;<br>                scores[x][<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;<br>            &#125;<br>            x++;<br>            y = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            y++;<br>        &#125;<br>        <span class="hljs-comment">//判断是否终止，如果第十局没有中，或者第十局已经投过一次，则终止计分</span><br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">if</span> (scores[<span class="hljs-number">9</span>][<span class="hljs-number">0</span>] != <span class="hljs-number">10</span> &amp;&amp; scores[<span class="hljs-number">9</span>][<span class="hljs-number">0</span>] + scores[<span class="hljs-number">9</span>][<span class="hljs-number">1</span>] != <span class="hljs-number">10</span>) &#123;<br>                finish = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (y &gt; <span class="hljs-number">0</span>) &#123;<br>                finish = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">getScore</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            result.add(scores[i][<span class="hljs-number">0</span>] + scores[i][<span class="hljs-number">1</span>] + scores[i][<span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql事务隔离与原理</title>
    <link href="/305128508.html"/>
    <url>/305128508.html</url>
    
    <content type="html"><![CDATA[<h1 id="mysql事务隔离与原理"><a href="#mysql事务隔离与原理" class="headerlink" title="mysql事务隔离与原理"></a>mysql事务隔离与原理</h1><h2 id="事务遇到的问题"><a href="#事务遇到的问题" class="headerlink" title="事务遇到的问题"></a>事务遇到的问题</h2><p>数据库的隔离级别会遇到下面三个问题，分别是脏读，不可重复读，幻读。</p><p><strong>脏读</strong>：</p><p>​事务A读取到事务B尚未提交的数据，这是不能接受的，如果事务B后面回滚了，事务A就相当于读取到了不存在的脏数据。</p><p><strong>不可重复读</strong>：</p><p>​指事务A读取一条数据 “name&#x3D;张三”，然后事务B修改了该条数据“update name&#x3D;李四”并提交，事务A再次读取时发现name被修改了。这在有些情况下是能接受的，有些情况下是不能接收的，要根据业务需求来。</p><p><strong>幻读</strong>：</p><p>​与不可重复读类似，A先读取“where id &gt; 10”查询出2条数据，此时B插入一条数据并提交，然后A再次读取时发现读取到了三条数据，读取到了<code>幻行</code>，和不可重复读类似，只是关注的点不一样，一个关注数据内容的变化，一个关注数据数量的变化。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>​上面描述的问题在有的业务场景下不允许发生，但在有的业务场景下确是允许发生的，所以mysql提供了四种事务隔离级别，能够由程序员自己根据业务需求配置mysql，选择哪种隔离级别。</p><p>四种隔离级别分别是，读未提交，读已提交，可重复读，序列化。</p><p><strong>读未提交级别Read Uncommitted</strong>：</p><p>​允许读取其他事务未提交的数据，也就是允许上面那三种现象的发生。</p><p><strong>读已提交Read Committed</strong>：</p><p>​允许读取已经提交的数据，未提交的不能读取，这能解决脏读问题，但是无法解决不可重复读和幻读的问题。</p><p><strong>可重复读Repeatable Read</strong>：</p><p>​不允许读取到其他事务已提交的数据，第一次读取时建立当前数据的快照，下次读取仍读取该快照，这样读取到的内容就不会受其他事务插入或修改的数据影响了。</p><p><strong>串行化Serializable</strong>：</p><p>​事务的提交串行化，可以解决上面所有的问题。</p><h3 id="mvcc快照原理"><a href="#mvcc快照原理" class="headerlink" title="mvcc快照原理"></a>mvcc快照原理</h3><p>​每行数据保存两个隐藏的列，分别是创建时的版本号和删除时的版本号。</p><p>进行查询时只查询创建版本号小于等于当前事务，且删除版本号为空或大于当前事务的数据。</p><p>进行更新时将数据的删除版本号设置为当前值，并复制一条数据进行更新，将创建版本号设为当前事务的</p><p>删除时将删除版本号设置当前事务</p><h3 id="行锁和间隙锁"><a href="#行锁和间隙锁" class="headerlink" title="行锁和间隙锁"></a>行锁和间隙锁</h3><p>​如果当前数据库数据如下（id添加主键索引，number添加普通索引）：</p><table><thead><tr><th>id</th><th>number</th></tr></thead><tbody><tr><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>2</td></tr><tr><td>5</td><td>5</td></tr><tr><td>7</td><td>7</td></tr></tbody></table><p>如果事务A执行下面语句，就会对id &#x3D; 2这一条语句加行锁，其他事务无法修改或删除该条数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from table where id = 2 for update<br></code></pre></td></tr></table></figure><p>如果事务A执行下面的语句，将会对 id&gt;2 的部分添加行锁，这里分别是id&#x3D;5和id&#x3D;7，除此之外还会对（7 - max）添加间隙锁，为什么是间隙锁而不是行锁呢，因为此时（7-max）的数据还不存在，也就不能添加行锁了，只能使用间隙锁，锁住暂时不存在的数据的索引间隙。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from table where id &gt; 2 for update<br></code></pre></td></tr></table></figure><p>上面只是间隙锁对唯一索引上的规则，如果是普通索引会有不一样的行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from table where number = 2 for update<br></code></pre></td></tr></table></figure><p>执行这条语句，他与上面不同的是他是查询的number字段而不是id，此时它不但会锁定number &#x3D; 2这条数据，还会添加间隙锁，锁住number处于 （1-2）（2-5]之间的number字段数据。</p><p>那么如果number&lt;&#x3D;1 或者 number &gt;5就能正常修改吗，当然也不一定。还需要满足id的限制。因为number作为二级索引，其下层是以一对多的形式存储主键id的，这里gap锁的左端记录是（1，1），右边数据是（5，5），不仅要求number满足范围条件，也需要id满足条件。</p><p>如果number &lt;&#x3D;1，虽然number的锁满足了，但需要id在区间（-max , 1]</p><p>如果number&gt;5 则需要id在区间 （5 , max）</p><h3 id="再看一个间隙锁的例子"><a href="#再看一个间隙锁的例子" class="headerlink" title="再看一个间隙锁的例子"></a>再看一个间隙锁的例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `ttt` (<br>  `uid` varchar(18) NOT NULL DEFAULT &#x27;&#x27;,<br>  `gap` int NOT NULL ,<br>`name` VARCHAR(10),<br>  PRIMARY KEY (`uid`),<br>  KEY `gap` (`gap`)<br>) ENGINE=InnoDB;<br><br>insert into `ttt` values (&#x27;11111&#x27;,1,&#x27;a1&#x27;);<br>insert into `ttt` values (&#x27;11113&#x27;,3,&#x27;a3&#x27;);<br>insert into `ttt` values (&#x27;11115&#x27;,5,&#x27;a5&#x27;);<br>insert into `ttt` values (&#x27;11117&#x27;,7,&#x27;a7&#x27;);<br>insert into `ttt` values (&#x27;11119&#x27;,9,&#x27;a9&#x27;);<br><br>##锁定gap = 3 的记录<br>BEGIN;<br>select * from `ttt` where `gap`=3  for update;<br><br><br></code></pre></td></tr></table></figure><p>锁定gap&#x3D;3的记录后，同时加在gap上的间隙锁是 (1,5],加在id上的间隙锁是(11111,11115],即其他事务插入的记录必须在 （1，11111）左边或 （5，11115）右边，一下是测试结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into `ttt` values (&#x27;11110&#x27;,0,&#x27;a6&#x27;);  ##success 因为在（1，11111）左边<br>insert into `ttt` values (&#x27;11110&#x27;,1,&#x27;a6&#x27;);  ##success 因为在（1，11111）左边<br>insert into `ttt` values (&#x27;11112&#x27;,1,&#x27;a6&#x27;);  ##block   因为在（1，11111）（5，11115）区间内<br><br>insert into `ttt` values (&#x27;11110&#x27;,2,&#x27;a6&#x27;);  ##block   因为在（1，11111）（5，11115）区间内<br><br>insert into `ttt` values (&#x27;11114&#x27;,5,&#x27;a6&#x27;);  ##block   因为在（1，11111）（5，11115）区间内<br>insert into `ttt` values (&#x27;11116&#x27;,5,&#x27;a6&#x27;);  ##success 因为在（5，11115）右边 <br></code></pre></td></tr></table></figure><p>从这个例子中能清楚的展示，二级索引的next-lock，不是只锁定二级索引对应的字段，而是更加细分到具体id，即使二级索引字段在gap锁范围内，但id在范围外也是可以的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>mysql使用next-lock解决尽量小范围内加锁问题，加锁后被锁定的范围就不能被修改和新增。</p><p>使用mvcc解决不可重复读和幻读问题，这里与锁无关，通过事务版本号和删除版本号，这样就不能读取后面事务做的修改了，但是仅限于快照读，如果发生当前读仍然会读取其他事务做的修改。</p><p>这种特性有时还蛮坑的，需要注意。</p><p>   例1，比如事务1查询 age &#x3D; 10 的记录共10条，事务2修改了其中一条的age，这时快照读读到的仍是10条，当前读读到的就是9条，如果按照age更新就只能更新9条，此时再次当前读还是10条会发现有一条不会被更新。</p><p>   例2，比如事务1查询age &#x3D; 10 的记录共10条，事务2新增一条age &#x3D; 10的记录，这时快照读仍是10条，但当前读读到的是11条，发生过一次当前读后再使用快照读就变成11条了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloudLoadbalance源码解读</title>
    <link href="/2239800896.html"/>
    <url>/2239800896.html</url>
    
    <content type="html"><![CDATA[<h1 id="springCloudLoadbalance源码解读"><a href="#springCloudLoadbalance源码解读" class="headerlink" title="springCloudLoadbalance源码解读"></a>springCloudLoadbalance源码解读</h1><p>​本文讲解<code>spring-cloud-loadbalance</code>这个包，这个包提供了微服务下的负载均衡功能。要想使用负载均衡前提是必须拥有注册中心，同一个名字的服务在注册中心上存在多个实例，这是就需要负载均衡来实现对多个实例的均衡请求。</p><p>​类比一下dns系统，一个域名在dns上可能存在多个ip地址，这就相当于同一个微服务模块在注册中心上存在多个实例，我们进行dns查询后获取到的多个ip地址，我们会选择其中一个进行连接，具体如何选择就需要一种策略来实现。一般查询dns会选择第一个ip地址，而微服务里的负载均衡会采用轮询的方式平均使用所有的实例。</p><h3 id="堵塞式负载均衡接口api"><a href="#堵塞式负载均衡接口api" class="headerlink" title="堵塞式负载均衡接口api"></a>堵塞式负载均衡接口api</h3><p>​</p><p>​首先看它的继承图</p><p><img src="/img/in/2020-09-29-springCloudLoadbalance/image-20200930163757870.png" alt="image-20200930163757870"></p><p>​负载均衡的接口是这样的，他的核心接口是<code>LoadBalancerClient</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ServiceInstanceChooser</span> &#123;<br>    <span class="hljs-comment">//传入微服务id，返回服务的详细信息（ip地址，端口 等）</span><br>ServiceInstance <span class="hljs-title function_">choose</span><span class="hljs-params">(String serviceId)</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LoadBalancerClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceInstanceChooser</span> &#123;<br><br>    <span class="hljs-comment">//传入微服务id和request对象，将request对象的执行返回结果返回</span><br>&lt;T&gt; T <span class="hljs-title function_">execute</span><span class="hljs-params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="hljs-keyword">throws</span> IOException;<br><br>    <span class="hljs-comment">//传入微服务id，微服务实例，request，将request对象的执行结果返回</span><br>&lt;T&gt; T <span class="hljs-title function_">execute</span><span class="hljs-params">(String serviceId, ServiceInstance serviceInstance,</span><br><span class="hljs-params">LoadBalancerRequest&lt;T&gt; request)</span> <span class="hljs-keyword">throws</span> IOException;<br><br>    <span class="hljs-comment">//传入服务信息，和原始uri，将原始uri里面的host字段替换成真实服务的ip并返回</span><br>URI <span class="hljs-title function_">reconstructURI</span><span class="hljs-params">(ServiceInstance instance, URI original)</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>而<code>LoadBalancerRequest</code>对象像下面这样，只需要传入微服务实例，就能得到结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LoadBalancerRequest</span>&lt;T&gt; &#123;<br><br>T <span class="hljs-title function_">apply</span><span class="hljs-params">(ServiceInstance instance)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>​所以核心方法就是<code>choose(String serviceId)</code>，他能由字符串形式的服务id得到服务实例。<code>LoadBalancerClient</code>的默认实现是这样的。我已经将多余部分删除了，他的逻辑就是使用<code>choose</code>方法获取到服务实例，然后调用<code>request</code>对象的apply方法就能得到结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingLoadBalancerClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LoadBalancerClient</span> &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">execute</span><span class="hljs-params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span><br><span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-type">ServiceInstance</span> <span class="hljs-variable">serviceInstance</span> <span class="hljs-operator">=</span> choose(serviceId);<br><span class="hljs-keyword">return</span> execute(serviceId, serviceInstance, request);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">execute</span><span class="hljs-params">(String serviceId, ServiceInstance serviceInstance,</span><br><span class="hljs-params">LoadBalancerRequest&lt;T&gt; request)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-keyword">return</span> request.apply(serviceInstance);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> URI <span class="hljs-title function_">reconstructURI</span><span class="hljs-params">(ServiceInstance serviceInstance, URI original)</span> &#123;<br><span class="hljs-keyword">return</span> LoadBalancerUriTools.reconstructURI(serviceInstance, original);<br>&#125;<br>    <br>    <br>    <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> ServiceInstance <span class="hljs-title function_">choose</span><span class="hljs-params">(String serviceId)</span> &#123;<br>            ReactiveLoadBalancer&lt;ServiceInstance&gt; loadBalancer = loadBalancerClientFactory.getInstance(serviceId);<br>            <span class="hljs-keyword">if</span> (loadBalancer == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            Response&lt;ServiceInstance&gt; loadBalancerResponse = Mono.from(loadBalancer.choose()).block();<br>            <span class="hljs-keyword">if</span> (loadBalancerResponse == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> loadBalancerResponse.getServer();<br>        &#125;<br>    <br><br></code></pre></td></tr></table></figure><p>​可以看到核心方法<code>choose</code>里面的逻辑是委托给<code>ReactiveLoadBalancer</code>来实现的，这是一种常见做法，将堵塞式的方法委托给非堵塞式的方法。下面看看这个非堵塞式接口是如何实现的。</p><h3 id="非堵塞式api"><a href="#非堵塞式api" class="headerlink" title="非堵塞式api"></a>非堵塞式api</h3><p>​上面是堵塞式的方式，而这种纯网络请求，不落库的场景是很容易做成异步形式的，下面看看非堵塞方式的api骨架。</p><p>​</p><p><img src="/img/in/2020-09-29-springCloudLoadbalance/image-20200930163902482.png" alt="image-20200930163902482"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReactorLoadBalancer</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReactiveLoadBalancer</span>&lt;T&gt; &#123;<br><br>Mono&lt;Response&lt;T&gt;&gt; <span class="hljs-title function_">choose</span><span class="hljs-params">(Request request)</span>;<br><br><span class="hljs-keyword">default</span> Mono&lt;Response&lt;T&gt;&gt; <span class="hljs-title function_">choose</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> choose(REQUEST);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>非堵塞式的api更简单，他有一个<code>choose</code>方法，返回值是<code>Response&lt;T&gt;</code>，这个泛型T就是想要的到的结果数据。</p><p>我们要做的事情就是由服务id，选取一个服务实例返回，这就是choose方法应该做到的。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>​上面的就是<code>spring-cloud</code>负载均衡方面的接口定义，具体实现都在<code>spring-cloud-loadbalance</code>依赖里面。</p><p>打开spring.factories文件</p><p><img src="/img/in/2020-09-29-springCloudLoadbalance/image-20200930141712970.png" alt="image-20200930141712970"></p><p>这个包下的配置文件很简单，只有三个，下面一个一个分析。</p><h3 id="1-LoadBalancerCacheAutoConfiguration"><a href="#1-LoadBalancerCacheAutoConfiguration" class="headerlink" title="1. LoadBalancerCacheAutoConfiguration"></a>1. LoadBalancerCacheAutoConfiguration</h3><p>​很显然此类与缓存有关，我们从注册中心获取到的服务信息是要缓存起来的，不可能每次都重新获取，此类上会创建一个<code>LoadBalancerCacheManager</code>对象，底层根据当前chasspath来选择Caffeine或evictor来缓存实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnClass(Caffeine.class)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CaffeineLoadBalancerCacheManagerConfiguration</span> &#123;<br><br><span class="hljs-meta">@Bean(autowireCandidate = false)</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br>LoadBalancerCacheManager <span class="hljs-title function_">caffeineLoadBalancerCacheManager</span><span class="hljs-params">(</span><br><span class="hljs-params">LoadBalancerCacheProperties cacheProperties)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CaffeineBasedLoadBalancerCacheManager</span>(cacheProperties);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-BlockingLoadBalancerClientAutoConfiguration"><a href="#2-BlockingLoadBalancerClientAutoConfiguration" class="headerlink" title="2. BlockingLoadBalancerClientAutoConfiguration"></a>2. BlockingLoadBalancerClientAutoConfiguration</h3><p>​此类也很简单，他创建了<code>BlockingLoadBalancerClient</code>的对象，并且传入<code>LoadBalancerClientFactory</code>，因为堵塞式的处理逻辑是委托给非堵塞式的，这里没有太多逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnBean(LoadBalancerClientFactory.class)</span><br><span class="hljs-meta">@Primary</span><br><span class="hljs-keyword">public</span> BlockingLoadBalancerClient <span class="hljs-title function_">blockingLoadBalancerClient</span><span class="hljs-params">(</span><br><span class="hljs-params">    LoadBalancerClientFactory loadBalancerClientFactory)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingLoadBalancerClient</span>(loadBalancerClientFactory);<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p><p>​此堵塞式的客户端会将所有逻辑委托给非堵塞式的客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ServiceInstance <span class="hljs-title function_">choose</span><span class="hljs-params">(String serviceId)</span> &#123;<br><span class="hljs-comment">//获取非堵塞式客户端</span><br>       ReactiveLoadBalancer&lt;ServiceInstance&gt; loadBalancer = loadBalancerClientFactory.getInstance(serviceId);<br><span class="hljs-keyword">if</span> (loadBalancer == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>       <span class="hljs-comment">//将逻辑委托给非堵塞客户端</span><br>Response&lt;ServiceInstance&gt; loadBalancerResponse = Mono.from(loadBalancer.choose()).block();<br><span class="hljs-keyword">if</span> (loadBalancerResponse == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">return</span> loadBalancerResponse.getServer();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-LoadBalancerAutoConfiguration"><a href="#3-LoadBalancerAutoConfiguration" class="headerlink" title="3. LoadBalancerAutoConfiguration"></a>3. LoadBalancerAutoConfiguration</h3><p>​此方法创建<code>LoadBalancerClientFactory</code>对象，这个类是一个<code>NamedContextFactory</code>类，他能根据当前容器创建子容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> LoadBalancerClientFactory <span class="hljs-title function_">loadBalancerClientFactory</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">LoadBalancerClientFactory</span> <span class="hljs-variable">clientFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoadBalancerClientFactory</span>();<br>clientFactory.setConfigurations(<br><span class="hljs-built_in">this</span>.configurations.getIfAvailable(Collections::emptyList));<br><span class="hljs-keyword">return</span> clientFactory;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造方法如下，默认将<code>LoadBalancerClientConfiguration</code>类注册到子容器内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoadBalancerClientFactory</span><br><span class="hljs-keyword">extends</span> <span class="hljs-title class_">NamedContextFactory</span>&lt;LoadBalancerClientSpecification&gt;<br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">ReactiveLoadBalancer</span>.Factory&lt;ServiceInstance&gt; &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NAMESPACE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;loadbalancer&quot;</span>;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PROPERTY_NAME</span> <span class="hljs-operator">=</span> NAMESPACE + <span class="hljs-string">&quot;.client.name&quot;</span>;<br><br>    <span class="hljs-comment">//默认注册LoadBalancerClientConfiguration类</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LoadBalancerClientFactory</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>(LoadBalancerClientConfiguration.class, NAMESPACE, PROPERTY_NAME);<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">(Environment environment)</span> &#123;<br><span class="hljs-keyword">return</span> environment.getProperty(PROPERTY_NAME);<br>&#125;<br><br>    <span class="hljs-comment">//从容器内获取ReactiveLoadBalancer</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ReactiveLoadBalancer&lt;ServiceInstance&gt; <span class="hljs-title function_">getInstance</span><span class="hljs-params">(String serviceId)</span> &#123;<br><span class="hljs-keyword">return</span> getInstance(serviceId, ReactorServiceInstanceLoadBalancer.class);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>主要看他的<code>getInstance</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getInstance</span><span class="hljs-params">(String name, Class&lt;T&gt; type)</span> &#123;<br>       <span class="hljs-comment">//获取子容器</span><br><span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> getContext(name);<br><span class="hljs-comment">//从子容器内获取type类型的bean</span><br>       <span class="hljs-keyword">if</span> (BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context,<br>type).length &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> context.getBean(type);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取子容器的过程，这里使用缓存存储创建的每个子容器，子容器不会重复创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> AnnotationConfigApplicationContext <span class="hljs-title function_">getContext</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.contexts.containsKey(name)) &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.contexts) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.contexts.containsKey(name)) &#123;<br><span class="hljs-built_in">this</span>.contexts.put(name, createContext(name));<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.contexts.get(name);<br>&#125;<br></code></pre></td></tr></table></figure><p>创建子容器的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> AnnotationConfigApplicationContext <span class="hljs-title function_">createContext</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>();<br>       <span class="hljs-comment">//如果存在name名称的配置将配置注册进去</span><br>       <span class="hljs-comment">//这里的配置可以通过setConfigurations方法设置</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.configurations.containsKey(name)) &#123;<br><span class="hljs-keyword">for</span> (Class&lt;?&gt; configuration : <span class="hljs-built_in">this</span>.configurations.get(name)<br>.getConfiguration()) &#123;<br>context.register(configuration);<br>&#125;<br>&#125;<br>       <br>       <span class="hljs-comment">//查询是否有default.开头的配置，将这些配置注册进去</span><br><span class="hljs-keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="hljs-built_in">this</span>.configurations.entrySet()) &#123;<br><span class="hljs-keyword">if</span> (entry.getKey().startsWith(<span class="hljs-string">&quot;default.&quot;</span>)) &#123;<br><span class="hljs-keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;<br>context.register(configuration);<br>&#125;<br>&#125;<br>&#125;<br>     <br>       <span class="hljs-comment">//注册构造方法里传入的LoadBalancerClientConfiguration.class</span><br>context.register(PropertyPlaceholderAutoConfiguration.class,<br><span class="hljs-built_in">this</span>.defaultConfigType);<br>       <br>         <span class="hljs-comment">//将[propertyName - name] 存入环境变量</span><br>context.getEnvironment().getPropertySources().addFirst(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MapPropertySource</span>(<br><span class="hljs-built_in">this</span>.propertySourceName,<br>Collections.&lt;String, Object&gt;singletonMap(<span class="hljs-built_in">this</span>.propertyName, name)));<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.parent != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//将子容器的父容器设为当前容器</span><br>context.setParent(<span class="hljs-built_in">this</span>.parent);<br>context.setClassLoader(<span class="hljs-built_in">this</span>.parent.getClassLoader());<br>&#125;<br>context.setDisplayName(generateDisplayName(name));<br>context.refresh();<br><span class="hljs-keyword">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p><p>​下面是<code>LoadBalancerClientConfiguration</code>配置类，每个<code>serverId</code>都会创建一个子容器，每个子容器都会解析一遍此类，将解析出来的bean注册进容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoadBalancerClientConfiguration</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">REACTIVE_SERVICE_INSTANCE_SUPPLIER_ORDER</span> <span class="hljs-operator">=</span> <span class="hljs-number">193827465</span>;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> ReactorLoadBalancer&lt;ServiceInstance&gt; <span class="hljs-title function_">reactorServiceInstanceLoadBalancer</span><span class="hljs-params">(</span><br><span class="hljs-params">Environment environment,</span><br><span class="hljs-params">LoadBalancerClientFactory loadBalancerClientFactory)</span> &#123;<br><span class="hljs-comment">//从容器内获取serverId名称</span><br>        <span class="hljs-comment">//因为创建子容器过程中，已经将[propertyName - name]键值对存储环境变量里了，此处获取的就是serverId</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);<br><br>        <span class="hljs-comment">//从容器内获取ServiceInstanceListSupplier对象，这是ServiceInstance的列表</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RoundRobinLoadBalancer</span>(loadBalancerClientFactory.getLazyProvider(name,<br>ServiceInstanceListSupplier.class), name);<br>&#125;<br>    <br> <span class="hljs-comment">/*</span><br><span class="hljs-comment"> 下面这些就是配置ServiceInstanceListSupplier的过程，他会根据当前环境自动选择堵塞式或者非堵塞式</span><br><span class="hljs-comment"> 使用order注解控制顺序，非堵塞式的优先堵塞式的。</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> 同时根据配置文件选择是否根据地域优先或使用health-check</span><br><span class="hljs-comment"> */</span>   <br><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnReactiveDiscoveryEnabled</span><br><span class="hljs-meta">@Order(REACTIVE_SERVICE_INSTANCE_SUPPLIER_ORDER)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactiveSupportConfiguration</span> &#123;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnBean(ReactiveDiscoveryClient.class)</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-meta">@ConditionalOnProperty(value = &quot;spring.cloud.loadbalancer.configurations&quot;,</span><br><span class="hljs-meta">havingValue = &quot;default&quot;, matchIfMissing = true)</span><br><span class="hljs-keyword">public</span> ServiceInstanceListSupplier <span class="hljs-title function_">discoveryClientServiceInstanceListSupplier</span><span class="hljs-params">(</span><br><span class="hljs-params">ConfigurableApplicationContext context)</span> &#123;<br><span class="hljs-keyword">return</span> ServiceInstanceListSupplier.builder().withDiscoveryClient()<br>.withCaching().build(context);<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnBean(ReactiveDiscoveryClient.class)</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-meta">@ConditionalOnProperty(value = &quot;spring.cloud.loadbalancer.configurations&quot;,</span><br><span class="hljs-meta">havingValue = &quot;zone-preference&quot;)</span><br><span class="hljs-keyword">public</span> ServiceInstanceListSupplier <span class="hljs-title function_">zonePreferenceDiscoveryClientServiceInstanceListSupplier</span><span class="hljs-params">(</span><br><span class="hljs-params">ConfigurableApplicationContext context)</span> &#123;<br><span class="hljs-keyword">return</span> ServiceInstanceListSupplier.builder().withDiscoveryClient()<br>.withZonePreference().withCaching().build(context);<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnBean(ReactiveDiscoveryClient.class)</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-meta">@ConditionalOnProperty(value = &quot;spring.cloud.loadbalancer.configurations&quot;,</span><br><span class="hljs-meta">havingValue = &quot;health-check&quot;)</span><br><span class="hljs-keyword">public</span> ServiceInstanceListSupplier <span class="hljs-title function_">healthCheckDiscoveryClientServiceInstanceListSupplier</span><span class="hljs-params">(</span><br><span class="hljs-params">ConfigurableApplicationContext context)</span> &#123;<br><span class="hljs-keyword">return</span> ServiceInstanceListSupplier.builder().withDiscoveryClient()<br>.withHealthChecks().withCaching().build(context);<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnBean(ReactiveDiscoveryClient.class)</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> ServiceInstanceSupplier <span class="hljs-title function_">discoveryClientServiceInstanceSupplier</span><span class="hljs-params">(</span><br><span class="hljs-params">ReactiveDiscoveryClient discoveryClient, Environment env,</span><br><span class="hljs-params">ApplicationContext context)</span> &#123;<br><span class="hljs-type">DiscoveryClientServiceInstanceSupplier</span> <span class="hljs-variable">delegate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DiscoveryClientServiceInstanceSupplier</span>(<br>discoveryClient, env);<br>ObjectProvider&lt;LoadBalancerCacheManager&gt; cacheManagerProvider = context<br>.getBeanProvider(LoadBalancerCacheManager.class);<br><span class="hljs-keyword">if</span> (cacheManagerProvider.getIfAvailable() != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CachingServiceInstanceSupplier</span>(delegate,<br>cacheManagerProvider.getIfAvailable());<br>&#125;<br><span class="hljs-keyword">return</span> delegate;<br>&#125;<br><br>&#125;<br><br><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnBlockingDiscoveryEnabled</span><br><span class="hljs-meta">@Order(REACTIVE_SERVICE_INSTANCE_SUPPLIER_ORDER + 1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingSupportConfiguration</span> &#123;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnBean(DiscoveryClient.class)</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-meta">@ConditionalOnProperty(value = &quot;spring.cloud.loadbalancer.configurations&quot;,</span><br><span class="hljs-meta">havingValue = &quot;default&quot;, matchIfMissing = true)</span><br><span class="hljs-keyword">public</span> ServiceInstanceListSupplier <span class="hljs-title function_">discoveryClientServiceInstanceListSupplier</span><span class="hljs-params">(</span><br><span class="hljs-params">ConfigurableApplicationContext context)</span> &#123;<br><span class="hljs-keyword">return</span> ServiceInstanceListSupplier.builder().withBlockingDiscoveryClient()<br>.withCaching().build(context);<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnBean(DiscoveryClient.class)</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-meta">@ConditionalOnProperty(value = &quot;spring.cloud.loadbalancer.configurations&quot;,</span><br><span class="hljs-meta">havingValue = &quot;zone-preference&quot;)</span><br><span class="hljs-keyword">public</span> ServiceInstanceListSupplier <span class="hljs-title function_">zonePreferenceDiscoveryClientServiceInstanceListSupplier</span><span class="hljs-params">(</span><br><span class="hljs-params">ConfigurableApplicationContext context)</span> &#123;<br><span class="hljs-keyword">return</span> ServiceInstanceListSupplier.builder().withBlockingDiscoveryClient()<br>.withZonePreference().withCaching().build(context);<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnBean(DiscoveryClient.class)</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-meta">@ConditionalOnProperty(value = &quot;spring.cloud.loadbalancer.configurations&quot;,</span><br><span class="hljs-meta">havingValue = &quot;health-check&quot;)</span><br><span class="hljs-keyword">public</span> ServiceInstanceListSupplier <span class="hljs-title function_">healthCheckDiscoveryClientServiceInstanceListSupplier</span><span class="hljs-params">(</span><br><span class="hljs-params">ConfigurableApplicationContext context)</span> &#123;<br><span class="hljs-keyword">return</span> ServiceInstanceListSupplier.builder().withBlockingDiscoveryClient()<br>.withHealthChecks().withCaching().build(context);<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnBean(DiscoveryClient.class)</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> ServiceInstanceSupplier <span class="hljs-title function_">discoveryClientServiceInstanceSupplier</span><span class="hljs-params">(</span><br><span class="hljs-params">DiscoveryClient discoveryClient, Environment env,</span><br><span class="hljs-params">ApplicationContext context)</span> &#123;<br><span class="hljs-type">DiscoveryClientServiceInstanceSupplier</span> <span class="hljs-variable">delegate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DiscoveryClientServiceInstanceSupplier</span>(<br>discoveryClient, env);<br>ObjectProvider&lt;LoadBalancerCacheManager&gt; cacheManagerProvider = context<br>.getBeanProvider(LoadBalancerCacheManager.class);<br><span class="hljs-keyword">if</span> (cacheManagerProvider.getIfAvailable() != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CachingServiceInstanceSupplier</span>(delegate,<br>cacheManagerProvider.getIfAvailable());<br>&#125;<br><span class="hljs-keyword">return</span> delegate;<br>&#125;<br><br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>​下面看<code>RoundRobinLoadBalancer</code>是如何处理的。他从<code>serviceInstanceListSupplierProvider</code>里面获取到<code>List&lt;ServiceInstance&gt;</code>，并使用<code>getInstanceResponse</code>方法轮询选择一个服务对象返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoundRobinLoadBalancer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ReactorServiceInstanceLoadBalancer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> Mono&lt;Response&lt;ServiceInstance&gt;&gt; <span class="hljs-title function_">choose</span><span class="hljs-params">(Request request)</span> &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> move supplier to Request?</span><br><span class="hljs-comment">// Temporary conditional logic till deprecated members are removed.</span><br><span class="hljs-keyword">if</span> (serviceInstanceListSupplierProvider != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-type">ServiceInstanceListSupplier</span> <span class="hljs-variable">supplier</span> <span class="hljs-operator">=</span> serviceInstanceListSupplierProvider<br>.getIfAvailable(NoopServiceInstanceListSupplier::<span class="hljs-keyword">new</span>);<br>            <br>            <span class="hljs-comment">//获取服务列表</span><br><span class="hljs-keyword">return</span> supplier.get().next().map(<span class="hljs-built_in">this</span>::getInstanceResponse);<br>&#125;<br><span class="hljs-type">ServiceInstanceSupplier</span> <span class="hljs-variable">supplier</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.serviceInstanceSupplier<br>.getIfAvailable(NoopServiceInstanceSupplier::<span class="hljs-keyword">new</span>);<br><span class="hljs-keyword">return</span> supplier.get().collectList().map(<span class="hljs-built_in">this</span>::getInstanceResponse);<br>&#125;<br>    <br>    <span class="hljs-comment">//使用轮询的方式</span><br>    <span class="hljs-keyword">private</span> Response&lt;ServiceInstance&gt; <span class="hljs-title function_">getInstanceResponse</span><span class="hljs-params">(</span><br><span class="hljs-params">        List&lt;ServiceInstance&gt; instances)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> Math.abs(<span class="hljs-built_in">this</span>.position.incrementAndGet());<br><br>        <span class="hljs-type">ServiceInstance</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> instances.get(pos % instances.size());<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultResponse</span>(instance);<br>    &#125;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><p>​默认<code>ServiceInstanceListSupplier</code>的生成是有<code>ServiceInstanceListSupplier.builder</code>工具类实现的，最后调用的<code>build</code>方法将当前容器传入进去，所需的<code>discoverClient</code>，<code>cache</code>等都能从容器内获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ServiceInstanceListSupplier <span class="hljs-title function_">discoveryClientServiceInstanceListSupplier</span><span class="hljs-params">(</span><br><span class="hljs-params">    ConfigurableApplicationContext context)</span> &#123;<br>    <span class="hljs-keyword">return</span> ServiceInstanceListSupplier.builder().withDiscoveryClient()<br>        .withCaching().build(context);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LoadBalancerClient注解"><a href="#LoadBalancerClient注解" class="headerlink" title="@LoadBalancerClient注解"></a>@LoadBalancerClient注解</h3><p>​在创建<code>LoadBalancerClientFactory</code>时注意到调用<code>setConfigurations</code>方法，这些配置类是自动注入进来的，那么这些配置类是从哪里创建的，又是在哪里起作用的呢，通过<code>@LoadBalancerClient</code>注解可以方便的注入这些配置进去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> LoadBalancerClientFactory <span class="hljs-title function_">loadBalancerClientFactory</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">LoadBalancerClientFactory</span> <span class="hljs-variable">clientFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoadBalancerClientFactory</span>();<br>clientFactory.setConfigurations(<br><span class="hljs-built_in">this</span>.configurations.getIfAvailable(Collections::emptyList));<br><span class="hljs-keyword">return</span> clientFactory;<br>&#125;<br></code></pre></td></tr></table></figure><p>注解需要提供名称表明配置要注册到哪个子容器里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> LoadBalancerClient &#123;<br><br><span class="hljs-meta">@AliasFor(&quot;name&quot;)</span><br>String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-meta">@AliasFor(&quot;value&quot;)</span><br>String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>Class&lt;?&gt;[] configuration() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>此注解引入了<code>LoadBalancerClientConfigurationRegistrar</code>类，这里将注解上name和configuration包装成<code>LoadBalancerClientSpecification</code>对象，注册到容器里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata,</span><br><span class="hljs-params">BeanDefinitionRegistry registry)</span> &#123;<br>Map&lt;String, Object&gt; attrs = metadata<br>.getAnnotationAttributes(LoadBalancerClients.class.getName(), <span class="hljs-literal">true</span>);<br><span class="hljs-keyword">if</span> (attrs != <span class="hljs-literal">null</span> &amp;&amp; attrs.containsKey(<span class="hljs-string">&quot;value&quot;</span>)) &#123;<br>AnnotationAttributes[] clients = (AnnotationAttributes[]) attrs.get(<span class="hljs-string">&quot;value&quot;</span>);<br><span class="hljs-keyword">for</span> (AnnotationAttributes client : clients) &#123;<br>registerClientConfiguration(registry, getClientName(client),<br>client.get(<span class="hljs-string">&quot;configuration&quot;</span>));<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (attrs != <span class="hljs-literal">null</span> &amp;&amp; attrs.containsKey(<span class="hljs-string">&quot;defaultConfiguration&quot;</span>)) &#123;<br>String name;<br><span class="hljs-keyword">if</span> (metadata.hasEnclosingClass()) &#123;<br>name = <span class="hljs-string">&quot;default.&quot;</span> + metadata.getEnclosingClassName();<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>name = <span class="hljs-string">&quot;default.&quot;</span> + metadata.getClassName();<br>&#125;<br>registerClientConfiguration(registry, name,<br>attrs.get(<span class="hljs-string">&quot;defaultConfiguration&quot;</span>));<br>&#125;<br>Map&lt;String, Object&gt; client = metadata<br>.getAnnotationAttributes(LoadBalancerClient.class.getName(), <span class="hljs-literal">true</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> getClientName(client);<br><span class="hljs-keyword">if</span> (name != <span class="hljs-literal">null</span>) &#123;<br>registerClientConfiguration(registry, name, client.get(<span class="hljs-string">&quot;configuration&quot;</span>));<br>&#125;<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerClientConfiguration</span><span class="hljs-params">(BeanDefinitionRegistry registry,</span><br><span class="hljs-params">Object name, Object configuration)</span> &#123;<br><span class="hljs-type">BeanDefinitionBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> BeanDefinitionBuilder<br>.genericBeanDefinition(LoadBalancerClientSpecification.class);<br>builder.addConstructorArgValue(name);<br>builder.addConstructorArgValue(configuration);<br>registry.registerBeanDefinition(name + <span class="hljs-string">&quot;.LoadBalancerClientSpecification&quot;</span>,<br>builder.getBeanDefinition());<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p><p>​创建子容器时，根据名字从列表里获取配置并注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> AnnotationConfigApplicationContext <span class="hljs-title function_">createContext</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>();<br>    <span class="hljs-comment">//根据名字选择筛选出配置，将配置注册到子容器里</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.configurations.containsKey(name)) &#123;<br><span class="hljs-keyword">for</span> (Class&lt;?&gt; configuration : <span class="hljs-built_in">this</span>.configurations.get(name)<br>.getConfiguration()) &#123;<br>context.register(configuration);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (Map.Entry&lt;String, C&gt; entry : <span class="hljs-built_in">this</span>.configurations.entrySet()) &#123;<br><span class="hljs-keyword">if</span> (entry.getKey().startsWith(<span class="hljs-string">&quot;default.&quot;</span>)) &#123;<br><span class="hljs-keyword">for</span> (Class&lt;?&gt; configuration : entry.getValue().getConfiguration()) &#123;<br>context.register(configuration);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面可以看到<code>@LoadBalancerClient</code>是引入一个名字和配置类，配置类最终会注册到名称指定的子容器里。</p><p>总结一下负载均衡获取根据实例id获取实例的过程</p><ol><li>创建<code>LoadBalancerClientFactory</code>工厂类，其是一个子容器的工厂</li><li><code>LoadBalancerClientFactory</code>获取bean时会自动创建子容器，创建过程中会解析配置类（构造方法里传入的和<code>@LoadBalancerClient</code>注解引入的）</li><li>由工厂类获取<code>ReactiveLoadBalancer</code>对象（解析好配置类后，此对象就会在子容器里）</li><li>创建<code>BlockingLoadBalancerClient</code>供堵塞式api使用，其将逻辑委托给<code>ReactiveLoadBalancer</code></li><li>这样我们就能从容器里获取堵塞式和非堵塞式的<code>LoadbalancerClient</code>了</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​<code>spring-loadbalance</code>是一个小巧的库，它支持堵塞式和非堵塞式的api，其中堵塞式是委托给非堵塞式来完成的，它的原理是使用<code>DiscoverClient</code>获取指定服务id对应的服务实例列表，通过轮询的方式从其中选择一个实例，并且可以配置缓存。 </p>]]></content>
    
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>springcloud</tag>
      
      <tag>负载均衡</tag>
      
      <tag>loadbalance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springGateway配置需要注意的点</title>
    <link href="/1448015480.html"/>
    <url>/1448015480.html</url>
    
    <content type="html"><![CDATA[<h1 id="springGateway配置需要注意的点"><a href="#springGateway配置需要注意的点" class="headerlink" title="springGateway配置需要注意的点"></a>springGateway配置需要注意的点</h1><h2 id="1-超时时间"><a href="#1-超时时间" class="headerlink" title="1. 超时时间"></a>1. 超时时间</h2><p>​springGateway使用的是WebFlux里面的WebClient来执行请求，WebClient有一些超时时间需要配置，</p><p>默认的可能不太合适。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#默认连接时间，默认45秒，太长了可以在此配置</span><br><span class="hljs-attr">spring.cloud.gateway.httpclient.connect-timeout</span>=<span class="hljs-string"></span><br><span class="hljs-comment">#响应读取时间，默认不设置超时时间，可以在此设置</span><br><span class="hljs-attr">spring.cloud.gateway.httpclient.response-timeout</span>=<span class="hljs-string"></span><br><span class="hljs-comment">#HttpClient连接池，最大空闲时间，默认无限制，可以在此配置</span><br><span class="hljs-attr">spring.cloud.gateway.httpclient.pool.max-idle-time</span>=<span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h2 id="2-缓存时间"><a href="#2-缓存时间" class="headerlink" title="2.缓存时间"></a>2.缓存时间</h2><p>​gateway里面难免要使用负载均衡，如果使用的是Spring-cloud-loadbalance实现，loadbalance从discover-client拿到实例信息会存入缓存，默认缓存30秒。因为discover-client本身可能也带有缓存(不同的discover-client可能不一样)，所以loadbalance里的缓存没必要太长时间，此处调整成5秒</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#默认30s，但其实没必要这么长时间</span><br><span class="hljs-attr">spring.cloud.loadbalancer.cache.ttl</span>=<span class="hljs-string">5s</span><br><span class="hljs-comment">#关闭ribbon，才会启用cloud-loadbalance</span><br><span class="hljs-attr">spring.cloud.loadbalancer.ribbon.enabled</span>=<span class="hljs-string">false</span><br></code></pre></td></tr></table></figure><h2 id="3-异常拦截返回值"><a href="#3-异常拦截返回值" class="headerlink" title="3.异常拦截返回值"></a>3.异常拦截返回值</h2><p>​默认情况下，gateway报错时会输出简单的错误json，或空白错误页面，但页面中的隐私的信息如错误堆栈会被删掉，调试阶段，可以将它开启，更多选项都在<code>server.error.</code>里面</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.error.whitelabel.enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">server.error.include-exception</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">server.error.include-message</span>=<span class="hljs-string">always</span><br></code></pre></td></tr></table></figure><p>这里的控制逻辑在<code>org.springframework.boot.web.reactive.error.DefaultErrorAttributes#getErrorAttributes(org.springframework.web.reactive.function.server.ServerRequest, org.springframework.boot.web.error.ErrorAttributeOptions)</code>方法里，如果没在<code>server.error.</code>配置里开启的数据，都被移除了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">getErrorAttributes</span><span class="hljs-params">(ServerRequest request, ErrorAttributeOptions options)</span> &#123;<br>Map&lt;String, Object&gt; errorAttributes = getErrorAttributes(request, options.isIncluded(Include.STACK_TRACE));<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.includeException != <span class="hljs-literal">null</span>) &#123;<br>options = options.including(Include.EXCEPTION);<br>&#125;<br>       <span class="hljs-comment">//remove了</span><br><span class="hljs-keyword">if</span> (!options.isIncluded(Include.EXCEPTION)) &#123;<br>errorAttributes.remove(<span class="hljs-string">&quot;exception&quot;</span>);<br>&#125;<br>       <span class="hljs-comment">//remove了</span><br><span class="hljs-keyword">if</span> (!options.isIncluded(Include.STACK_TRACE)) &#123;<br>errorAttributes.remove(<span class="hljs-string">&quot;trace&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (!options.isIncluded(Include.MESSAGE) &amp;&amp; errorAttributes.get(<span class="hljs-string">&quot;message&quot;</span>) != <span class="hljs-literal">null</span>) &#123;<br>errorAttributes.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br>       <span class="hljs-comment">//remove了</span><br><span class="hljs-keyword">if</span> (!options.isIncluded(Include.BINDING_ERRORS)) &#123;<br>errorAttributes.remove(<span class="hljs-string">&quot;errors&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> errorAttributes;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-断路器"><a href="#4-断路器" class="headerlink" title="4.断路器"></a>4.断路器</h2><p>​如果使用的Resilience4J作为断路器，一定要进行配置，因为默认的断路器超时时间是1秒，这肯定是不够的。自定义一个Customizer，将超时时间设为60秒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Resilience4JConfig</span> &#123;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Customizer&lt;ReactiveResilience4JCircuitBreakerFactory&gt; <span class="hljs-title function_">customReactiveResilience4j</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> factory -&gt; factory.configureDefault(id -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resilience4JConfigBuilder</span>(id)<br>.circuitBreakerConfig(CircuitBreakerConfig.ofDefaults())<br>.timeLimiterConfig(TimeLimiterConfig.custom().timeoutDuration(Duration.ofSeconds(<span class="hljs-number">60</span>)).build())<br>.build());<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>需要添加的依赖是，才能使用resilience4j。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-circuitbreaker-reactor-resilience4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-路由顺序"><a href="#5-路由顺序" class="headerlink" title="5.路由顺序"></a>5.路由顺序</h2><p>生成RouteLocator是没有顺序的，不会按照最佳匹配来处理，要想让生成的RouteLocator排在前面可以使用<code>@Order</code>注解，添加注解的一定优先于不加注解的，注解里面填的数字越小越优先。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Order(-1)</span><br><span class="hljs-keyword">public</span> RouteLocator <span class="hljs-title function_">test</span><span class="hljs-params">(RouteLocatorBuilder builder)</span> &#123;<br><span class="hljs-keyword">return</span> builder.routes()<br>.route(ps -&gt; ps.path(<span class="hljs-string">&quot;/test&quot;</span>)<br>.uri(<span class="hljs-string">&quot;lb://server&quot;</span>)<br>)<br>.build();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-添加filter的方式"><a href="#6-添加filter的方式" class="headerlink" title="6.添加filter的方式"></a>6.添加filter的方式</h2><p>下面两种添加filter的方式有什么区别吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RouteLocator <span class="hljs-title function_">test</span><span class="hljs-params">(RouteLocatorBuilder builder)</span> &#123;<br>    <span class="hljs-keyword">return</span> builder.routes()<br>        .route(ps -&gt; ps.path(<span class="hljs-string">&quot;/aaa&quot;</span>)<br>               .filters(sp -&gt; sp.filter((ex, chain) -&gt; chain.filter(ex)))<br>               .uri(<span class="hljs-string">&quot;lb://server&quot;</span>)<br>              )<br>        <br>        .route(ps -&gt; ps.path(<span class="hljs-string">&quot;/bbb&quot;</span>)<br>               .uri(<span class="hljs-string">&quot;lb://server&quot;</span>)<br>               .filter((ex, chain) -&gt; chain.filter(ex))<br>              )<br>        .build();<br>&#125;<br></code></pre></td></tr></table></figure><p>答:</p><p>​一个是在执行path后，使用<code>filters</code>添加，一个是在uri方法后使用<code>filter</code>方法添加。既然是filter链肯定是要排序的，第一种方式添加filter会被包装成OrderFilter，排序号为0，第二种方式filter不会被包装，没有排序号。</p><p>​gateway默认提供的十个globalFilter是实现Order接口的，所以第一种方式添加的filter，会插入到globalFIlter之间（具体顺序请查看每个globalFilter的顺序），第二种方式加入的filter会插入在所有globalFilter之后。</p>]]></content>
    
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>springGateway</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring事务和事务传播</title>
    <link href="/300000547.html"/>
    <url>/300000547.html</url>
    
    <content type="html"><![CDATA[<h1 id="spring事务和事务传播"><a href="#spring事务和事务传播" class="headerlink" title="spring事务和事务传播"></a>spring事务和事务传播</h1><h2 id="1-原生的事务控制是这样的"><a href="#1-原生的事务控制是这样的" class="headerlink" title="1.原生的事务控制是这样的"></a>1.原生的事务控制是这样的</h2><p>​原生的事务是这样使用的，需要将连接设为非自动提交，执行完sql语句后，可以选择提交或者回滚。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>    <span class="hljs-keyword">try</span> &#123;<br>        connection.setAutoCommit(<span class="hljs-literal">false</span>);<br>        connection.createStatement().executeQuery(<span class="hljs-string">&quot;select * from user where id = 1&quot;</span>);<br>        connection.createStatement().executeQuery(<span class="hljs-string">&quot;select * from user where id = 2&quot;</span>);<br>        connection.commit();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        connection.rollback();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了直接提交外，还可以设置savepoint，可以回滚到指定的savepoint。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>    <span class="hljs-keyword">try</span> &#123;<br>        connection.setAutoCommit(<span class="hljs-literal">false</span>);<br>        connection.createStatement().executeQuery(<span class="hljs-string">&quot;select * from user where id = 1&quot;</span>);<br>        <span class="hljs-comment">//执行出错时，可以回滚到保存点</span><br>        <span class="hljs-type">Savepoint</span> <span class="hljs-variable">savepoint</span> <span class="hljs-operator">=</span> connection.setSavepoint();<br>        <span class="hljs-keyword">try</span> &#123;<br>            connection.createStatement().executeQuery(<span class="hljs-string">&quot;select * from user where id = 2&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            connection.rollback(savepoint);<br>        &#125;<br>        connection.releaseSavepoint(savepoint);<br>        connection.commit();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        connection.rollback();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-spring的事务控制"><a href="#2-spring的事务控制" class="headerlink" title="2.spring的事务控制"></a>2.spring的事务控制</h2><p>spring的事务传播级别有七种，分为三类</p><p>1.必须要在事务里运行的</p><table><thead><tr><th>事务级别</th><th>解释</th></tr></thead><tbody><tr><td>REQUIRED</td><td>如果当前存在事务，加入当前事务，否则创建新的</td></tr><tr><td>REQUIRES_NEW</td><td>如果当前存在事务，则挂起他，开启新的事物执行</td></tr><tr><td>MANDATORY</td><td>如果当前存在事务，加入当前事务，否则报错</td></tr><tr><td>NESTED</td><td>如果当前存在事务，使用嵌套事物执行，否则开启新事务</td></tr></tbody></table><p>2.必须以非事务运行的</p><table><thead><tr><th>事务级别</th><th>解释</th></tr></thead><tbody><tr><td>NOT_SUPPORTED</td><td>以非事务方式执行，如果当前存在事务，则挂起他</td></tr><tr><td>NEVER</td><td>以非事务方式执行，如果当前存在事务，则报错</td></tr></tbody></table><p>3.有没有事物都可以运行的</p><table><thead><tr><th>事务级别</th><th>解释</th></tr></thead><tbody><tr><td>SUPPORTS</td><td>当前存在事务就加入，没有就已非事务方式执行</td></tr></tbody></table><p>​Spring是使用Aop对方法进行拦截实现自动管理事务的，在方法前后进行拦截。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown">方法执行前执行<br>&#123;<br><span class="hljs-code">    通过DataSource获取一个连接</span><br><span class="hljs-code">    设置连接的AutoCommit = false</span><br><span class="hljs-code">    存储到ThreadLocal上，与线程绑定</span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code"></span><br>执行方法<br>&#123;<br><span class="hljs-code">使用ThreadLocal上的连接执行sql语句，需要保证使用的是ThreadLocal上绑定的连接才能自动管理事物  </span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code"></span><br>方法执行后<br>&#123;<br><span class="hljs-code">从ThreadLocal上拿到链接，根据方法执行中是否报错，决定回滚或者提交</span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><p>​如何保证方法内获取的连接就是ThreadLocal上存储的连接呢？</p><p>​</p><p>​获取连接，可以使用<code>DataSourceUtils</code>工具类，如果当前ThreadLocal存在连接，它会返回ThreadLocal上的，否则才返回数据源内的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DataSourceUtils.getConnection(dataSource);<br></code></pre></td></tr></table></figure><p>​</p><p>​如果使用的是<code>MyBatis</code>，<code>Mybatis</code>获取连接的是使用<code>Transaction</code>对象获取连接的。整合Spring时使用的是<code>SpringManagedTransaction</code>对象，其会按照Spring的规范，使用DataSourceUtils获取连接。</p><p>​</p><p>​如果使用的是<code>JdbcTemplate</code>，此对象获取连接方法也是使用的DataSourceUtils工具类。</p><p>​其他orm框架要想使用Spring的事物管理，都需要使用DataSourceUtils工具类获取连接，这样才能被Spring管理。</p><h4 id="下面是DataSourceUtils工具类获取连接的实现逻辑"><a href="#下面是DataSourceUtils工具类获取连接的实现逻辑" class="headerlink" title="下面是DataSourceUtils工具类获取连接的实现逻辑"></a>下面是DataSourceUtils工具类获取连接的实现逻辑</h4><p>​先从ThreadLocal上获取，没有再从连接池上获取的逻辑就是工具类DataSourceUtils实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">doGetConnection</span><span class="hljs-params">(DataSource dataSource)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><span class="hljs-comment">//从ThreadLocal上获取连接，委托给TransactionSynchronizationManager</span><br><span class="hljs-type">ConnectionHolder</span> <span class="hljs-variable">conHolder</span> <span class="hljs-operator">=</span> (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);<br>       <br>       <span class="hljs-comment">//如果存在则返回</span><br><span class="hljs-keyword">if</span> (conHolder != <span class="hljs-literal">null</span> &amp;&amp; (conHolder.hasConnection() || conHolder.isSynchronizedWithTransaction())) &#123;<br>conHolder.requested();<br><span class="hljs-keyword">if</span> (!conHolder.hasConnection()) &#123;<br>logger.debug(<span class="hljs-string">&quot;Fetching resumed JDBC Connection from DataSource&quot;</span>);<br>conHolder.setConnection(dataSource.getConnection());<br>&#125;<br><span class="hljs-keyword">return</span> conHolder.getConnection();<br>&#125;<br><br>       <span class="hljs-comment">//否则从连接池获取连接</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br><br>       <span class="hljs-comment">//如果开启了事物，则设置到ThreadLocal上供下次使用，否则不设置</span><br><span class="hljs-keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;<br><span class="hljs-type">ConnectionHolder</span> <span class="hljs-variable">holderToUse</span> <span class="hljs-operator">=</span> conHolder;<br><span class="hljs-keyword">if</span> (holderToUse == <span class="hljs-literal">null</span>) &#123;<br>holderToUse = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionHolder</span>(con);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>holderToUse.setConnection(con);<br>&#125;<br>holderToUse.requested();<br>TransactionSynchronizationManager.registerSynchronization(<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionSynchronization</span>(holderToUse, dataSource));<br>holderToUse.setSynchronizedWithTransaction(<span class="hljs-literal">true</span>);<br><span class="hljs-keyword">if</span> (holderToUse != conHolder) &#123;<br>TransactionSynchronizationManager.bindResource(dataSource, holderToUse);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> con;<br>&#125;<br></code></pre></td></tr></table></figure><p>​无论使用的是什么orm框架，只要执行Sql时使用的是ThreadLocal里面的连接，就能被Spring的事务管理器管理。</p><hr><h2 id="3-事物传播属性的影响"><a href="#3-事物传播属性的影响" class="headerlink" title="3.事物传播属性的影响"></a>3.事物传播属性的影响</h2><p>​例如下面这样有一个TestController，调用TestService的方法。Controller 和 Service都开启了事物。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">//controller 存在事务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br>       <span class="hljs-meta">@Autowired</span><br>       <span class="hljs-keyword">private</span> TestService testService;<br><br>       <span class="hljs-meta">@RequestMapping(&quot;test&quot;)</span><br>       <span class="hljs-meta">@Transactional</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>           sqlSession.selectList(<span class="hljs-string">&quot;com.item.dao.selectById&quot;</span>, <span class="hljs-number">1</span>);<br>           testService.getItem();<br>       &#125;<br>&#125;<br><br><br><br><span class="hljs-comment">//service 存在事务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestService</span>&#123;<br>       <br>       <span class="hljs-meta">@Transactional</span><br>       <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">getItem</span><span class="hljs-params">()</span> &#123;<br>           sqlSession.selectList(<span class="hljs-string">&quot;com.item.dao.selectById&quot;</span>, <span class="hljs-number">1</span>);<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="如果getItem事物传播级别是-REQUIRED"><a href="#如果getItem事物传播级别是-REQUIRED" class="headerlink" title="如果getItem事物传播级别是 REQUIRED"></a>如果getItem事物传播级别是 REQUIRED</h3><p><code>getItem</code>方法会加入当前事物，共享同一条连接，加入之前会先调用<code>connection.savePoint()</code>保存调用点，<code>getItem</code>里面回滚不会回滚整个事物，而是回滚到<code>savePoint</code>。<code>getItem</code>执行完成<code>commit</code>也不会提交事物，而是清除<code>savePoint</code>。</p><h3 id="如果getItem事物传播级别是MANDATORY"><a href="#如果getItem事物传播级别是MANDATORY" class="headerlink" title="如果getItem事物传播级别是MANDATORY"></a>如果getItem事物传播级别是MANDATORY</h3><p>​同REQUIRED，加入当前事物</p><h3 id="如果getItem事物传播级别是-SUPPORTS"><a href="#如果getItem事物传播级别是-SUPPORTS" class="headerlink" title="如果getItem事物传播级别是 SUPPORTS"></a>如果getItem事物传播级别是 SUPPORTS</h3><p>​同REQUIRED，加入当前事物。</p><h3 id="如果getItem事物传播级别是-REQUIRES-NEW"><a href="#如果getItem事物传播级别是-REQUIRES-NEW" class="headerlink" title="如果getItem事物传播级别是 REQUIRES_NEW"></a>如果getItem事物传播级别是 REQUIRES_NEW</h3><p>​先将当前ThreadLocal里的连接存储起来，如 oldConnection &#x3D; ThreadLocal.get()，再清空ThreadLocal。</p><p>​执行getItem时，因为此时ThreadLocal上已经没有连接了，会新建一个连接。</p><p>​<code>getItem</code>执行完成提交或者回滚后，将刚才存储再临时变量oldConnection的连接重新设置到ThreadLocal。</p><p>​这样将ThreadLocal连接转移到临时变量里，就叫做对该连接<strong>挂起</strong>。</p><h3 id="如果getItem事物传播级别是-NESTED"><a href="#如果getItem事物传播级别是-NESTED" class="headerlink" title="如果getItem事物传播级别是 NESTED"></a>如果getItem事物传播级别是 NESTED</h3><p>​开启嵌套事物。</p><h3 id="如果getItem事物传播级别是-NOT-SUPPORTED"><a href="#如果getItem事物传播级别是-NOT-SUPPORTED" class="headerlink" title="如果getItem事物传播级别是 NOT_SUPPORTED"></a>如果getItem事物传播级别是 NOT_SUPPORTED</h3><p>​从线程池里获取新连接，使用新连接执行。</p><h3 id="如果getItem事物传播级别是-NEVER"><a href="#如果getItem事物传播级别是-NEVER" class="headerlink" title="如果getItem事物传播级别是 NEVER"></a>如果getItem事物传播级别是 NEVER</h3><p>​因为当前已经存在事物，抛出<code>**Existing transaction found for transaction marked with propagation &#39;never&#39;</code>异常。</p><p>如果Controller上没有事物，只是Service上有事物</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br>       <span class="hljs-meta">@Autowired</span><br>       <span class="hljs-keyword">private</span> TestService testService;<br><br>       <span class="hljs-meta">@RequestMapping(&quot;test&quot;)</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>           sqlSession.selectList(<span class="hljs-string">&quot;com.item.dao.selectById&quot;</span>, <span class="hljs-number">1</span>);<br>           testService.getItem();<br>       &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestService</span>&#123;<br>       <br>       <span class="hljs-meta">@Transactional</span><br>       <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">getItem</span><span class="hljs-params">()</span> &#123;<br>           sqlSession.selectList(<span class="hljs-string">&quot;com.item.dao.selectById&quot;</span>, <span class="hljs-number">1</span>);<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="如果getItem事物传播级别是REQUIRES"><a href="#如果getItem事物传播级别是REQUIRES" class="headerlink" title="如果getItem事物传播级别是REQUIRES"></a>如果getItem事物传播级别是REQUIRES</h3><p>​因为当前ThreadLocal不存在连接，会开启新事物连接。</p><h3 id="如果getItem事物传播级别是REQUIRES-NEW"><a href="#如果getItem事物传播级别是REQUIRES-NEW" class="headerlink" title="如果getItem事物传播级别是REQUIRES_NEW"></a>如果getItem事物传播级别是REQUIRES_NEW</h3><p>​会开启新事物连接。</p><h3 id="如果getItem事物传播级别是-NESTED-1"><a href="#如果getItem事物传播级别是-NESTED-1" class="headerlink" title="如果getItem事物传播级别是 NESTED"></a>如果getItem事物传播级别是 NESTED</h3><p>​会开启新事物连接。</p><h3 id="如果getItem事物传播级别是-MANDATORY"><a href="#如果getItem事物传播级别是-MANDATORY" class="headerlink" title="如果getItem事物传播级别是 MANDATORY"></a>如果getItem事物传播级别是 MANDATORY</h3><p>​当前没有事物连接，会抛出<code>No existing transaction found for transaction marked with propagation &#39;mandatory&#39;</code>异常。</p><h3 id="如果getItem事物传播级别是-NOT-SUPPORTED-1"><a href="#如果getItem事物传播级别是-NOT-SUPPORTED-1" class="headerlink" title="如果getItem事物传播级别是 NOT_SUPPORTED"></a>如果getItem事物传播级别是 NOT_SUPPORTED</h3><p>​从连接池里拿到新的连接执行（没有事物管理）。</p><h3 id="如果getItem事物传播级别是-NEVER-1"><a href="#如果getItem事物传播级别是-NEVER-1" class="headerlink" title="如果getItem事物传播级别是 NEVER"></a>如果getItem事物传播级别是 NEVER</h3><p>​从连接池里拿到新的连接执行（没有事物管理）。</p><h3 id="如果getItem事物传播级别是-SUPPORTS-1"><a href="#如果getItem事物传播级别是-SUPPORTS-1" class="headerlink" title="如果getItem事物传播级别是 SUPPORTS"></a>如果getItem事物传播级别是 SUPPORTS</h3><p>​从连接池里拿到新的连接执行（没有事物管理）。</p><hr><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>​核心原理就是Spring事先从连接池获取连接，与线程绑定，代码里要使用DataSourceUtils来获取连接，这样能保证获取的连接就是Spring管理的那一条连接。这样Spring就可以在方法执行完成后执行commit 或者捕获到特定的异常时rollback。</p><p>​</p><p>​对于事物传播属性，就是定义事物方法和事物方法之间，或非事物方法和事物方法之间的调用处理逻辑。</p><p>再重复下上面的那张表</p><table><thead><tr><th>传播属性</th><th>解释</th></tr></thead><tbody><tr><td>REQUIRED</td><td>有就加入，没有就新建，最终会在事物中执行</td></tr><tr><td>REQUIRES_NEW</td><td>有就先挂起旧连接，创建新的连接，最终会在新的事物连接中执行</td></tr><tr><td>MANDATORY</td><td>要求当前必须存在事物，不存在就报错</td></tr><tr><td>NOT_SUPPORTED</td><td>获取一个非事物连接执行，不需要挂起旧的，因为新连接不需要事物管理</td></tr><tr><td>NEVER</td><td>要求当前必须不存在事物，和MANDATORY相反</td></tr><tr><td>SUPPORTS</td><td>存在就加入，不存在就使用非事物执行</td></tr><tr><td>NESTED</td><td>存在就使用嵌套事物，不存在就创建</td></tr></tbody></table><p>​</p><p>​<strong>一些名词解释</strong></p><p><code>加入当前事物</code></p><p>​当前线程ThreadLocal已经存在一个connection，直接拿来用，用之前创建savePoint，如果rollback，只是rollback到savePoint不会全部回滚，commit也不会真的commit，而是清除savePoint。</p><p><code>挂起当前事物</code></p><p>​因为当前ThreadLocal上已经绑定了connection，要想创建新的事物连接，需要将ThreadLocal上的connection先临时存储到其他地方，这就叫做挂起。新连接执行完成后，再将存储的旧连接还原回去。</p><p>​<strong>一些重要的类</strong></p><p>​此方法就是使用ThreadLocal绑定资源的类，注重看下<code>getResource</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.transaction.support.TransactionSynchronizationManager#getResource<br></code></pre></td></tr></table></figure><p>​此方法利用<code>TransactionSynchronizationManager</code>保存一条连接到ThreadLocal上，如果没有就利用连接池获取新连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.jdbc.datasource.DataSourceUtils#getConnection<br></code></pre></td></tr></table></figure><p>​此方法就是事物管理器根据不同传播属性进行不同方式的处理，需要重点看这个方法的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.transaction.support.AbstractPlatformTransactionManager#getTransaction<br></code></pre></td></tr></table></figure><p>​此方法就是获取当前线程绑定的连接，其利用了<code>TransactionSynchronizationManager</code>获取当前线程上绑定的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.jdbc.datasource.DataSourceTransactionManager#doGetTransaction<br></code></pre></td></tr></table></figure><p>​这两个方法就是如果需要挂起当前连接是的操作，它会解绑当前ThreadLocal上的连接</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.transaction</span><span class="hljs-selector-class">.support</span>.AbstractPlatformTransactionManager<span class="hljs-selector-id">#suspend</span><br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.datasource</span>.DataSourceTransactionManager#doSuspend<br></code></pre></td></tr></table></figure><p>​此方法重点看，其实对事物方法进行拦截时的操作，方法执行前通过事物管理器创建事物（其实就是创建连接，绑定到ThreadLocal上），使用try catch捕捉异常，决定是否回滚，最后在commit。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.transaction.interceptor.TransactionAspectSupport#invokeWithinTransaction<br></code></pre></td></tr></table></figure><p>​此方法就是进行事物commit操作的，但并不一定真实提交，如果当前存在savePoint说明是加入到其他连接里的，提交操作就是清除savePoint而已。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.transaction.support.AbstractPlatformTransactionManager#processCommit<br></code></pre></td></tr></table></figure><p>​这是提交或回滚后清理各种资源你的方法，如果<code>SuspendedResources</code>不为空的话，说明现在还有一个事物被挂起呢，将获取<code>SuspendedResources</code>，将其还原回去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.transaction.support.AbstractPlatformTransactionManager#cleanupAfterCompletion<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​以上就是我对Spring事物的看法，逻辑不复杂，但代码分支太多，可以先从整体把握，再逐渐看细节。</p><p>再重复一遍简单的原理：</p><p>​使用Aop对方法调用前，调用后进行拦截，调用前获取连接设置到ThreadLocal上，调用后将ThreadLocal上的连接回滚或提交。</p><p>​遇到需要开启新事物的，将当前事物挂起，处理新事物，新事物提交后，还原当前事物连接。</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>​AbstractPlatformTransactionManager类上有一个setTransactionSynchronization方法。它可以控制，如果方法受事务管理器管理，但是不需要开启事务的场景下，是否共用同一条jdbc链接。</p><p>​即一个方法添加了注解，受事务管理，但不需要开启新事物，方法内的若干个请求是否使用同一条数据库连接。默认是开启的，可通过上面那个方法进行控制。</p><p>​举个例子，如果事务传播级别为NEVER，且外层没有开启事务。这时因为是NEVER级别所以不会开启新的事物，但是方法内执行的多个sql语句是被限制使用同一个sql连接的。</p><p>​同理NOT_SUPPORTED也可以达成这种条件。</p><p>​关注下 SYNCHRONIZATION_ALWAYS，SYNCHRONIZATION_ON_ACTUAL_TRANSACTION，SYNCHRONIZATION_NEVER 三个字段。</p>]]></content>
    
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springGateway常见类分析</title>
    <link href="/4217255769.html"/>
    <url>/4217255769.html</url>
    
    <content type="html"><![CDATA[<h1 id="springGateway常见类分析"><a href="#springGateway常见类分析" class="headerlink" title="springGateway常见类分析"></a>springGateway常见类分析</h1><p>​本文将<code>springGateway</code>的重要类提出来，从宏观角度理解下这个框架。</p><h3 id="1-HttpHandler"><a href="#1-HttpHandler" class="headerlink" title="1.HttpHandler"></a>1.HttpHandler</h3><p>​底层reactor将netty解析好的request封装成request，response交给此类处理。这是最原始的处理请求的接口，最接近底层netty的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HttpHandler</span> &#123;<br>Mono&lt;Void&gt; <span class="hljs-title function_">handle</span><span class="hljs-params">(ServerHttpRequest request, ServerHttpResponse response)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-WebHandler"><a href="#2-WebHandler" class="headerlink" title="2.WebHandler"></a>2.WebHandler</h3><p>​HttpHandler的另一个抽象，参数exchange包装了request + response。此类类比于j2ee里面的servlet。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WebHandler</span> &#123;<br><br>Mono&lt;Void&gt; <span class="hljs-title function_">handle</span><span class="hljs-params">(ServerWebExchange exchange)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-WebFilter"><a href="#3-WebFilter" class="headerlink" title="3.WebFilter"></a>3.WebFilter</h3><p>​配合WebHandler使用，提供拦截器功能，此类类比于j2ee里面的filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WebFilter</span> &#123;<br><br>Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, WebFilterChain chain)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-WebHandlerDecorator"><a href="#4-WebHandlerDecorator" class="headerlink" title="4.WebHandlerDecorator"></a>4.WebHandlerDecorator</h3><p>​WebHandler的代理类，全部委托给代理类执行。仍然实现WebHandler接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebHandlerDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebHandler</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebHandler delegate;<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">WebHandlerDecorator</span><span class="hljs-params">(WebHandler delegate)</span> &#123;<br><span class="hljs-built_in">this</span>.delegate = delegate;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">handle</span><span class="hljs-params">(ServerWebExchange exchange)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.delegate.handle(exchange);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="5-FilteringWebHandler"><a href="#5-FilteringWebHandler" class="headerlink" title="5.FilteringWebHandler"></a>5.FilteringWebHandler</h3><p>​将WebFilter和WebHandler组合在一起，变成一个WebHandler，执行此WebHandler之前会先经过WebFilter链。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilteringWebHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebHandlerDecorator</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DefaultWebFilterChain chain;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FilteringWebHandler</span><span class="hljs-params">(WebHandler handler, List&lt;WebFilter&gt; filters)</span> &#123;<br><span class="hljs-built_in">super</span>(handler);<br><span class="hljs-built_in">this</span>.chain = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultWebFilterChain</span>(handler, filters);<br>&#125;<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">handle</span><span class="hljs-params">(ServerWebExchange exchange)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.chain.filter(exchange);<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-WebExceptionHandler"><a href="#6-WebExceptionHandler" class="headerlink" title="6.WebExceptionHandler"></a>6.WebExceptionHandler</h3><p>​异常处理，可以配置多个异常处理，如果已经处理完成则返回Mono<VOid>，否则返回Mono<Exception>，这样轮到下一个WebExceptionHandler处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WebExceptionHandler</span> &#123;<br><br>Mono&lt;Void&gt; <span class="hljs-title function_">handle</span><span class="hljs-params">(ServerWebExchange exchange, Throwable ex)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-ExceptionHandlingWebHandler"><a href="#7-ExceptionHandlingWebHandler" class="headerlink" title="7.ExceptionHandlingWebHandler"></a>7.ExceptionHandlingWebHandler</h3><p>​仍然是WebHandler的代理类，使用try catch包住执行逻辑，抛异常时使用exceptionHandlers处理异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionHandlingWebHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebHandlerDecorator</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;WebExceptionHandler&gt; exceptionHandlers;<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">handle</span><span class="hljs-params">(ServerWebExchange exchange)</span> &#123;<br>Mono&lt;Void&gt; completion;<br><span class="hljs-keyword">try</span> &#123;<br>completion = <span class="hljs-built_in">super</span>.handle(exchange);<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>completion = Mono.error(ex);<br>&#125;<br><br><span class="hljs-keyword">for</span> (WebExceptionHandler handler : <span class="hljs-built_in">this</span>.exceptionHandlers) &#123;<br>completion = completion.onErrorResume(ex -&gt; handler.handle(exchange, ex));<br>&#125;<br><span class="hljs-keyword">return</span> completion;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="8-HttpWebHandlerAdapter"><a href="#8-HttpWebHandlerAdapter" class="headerlink" title="8.HttpWebHandlerAdapter"></a>8.HttpWebHandlerAdapter</h3><p>​同时实现了WebHandler 和 HttpHandler接口，提供适配转换功能，将WebHandler适配成HttpHandler供底层调用，因为netty底层需要的是HttpHandler实现类，我们框架是以WebHandler作为基础开发的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpWebHandlerAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebHandlerDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HttpHandler</span> &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">handle</span><span class="hljs-params">(ServerHttpRequest request, ServerHttpResponse response)</span> &#123;<br><span class="hljs-type">ServerWebExchange</span> <span class="hljs-variable">exchange</span> <span class="hljs-operator">=</span> createExchange(request, response);<br><span class="hljs-keyword">return</span> getDelegate().handle(exchange)<br>.doOnSuccess(aVoid -&gt; logResponse(exchange))<br>.onErrorResume(ex -&gt; handleUnresolvedError(exchange, ex))<br>.then(Mono.defer(response::setComplete));<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-DispatcherHandler"><a href="#9-DispatcherHandler" class="headerlink" title="9.DispatcherHandler"></a>9.DispatcherHandler</h3><p>​实现了WebHandler接口，类似于springMvc的DispatcherServlet一样，先是通过handlerMapping查找mapping，在通过handlerAdapter执行mapping，再通过<code>HandlerResultHandler</code>处理返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DispatcherHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebHandler</span>, ApplicationContextAware &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">handle</span><span class="hljs-params">(ServerWebExchange exchange)</span> &#123;<br><span class="hljs-keyword">return</span> Flux.fromIterable(<span class="hljs-built_in">this</span>.handlerMappings)<br>.concatMap(mapping -&gt; mapping.getHandler(exchange))<br>.next()<br>.switchIfEmpty(createNotFoundError())<br>.flatMap(handler -&gt; invokeHandler(exchange, handler))<br>.flatMap(result -&gt; handleResult(exchange, result));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-GlobalFilter"><a href="#10-GlobalFilter" class="headerlink" title="10.GlobalFilter"></a>10.GlobalFilter</h3><p>​这是gateway独有的filter，签名和WebFilter一样，内置十个GloblFilter用来做路由功能。</p><p>一般不需要创建GlobalFilter。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GlobalFilter</span> &#123;<br><br>Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-GatewayFilter"><a href="#11-GatewayFilter" class="headerlink" title="11.GatewayFilter"></a>11.GatewayFilter</h3><p>​也是gateway独有的，签名和GlobalFilter一样，为了区分是系统默认的还是用户自定义了，我们写gateway的filter通常实现此接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GatewayFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ShortcutConfigurable</span> &#123;<br><br>Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-Route"><a href="#10-Route" class="headerlink" title="10.Route"></a>10.Route</h3><p>​gateway独有的类，系类相当于数据类，只是用来将路由相关的类，整理在一起。</p><ul><li><p>uri 标识目标地址</p></li><li><p>predicate 判断请求是否符合此route</p></li><li><p>gatewayFilters 存储的filter。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Route</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Ordered</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> URI uri;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> order;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AsyncPredicate&lt;ServerWebExchange&gt; predicate;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;GatewayFilter&gt; gatewayFilters;<br><br></code></pre></td></tr></table></figure><h3 id="11-RouteLocator"><a href="#11-RouteLocator" class="headerlink" title="11. RouteLocator"></a>11. RouteLocator</h3><p>​gateway独有的类，使用Flux封装多个Route，提供Route的存储功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RouteLocator</span> &#123;<br><br>Flux&lt;Route&gt; <span class="hljs-title function_">getRoutes</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-FilteringWebHandler"><a href="#12-FilteringWebHandler" class="headerlink" title="12.FilteringWebHandler"></a>12.FilteringWebHandler</h3><p>​gateway独有的类，和上面webFlux也有这个类，只是重名了而已。</p><p>此类实现了WebHandler接口，但实际执行逻辑是多个GatewayFIlter组成的FIlter链。</p><p>​构造方法里传入globalFilters，handler方法里，从route上获取GatewayFilter，将用户Filter和全局FIlter合并成FilterChain，再执行。</p><p>​此类可以看成在tomcat环境下，只有filter链，没有servlet。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilteringWebHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebHandler</span> &#123;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Log</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LogFactory.getLog(FilteringWebHandler.class);<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;GatewayFilter&gt; globalFilters;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FilteringWebHandler</span><span class="hljs-params">(List&lt;GlobalFilter&gt; globalFilters)</span> &#123;<br><span class="hljs-built_in">this</span>.globalFilters = loadFilters(globalFilters);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">handle</span><span class="hljs-params">(ServerWebExchange exchange)</span> &#123;<br><span class="hljs-type">Route</span> <span class="hljs-variable">route</span> <span class="hljs-operator">=</span> exchange.getRequiredAttribute(GATEWAY_ROUTE_ATTR);<br>List&lt;GatewayFilter&gt; gatewayFilters = route.getFilters();<br><br>List&lt;GatewayFilter&gt; combined = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">this</span>.globalFilters);<br>combined.addAll(gatewayFilters);<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> needed or cached?</span><br>AnnotationAwareOrderComparator.sort(combined);<br><br><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>logger.debug(<span class="hljs-string">&quot;Sorted gatewayFilterFactories: &quot;</span> + combined);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultGatewayFilterChain</span>(combined).filter(exchange);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-RoutePredicateHandlerMapping"><a href="#13-RoutePredicateHandlerMapping" class="headerlink" title="13.RoutePredicateHandlerMapping"></a>13.RoutePredicateHandlerMapping</h3><p>​gateway独有的，实现了HandlerMapping接口，查找handler时，将查找RouteLocator里面的匹配的Route，将route存入exchange里面，用于构造FilteringWebHandler。</p><h3 id="14-逻辑图"><a href="#14-逻辑图" class="headerlink" title="14.逻辑图"></a>14.逻辑图</h3><p><img src="/img/in/2020-09-04-springGateway%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%88%86%E6%9E%90/springGateway.svg" alt="springGateway"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​以上就是gateway使用到的主要类，因为gateway是基于springWebFlux实现的，所以流程还是webFlux的流程，gateway对其进行扩充，使用十个globleFilter实现了网关功能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>springGateway</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springBootActuator的使用</title>
    <link href="/344497220.html"/>
    <url>/344497220.html</url>
    
    <content type="html"><![CDATA[<ul><li>TOC<br>{:toc}</li></ul><h1 id="springBootActuator的使用"><a href="#springBootActuator的使用" class="headerlink" title="springBootActuator的使用"></a>springBootActuator的使用</h1><h2 id="启用actuator功能"><a href="#启用actuator功能" class="headerlink" title="启用actuator功能"></a>启用actuator功能</h2><p>​这个是<code>Springboot</code>提供的分析软件，他能提供一些指数供我们参考，因为他已经内置在<code>Springboot</code>里面了，要使用它非常简单，我们只需添加如下依赖在项目下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​他能提供<code>jmx</code>或者<code>web</code>两种方式的数据暴露方式，我们启用基于<code>web</code>的数据暴露方式。</p><p>添加依赖后在配置文件里配置如下</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#默认开启</span><br><span class="hljs-attr">management.endpoints.enabled-by-default</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#以web方式暴露所有端点（include * 表示包含全部）</span><br><span class="hljs-attr">management.endpoints.web.exposure.include</span>=<span class="hljs-string">*</span><br><span class="hljs-comment">#关闭jmx的所有端点（exclude * 表示排除全部）</span><br><span class="hljs-attr">management.endpoints.jmx.exposure.exclude</span>=<span class="hljs-string">*</span><br><span class="hljs-comment">#health接口包含细节信息</span><br><span class="hljs-attr">management.endpoint.health.show-details</span>=<span class="hljs-string">always</span><br></code></pre></td></tr></table></figure><p>​这样运行项目后，我们访问<code>http://127.0.0.1:8080/actuator</code>就能看到一个<code>json</code>，里面包含所有暴露出来的端点地址信息，但是只看<code>json</code>是不利于观察的，下面我们讲解如何配置可视化界面。</p><h2 id="配置可视化界面"><a href="#配置可视化界面" class="headerlink" title="配置可视化界面"></a>配置可视化界面</h2><p>​上面我们已经启用了<code>actuator</code>功能，但是数据不利于观察，于是有人做出了这样的<code>gui</code>项目，只需要将地址配置给<code>gui</code>项目，<code>gui</code>项目帮我们请求地址，将<code>json</code>数据以可视化的方式展示出来。</p><p>​</p><p>​在上面的项目上添加如下依赖，这是<code>spring-boot-admin</code>项目的客户端。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​ 配置文件里配置服务端的地址，假设服务端启动在8888端口</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.boot.admin.client.instance.service-url</span>=<span class="hljs-string">http://127.0.0.1:8888</span><br></code></pre></td></tr></table></figure><p>​</p><p><strong>新建一个项目作为服务端</strong>，添加如下依赖，这是<code>spring-boot-admin</code>项目的服务端。启动类上添加<code>@EnableAdminServer</code>注解，在8888端口启动。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​假设服务端启动在8888端口的，在客户端里面配置服务端的地址，这样客户端启动时，会连接服务端，将当前项目的<code>actuator</code>地址告诉服务端，打开<code>http://127.0.0.1:8888</code>就能展示可视化的客户端信息了。</p><p>​原理是这样的，拥有客户端的项目在启动时，将客户端的地址发送到服务端。服务端提供静态页面，页面上通过js访问服务端，服务端再请求项目，服务端在页面和客户端之间做转发操作。</p><h2 id="实现原理源码分析"><a href="#实现原理源码分析" class="headerlink" title="实现原理源码分析"></a>实现原理源码分析</h2><p>​配置了简单的<code>demo</code>，并简述了他的原理，下面我们深入到代码里面查看他的源码。</p><h3 id="客户端原理"><a href="#客户端原理" class="headerlink" title="客户端原理"></a>客户端原理</h3><p>​找到客户端<code>SpringBootAdminClientAutoConfiguration</code>类，此类在<code>spring.factorise</code>里配置了，启动时会自动执行。我么分析他的源码即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> RegistrationApplicationListener <span class="hljs-title function_">registrationListener</span><span class="hljs-params">(ClientProperties client,</span><br><span class="hljs-params">                                                            ApplicationRegistrator registrator)</span> &#123;<br>    <span class="hljs-type">RegistrationApplicationListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegistrationApplicationListener</span>(registrator);<br>    listener.setAutoRegister(client.isAutoRegistration());<br>    listener.setAutoDeregister(client.isAutoDeregistration());<br>    listener.setRegisterPeriod(client.getPeriod());<br>    <span class="hljs-keyword">return</span> listener;<br>&#125;<br></code></pre></td></tr></table></figure><p>​查看此类，其中有方法上标记了<code>@EventListener</code>注解，他在监听到容器启动完成后向服务端注册自己，下面代码里开启的注册的定时任务，10秒钟心跳注册一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EventListener</span><br><span class="hljs-meta">@Order(Ordered.LOWEST_PRECEDENCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationReady</span><span class="hljs-params">(ApplicationReadyEvent event)</span> &#123;<br>    <span class="hljs-keyword">if</span> (autoRegister) &#123;<br>        startRegisterTask();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p><p>​注册逻辑是写在此方法里的，其中有一个<code>register</code>方法，负责向服务端发送信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> ApplicationRegistrator <span class="hljs-title function_">registrator</span><span class="hljs-params">(ClientProperties client, ApplicationFactory applicationFactory)</span> &#123;<br>    <span class="hljs-type">RestTemplateBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplateBuilder</span>().setConnectTimeout(client.getConnectTimeout())<br>                                                           .setReadTimeout(client.getReadTimeout());<br>    <span class="hljs-keyword">if</span> (client.getUsername() != <span class="hljs-literal">null</span>) &#123;<br>        builder = builder.basicAuthentication(client.getUsername(), client.getPassword());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationRegistrator</span>(builder.build(), client, applicationFactory);<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p><p>​这是在<code>servlet</code>环境下的处理逻辑，可看淡它使用<code>RestTemplate</code>向服务端发送客户端的信息，如果是<code>webflux</code>环境下，会使用<code>webclient</code>发送信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">register</span><span class="hljs-params">(Application self, String adminUrl, <span class="hljs-type">boolean</span> firstAttempt)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ResponseEntity&lt;Map&lt;String, Object&gt;&gt; response = template.exchange(adminUrl, HttpMethod.POST,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpEntity</span>&lt;&gt;(self, HTTP_HEADERS), RESPONSE_TYPE);<br><br>            <span class="hljs-keyword">if</span> (response.getStatusCode().is2xxSuccessful()) &#123;<br>                <span class="hljs-keyword">if</span> (registeredId.compareAndSet(<span class="hljs-literal">null</span>, response.getBody().get(<span class="hljs-string">&quot;id&quot;</span>).toString())) &#123;<br>                    LOGGER.info(<span class="hljs-string">&quot;Application registered itself as &#123;&#125;&quot;</span>, response.getBody().get(<span class="hljs-string">&quot;id&quot;</span>).toString());<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    LOGGER.debug(<span class="hljs-string">&quot;Application refreshed itself as &#123;&#125;&quot;</span>, response.getBody().get(<span class="hljs-string">&quot;id&quot;</span>).toString());<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (firstAttempt) &#123;<br>                    LOGGER.warn(<br>                        <span class="hljs-string">&quot;Application failed to registered itself as &#123;&#125;. Response: &#123;&#125;. Further attempts are logged on DEBUG level&quot;</span>,<br>                        self, response.toString());<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    LOGGER.debug(<span class="hljs-string">&quot;Application failed to registered itself as &#123;&#125;. Response: &#123;&#125;&quot;</span>, self,<br>                        response.toString());<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            <span class="hljs-keyword">if</span> (firstAttempt) &#123;<br>                LOGGER.warn(<br>                    <span class="hljs-string">&quot;Failed to register application as &#123;&#125; at spring-boot-admin (&#123;&#125;): &#123;&#125;. Further attempts are logged on DEBUG level&quot;</span>,<br>                    self, client.getAdminUrl(), ex.getMessage());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                LOGGER.debug(<span class="hljs-string">&quot;Failed to register application as &#123;&#125; at spring-boot-admin (&#123;&#125;): &#123;&#125;&quot;</span>, self,<br>                    client.getAdminUrl(), ex.getMessage());<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>​那么到底向服务端发送的是什么内容呢？，查看restTemplate发送请求的代码，他发送了<code>Application</code>序列化的结果。下面是一个<code>ApplicationFactory</code>，他的<code>createApplication</code>会创建一个<code>Application</code>的实例，该实例将包含服务端需要的信息。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletConfiguration</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-keyword">public</span> ApplicationFactory <span class="hljs-title function_">applicationFactory</span><span class="hljs-params">(InstanceProperties instance,</span><br><span class="hljs-params">                                                 ManagementServerProperties management,</span><br><span class="hljs-params">                                                 ServerProperties server,</span><br><span class="hljs-params">                                                 ServletContext servletContext,</span><br><span class="hljs-params">                                                 PathMappedEndpoints pathMappedEndpoints,</span><br><span class="hljs-params">                                                 WebEndpointProperties webEndpoint,</span><br><span class="hljs-params">                                                 MetadataContributor metadataContributor,</span><br><span class="hljs-params">                                                 DispatcherServletPath dispatcherServletPath)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletApplicationFactory</span>(instance,<br>            management,<br>            server,<br>            servletContext,<br>            pathMappedEndpoints,<br>            webEndpoint,<br>            metadataContributor,<br>            dispatcherServletPath<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p><p>​这就是Application内含有的字段。这些字段如果不自己配置，都可以从程序里自动获取到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String managementUrl;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String healthUrl;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String serviceUrl;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; metadata;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​这就是客户端逻辑，他先是使用监听器监听程序启动，再收集<code>Application</code>类字段上的那些信息，根据容器的不同选择<code>resttemplate</code> 或者 <code>webclient</code>，使用<code>Schedult</code>线程池，每10秒向服务器发送本程序的信息。</p><p>​我们只需要配置服务端的地址，剩下的数据都能自动收集到。并且客户端的代码很少，就十几个类。功能也比较简单。</p><h3 id="服务端原理"><a href="#服务端原理" class="headerlink" title="服务端原理"></a>服务端原理</h3><p>​引入下面依赖后，共有三个依赖项目被引入。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>分别是</p><ul><li><p>spring-boot-admin-server-ui</p></li><li><p>spring-boot-admin-server-cloud</p></li><li><p>spring-boot-admin-server</p></li></ul><h4 id="spring-boot-admin-server-ui"><a href="#spring-boot-admin-server-ui" class="headerlink" title="spring-boot-admin-server-ui"></a>spring-boot-admin-server-ui</h4><p>​首先查看<code>spring-boot-admin-server-ui</code>项目，他在项目的<code>META-INF</code>文件夹下放置了页面的静态文件，并在代码里配置了<code>UiController</code>来返回这些静态页面。页面路径相关的配置由<code>AdminServerUiProperties</code>类配置，比较简单。</p><h4 id="spring-boot-admin-server-cloud"><a href="#spring-boot-admin-server-cloud" class="headerlink" title="spring-boot-admin-server-cloud"></a>spring-boot-admin-server-cloud</h4><p>​发现他配置了<code>InstanceDiscoveryListener</code>类，这里面对服务发现的事件进行监听，比如监听到<code>InstanceRegisteredEvent</code>事件时，调用<code>discoveryClient</code>读取注册中心，这些事件和注册中心都是在<code>spring-cloud-commons</code>包里定义的。如果使用注册中心，<code>admin-server</code>就能从注册中心拉取客户端信息，即使客户端不添加<code>admin-starter-client</code>也是可以的，这个稍后讲。</p><p>​下面这个方法就是就是发现逻辑，使用<code>discoveryClient</code>发现服务，进行转换后存储在<code>InstanceRegistry</code>里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">discover</span><span class="hljs-params">()</span> &#123;<br>    log.debug(<span class="hljs-string">&quot;Discovering new instances from DiscoveryClient&quot;</span>);<br>    Flux.fromIterable(discoveryClient.getServices())<br>        .filter(<span class="hljs-built_in">this</span>::shouldRegisterService)<br>        .flatMapIterable(discoveryClient::getInstances)<br>        .flatMap(<span class="hljs-built_in">this</span>::registerInstance)<br>        .collect(Collectors.toSet())<br>        .flatMap(<span class="hljs-built_in">this</span>::removeStaleInstances)<br>        .subscribe(v -&gt; &#123; &#125;, ex -&gt; log.error(<span class="hljs-string">&quot;Unexpected error.&quot;</span>, ex));<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p><h4 id="spring-boot-admin-server"><a href="#spring-boot-admin-server" class="headerlink" title="spring-boot-admin-server"></a>spring-boot-admin-server</h4><p>首先spring.factories文件里面引入了 <code>AdminServerAutoConfiguration</code>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ImportAutoConfiguration(&#123; AdminServerInstanceWebClientConfiguration.class, AdminServerWebConfiguration.class &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminServerAutoConfiguration</span> &#123;<br>    .<br>    .<br>    .<br>&#125;        <br>    <br></code></pre></td></tr></table></figure><p>同时这个类又引入了<code>AdminServerInstanceWebClientConfiguration.class</code>，<code>AdminServerWebConfiguration.class</code>两个类。</p><h5 id="AdminServerInstanceWebClientConfiguration配置类"><a href="#AdminServerInstanceWebClientConfiguration配置类" class="headerlink" title="AdminServerInstanceWebClientConfiguration配置类"></a>AdminServerInstanceWebClientConfiguration配置类</h5><p>这个类里面主要定义和配置了<code>InstanceWebClient.Builder</code>，这是一个包装了WebClient的客户端，使用它来获取客户端信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@Lazy(false)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminServerInstanceWebClientConfiguration</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InstanceWebClient.Builder instanceWebClientBuilder;<br><br><span class="hljs-comment">//构造方法里，传入了WebClient和InstanceWebClientCustomizer，webclient.build就是springboot自动配置的 </span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">AdminServerInstanceWebClientConfiguration</span><span class="hljs-params">(ObjectProvider&lt;InstanceWebClientCustomizer&gt; customizers,</span><br><span class="hljs-params">WebClient.Builder webClient)</span> &#123;<br><span class="hljs-built_in">this</span>.instanceWebClientBuilder = InstanceWebClient.builder(webClient);<br>customizers.orderedStream().forEach((customizer) -&gt; customizer.customize(<span class="hljs-built_in">this</span>.instanceWebClientBuilder));<br>&#125;<br><br><span class="hljs-comment">//这里在返回InstanceWebClient时进行了clone操作，同时也会可用一份WebClient，所以对此webclient的改动不会反应到全局webclient上    </span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br><span class="hljs-keyword">public</span> InstanceWebClient.Builder <span class="hljs-title function_">instanceWebClientBuilder</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.instanceWebClientBuilder.clone();<br>&#125;<br></code></pre></td></tr></table></figure><p>​此配置类执行完成后，我们就拥有了一个封装好的<code>Webclient</code>供我们使用，并且对此类的所有配置都不会影响全局<code>Webclient</code>配置。</p><p>​下面这个类可以为请求添加Basic验证的请求头，如果客户端需要Basic验证，并且配置了密码，就能验证访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpHeadersProviderConfiguration</span> &#123;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> BasicAuthHttpHeaderProvider <span class="hljs-title function_">basicAuthHttpHeadersProvider</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicAuthHttpHeaderProvider</span>();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="AdminServerWebConfiguration"><a href="#AdminServerWebConfiguration" class="headerlink" title="AdminServerWebConfiguration"></a>AdminServerWebConfiguration</h5><p>此类配置了一些<code>Controller</code>。如下面这个方法用来接收客户端的注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(path = &quot;/instances&quot;, consumes = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&lt;Map&lt;String, InstanceId&gt;&gt;&gt; <span class="hljs-title function_">register</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Registration registration,</span><br><span class="hljs-params">UriComponentsBuilder builder)</span> &#123;<br><span class="hljs-type">Registration</span> <span class="hljs-variable">withSource</span> <span class="hljs-operator">=</span> Registration.copyOf(registration).source(<span class="hljs-string">&quot;http-api&quot;</span>).build();<br>LOGGER.debug(<span class="hljs-string">&quot;Register instance &#123;&#125;&quot;</span>, withSource);<br><span class="hljs-keyword">return</span> registry.register(withSource).map((id) -&gt; &#123;<br><span class="hljs-type">URI</span> <span class="hljs-variable">location</span> <span class="hljs-operator">=</span> builder.replacePath(<span class="hljs-string">&quot;/instances/&#123;id&#125;&quot;</span>).buildAndExpand(id).toUri();<br><span class="hljs-keyword">return</span> ResponseEntity.created(location).body(Collections.singletonMap(<span class="hljs-string">&quot;id&quot;</span>, id));<br>&#125;);<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="AdminServerAutoConfiguration"><a href="#AdminServerAutoConfiguration" class="headerlink" title="AdminServerAutoConfiguration"></a>AdminServerAutoConfiguration</h5><p>​上面通过<code>controller</code>可以接受用户注册，通过<code>Discover</code>能从注册中心发现服务，那么将这些信息存储在哪里呢？</p><p>由此类里定义的三个组件完成的，分别是</p><ul><li><code>InstanceRegistry</code> 客户端实例的注册器，处理注册操作</li><li><code>InstanceIdGenerator</code> 客户端id生成</li><li><code>SnapshottingInstanceRepository</code> 上面的注册器实际上将信息存储在这个类里面，相当于是注册器的数据库，默认存储在内存里。</li></ul><h4 id="服务发现和密码保护"><a href="#服务发现和密码保护" class="headerlink" title="服务发现和密码保护"></a>服务发现和密码保护</h4><p>​客户端<code>Actuator</code>相关接口一般是要加密的，如果采用HttpBasic方式加密，可以将密码配置到服务端，或者配置到注册中心的元数据里面，默认<code>admin-server</code>会从元数据里面获取如下的帐号密码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] USERNAME_KEYS = &#123; <span class="hljs-string">&quot;user.name&quot;</span>, <span class="hljs-string">&quot;user-name&quot;</span>, <span class="hljs-string">&quot;username&quot;</span> &#125;;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] PASSWORD_KEYS = &#123; <span class="hljs-string">&quot;user.password&quot;</span>, <span class="hljs-string">&quot;user-password&quot;</span>, <span class="hljs-string">&quot;userpassword&quot;</span> &#125;;<br><br></code></pre></td></tr></table></figure><p>​eureka注册中心将数据存储到元数据里面的方法是下面这样，这样服务端就不用配置客户端的密码了，能直接从注册中心里获取到。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">eureka.instance.metadata-map.user-name</span>=<span class="hljs-string">abc</span><br><span class="hljs-attr">eureka.instance.metadata-map.user-password</span>=<span class="hljs-string">abc</span><br></code></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>​以上就是<code>admin-server</code>端的源码分析，他能使用服务发现，或者接口的方式得到客户端的信息，并存储起来，如果管理网页被打开，就会进行请求转发，转发到对应客户端的地址上。如果不存在注册中心，他就自己维持心跳，维持状态，否则它可以直接从注册中心内获取这些信息。关于密码保护，如果使用注册中心的话，可以将密码存储到元数据里，他尝试从元数据里按照上面三个名字获取账号密码。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>​以上就是<code>Actuator</code>可视化的过程，强烈推荐将<code>admin-server</code>单独部署为一个项目，将所有项目部署到一个注册中心里，这样其他项目不使用<code>admin-client</code>也是可以的</p>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>springbootActuator</tag>
      
      <tag>springbootadmin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springSecurity配置jwt</title>
    <link href="/521069115.html"/>
    <url>/521069115.html</url>
    
    <content type="html"><![CDATA[<h1 id="springSecurity配置jwt"><a href="#springSecurity配置jwt" class="headerlink" title="springSecurity配置jwt"></a>springSecurity配置jwt</h1><p>​在分布式项目下，同一个项目后端可能部署多次，通过负载均衡分配到每个实例上，传统的Session是每个实例独有的，在一个实例上登陆后，其他实例并不知道登录状态。要想解决此问题，有以下几种办法，下面进行分析。</p><h2 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h2><p>​首先前端能存储数据的方式有两种，一种是前端通过<code>localstorage</code>主动存储数据，在发送请求时主动携带。另一种是后端将数据放入<code>Cookie</code>中，前端发起请求时浏览器自动携带。</p><p>对于后端来说，这两种方式并没有本质上的区别。</p><h2 id="后端部分"><a href="#后端部分" class="headerlink" title="后端部分"></a>后端部分</h2><p>​后端能存储数据的方式有以下几种</p><ol><li><p>存储在共享介质中，如<code>mysql</code>，<code>redis</code>，分布式缓存，但本质上是一样的。项目仍然是有状态的，但是状态共享。</p></li><li><p>存储在项目本身的缓存或<code>session</code>里。因为存储在自身的项目下，其他项目无法获取到数据。</p></li><li><p>以<code>Cookie</code>的形式或者接口返回值的形式传给前端，前端请求时每次都带回来，这样其他项目就能拿到共享数据。</p></li></ol><p>​方案1 本质上的有状态的，只是状态是共享的。需要使用用户唯一标识来获取用户存储的数据，此标识可以存储在<code>Cookie</code>里也可以存储在<code>localStorage</code>由前台主动发送，这是对原始<code>cookie session</code>功能的改进，只是将<code>session</code>由单机变成分布式而已。</p><p>​方案2 无法解决负载均衡下的多实例问题。</p><p>​方案3 将信息下发送到前端，每个实例处理请求是拿到前端的信息，就能得到数据，不需要第三方存储，但是需要一种方案验证信息的有效性，且不宜过大。</p><h2 id="jwt以及变种"><a href="#jwt以及变种" class="headerlink" title="jwt以及变种"></a>jwt以及变种</h2><p>​<code>jwt</code>就属于方案三，在登陆时将用户信息存储到前台，下次访问时在重新解析出信息就能判断用户是谁，权限是什么，是否登录。</p><p>​标准的<code>jwt</code>规范是使用<code>json</code>存储数据。除了使用<code>json</code>外，也可以使用其他变种格式，比如用逗号分隔，都是可以的。</p><p>​<code>SpringSecurity</code>里自带了<code>RememberMeService</code>，这个原始用法是为了实现记住我功能，用户<code>session</code>关闭后下次访问能自动登录。如果用户压根没有<code>session</code>，那么每次登录都是自动登录，以此来验证用户身份也是可以的。</p><p>​标准的<code>TokenBasedRememberMeServices</code>会将『用户名，过期时间，密码，盐』加一起进行md5，自动登录时进行同样的运算，如果获取的签名一致则允许自动登录，但是查询密码时仍然需要查询数据库，我们可以简化这一步，使他恒返回一个唯一的密码，因为有盐的存在，签名仍然是安全的，只不过用户改密码后<code>jwt</code>不会失效，不过<code>jwt</code>就是如此。</p><p>​我们将生成的值放入cookie里，这样就不需要前台配合，仅后端就能实现。</p><h2 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h2><p>​将<code>SpringSecurity</code>改为<code>STATELESS</code>模式，这样他就不会使用<code>session</code>了,</p><p>然后配置<code>RememberMeService</code>，我们继承<code>TokenBasedRememberMeServices</code>，重写其中的<code>retrievePassword</code>方法，并且设置一个<code>userDetailService</code>，传入构造方法里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span>&#123;<br><span class="hljs-comment">//配置为无状态模式,不使用session</span><br>http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);   <span class="hljs-comment">//配置form表单登录，以及登录后的执行逻辑</span><br>http.formLogin().loginPage(<span class="hljs-string">&quot;/error&quot;</span>).loginProcessingUrl(<span class="hljs-string">&quot;/login&quot;</span>).permitAll()<br>.successHandler((request, response, authentication) -&gt; &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;s\&quot;:1,\&quot;r\&quot;:\&quot;login success\&quot;&#125;&quot;</span>;<br>sendOut(str, response);<br>&#125;)<br>.failureHandler((request, response, exception) -&gt; &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;s\&quot;:0,\&quot;r\&quot;:\&quot;&quot;</span> + exception.getMessage() + <span class="hljs-string">&quot;\&quot;&#125;&quot;</span>;<br>sendOut(str, response);<br>&#125;);<br>        <br><span class="hljs-comment">//使用RememberMe功能实现jwt登录</span><br><span class="hljs-type">TokenBasedRememberMeServices</span> <span class="hljs-variable">rememberMeServices</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JwtRemember</span>(<span class="hljs-string">&quot;tokenxxx&quot;</span>);<br>rememberMeServices.setAlwaysRemember(<span class="hljs-literal">true</span>);<br>rememberMeServices.setCookieName(<span class="hljs-string">&quot;jwt.token&quot;</span>);<br>http.rememberMe().rememberMeServices(rememberMeServices).key(<span class="hljs-string">&quot;tokenxxx&quot;</span>);<br><br><span class="hljs-comment">//所有端口都需要验证</span><br>http.authorizeRequests().anyRequest().authenticated();<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtRemember</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TokenBasedRememberMeServices</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">salt</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;_randow_salt&quot;</span>;<br>        <br><span class="hljs-comment">//传入userDetailService，返回的新用户的密码是 用户名 + salt</span><br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">JwtRemember</span><span class="hljs-params">(String key)</span> &#123;<br><span class="hljs-built_in">super</span>(key, username -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(username, username + salt, Collections.emptyList()));<br>&#125;<br>        <br><span class="hljs-comment">//重写解析密码的方法，密码固定返回 用户名 + salt</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> String <span class="hljs-title function_">retrievePassword</span><span class="hljs-params">(Authentication authentication)</span> &#123;<br><span class="hljs-keyword">return</span> retrieveUserName(authentication) + salt;<br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">//配置全局userDetailsService 和 passwordEncoder</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-type">UserDetailsService</span> <span class="hljs-variable">userDetailsService</span> <span class="hljs-operator">=</span> username -&gt; &#123;<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getUserByUserName(username);<br><span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernameNotFoundException</span>(username);<br>&#125;<br>        <span class="hljs-keyword">return</span> user;<br>&#125;;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-type">PasswordEncoder</span> <span class="hljs-variable">passwordEncoder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PasswordEncoder</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">encode</span><span class="hljs-params">(CharSequence rawPassword)</span> &#123;<br><span class="hljs-keyword">return</span> UserService.securityPassword(rawPassword.toString());<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(CharSequence rawPassword, String encodedPassword)</span> &#123;<br><span class="hljs-keyword">return</span> encode(rawPassword).equals(encodedPassword);<br>&#125;<br>&#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​初次登录时，会通过下面的<code>UserDetailsService</code> 和 <code>PasswordEncoder</code> 查询数据库，验证用户身份，登陆完成后<code>RememberMeService</code>会自动创建Cookie，Cookie的内容就是上面写的 。</p><p>​第二次访问时，请求经过<code>RememberMeAuthenticationFilter</code>时，它检测到当前未登录，从Cookie中获取数据，自动登录。<br>这里是不查询数据库的。</p><p>下面是此<code>RememberService</code>进行生成<code>Token</code>的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">makeTokenSignature</span><span class="hljs-params">(<span class="hljs-type">long</span> tokenExpiryTime, String username, String password)</span> &#123;<br>    <span class="hljs-comment">//用户名，过期时间，密码（此密码已被我们改为用户名+salt了）+ key</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> username + <span class="hljs-string">&quot;:&quot;</span> + tokenExpiryTime + <span class="hljs-string">&quot;:&quot;</span> + password + <span class="hljs-string">&quot;:&quot;</span> + getKey();<br>    MessageDigest digest;<br>    <span class="hljs-keyword">try</span> &#123;<br>        digest = MessageDigest.getInstance(<span class="hljs-string">&quot;MD5&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (NoSuchAlgorithmException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No MD5 algorithm available!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(Hex.encode(digest.digest(data.getBytes())));<br>&#125;<br><br></code></pre></td></tr></table></figure><p>以下是自动登录的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> UserDetails <span class="hljs-title function_">processAutoLoginCookie</span><span class="hljs-params">(String[] cookieTokens,</span><br><span class="hljs-params">HttpServletRequest request, HttpServletResponse response)</span> &#123;<br><br>       <span class="hljs-comment">//验证过期时间</span><br><span class="hljs-type">long</span> tokenExpiryTime;<br><span class="hljs-keyword">try</span> &#123;<br>tokenExpiryTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(cookieTokens[<span class="hljs-number">1</span>]).longValue();<br>&#125;<br><span class="hljs-keyword">catch</span> (NumberFormatException nfe) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidCookieException</span>(<br><span class="hljs-string">&quot;Cookie token[1] did not contain a valid number (contained &#x27;&quot;</span><br>+ cookieTokens[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;&#x27;)&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (isTokenExpired(tokenExpiryTime)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidCookieException</span>(<span class="hljs-string">&quot;Cookie token[1] has expired (expired on &#x27;&quot;</span><br>+ <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(tokenExpiryTime) + <span class="hljs-string">&quot;&#x27;; current time is &#x27;&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>+ <span class="hljs-string">&quot;&#x27;)&quot;</span>);<br>&#125;<br>       <br>       <span class="hljs-comment">//通过用户名查找用户，这里使用的是构造方法里传入的userDetailSevice</span><br><span class="hljs-type">UserDetails</span> <span class="hljs-variable">userDetails</span> <span class="hljs-operator">=</span> getUserDetailsService().loadUserByUsername(<br>cookieTokens[<span class="hljs-number">0</span>]);<br>       <br>       <span class="hljs-comment">//使用查询到的userDetails 再次生成签名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">expectedTokenSignature</span> <span class="hljs-operator">=</span> makeTokenSignature(tokenExpiryTime,<br>userDetails.getUsername(), userDetails.getPassword());<br>       <br>       <span class="hljs-comment">//验证签名和cookie里携带的签名相同</span><br><span class="hljs-keyword">if</span> (!equals(expectedTokenSignature, cookieTokens[<span class="hljs-number">2</span>])) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidCookieException</span>(<span class="hljs-string">&quot;Cookie token[2] contained signature &#x27;&quot;</span><br>+ cookieTokens[<span class="hljs-number">2</span>] + <span class="hljs-string">&quot;&#x27; but expected &#x27;&quot;</span> + expectedTokenSignature + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> userDetails;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>下面是正常登录成功后，Cookie生成逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLoginSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span><br><span class="hljs-params">Authentication successfulAuthentication)</span> &#123;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> retrieveUserName(successfulAuthentication);<br>        <br>        <span class="hljs-comment">//此处的获取密码方法已被我们重写，返回 用户名+salt</span><br><span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> retrievePassword(successfulAuthentication);<br><br>        <span class="hljs-comment">//过期时间</span><br><span class="hljs-type">int</span> <span class="hljs-variable">tokenLifetime</span> <span class="hljs-operator">=</span> calculateLoginLifetime(request, successfulAuthentication);<br><span class="hljs-type">long</span> <span class="hljs-variable">expiryTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>expiryTime += <span class="hljs-number">1000L</span> * (tokenLifetime &lt; <span class="hljs-number">0</span> ? TWO_WEEKS_S : tokenLifetime);<br><br>        <span class="hljs-comment">//生成签名</span><br><span class="hljs-type">String</span> <span class="hljs-variable">signatureValue</span> <span class="hljs-operator">=</span> makeTokenSignature(expiryTime, username, password);<br><span class="hljs-comment">//设置cookie</span><br>setCookie(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123; username, Long.toString(expiryTime), signatureValue &#125;,tokenLifetime, request, response);<br><br>        <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​以上就是使用<code>SpringSecurity</code>做无状态服务的方法，除了第一次登陆时，后面验证是否登录是不需要查库的，我们也可以重写生成<code>Cookie</code>的方法，将更多的信息保存在前端。</p><p>​<code>rememberMeService</code>是完全嵌入到<code>SpringSecurity</code>体系内的组件，且其中的设置<code>Cookie</code>，清理<code>Cookie</code>都已经有实现，我们用这个来实现<code>jwt</code>是相当方便的。</p><p>​除此之外也可以使用自定义<code>filter</code>达到同样效果，但是利用<code>rememberMeService</code>实现起来比较简单。</p>]]></content>
    
    
    
    <tags>
      
      <tag>springSecurity</tag>
      
      <tag>spring</tag>
      
      <tag>jwt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot 如何正确配置springmvc</title>
    <link href="/3977069685.html"/>
    <url>/3977069685.html</url>
    
    <content type="html"><![CDATA[<h1 id="springboot-如何正确配置springmvc"><a href="#springboot-如何正确配置springmvc" class="headerlink" title="springboot 如何正确配置springmvc"></a>springboot 如何正确配置springmvc</h1><p>​</p><p>​虽然<code>Springboot</code>是开箱即用的，使用<code>Springmvc</code>也是十分简单，但是如何配置才是最好的呢？，看到很多人多它的用法不了解，本文讲一下它的用法。</p><p>将它之前，我们先了解下<strong>什么是<code>Springmvc</code></strong>。</p><p>​<code>Springmvc</code>是基于<code>servlet</code>体系的开发框架，他由<code>DispatcherServlet</code>拦截请求，根据请求路径使用<code>handlerMapper</code>查找到能执行请求的<code>handler</code>，再由<code>handlerAdapter</code>执行<code>handler</code>。</p><p>这其中又涉及到了如何映射?，如何解析参数?，如果处理返回值?，如果处理异常?，如果渲染页面?，等一系列问题，但是核心的操作就是下面三个。</p><ol><li><p><code>DispatcherServlet</code> 实现了servlet接口，负责拦截请求</p></li><li><p><code>handlerMapper</code> 负责路由</p></li><li><p><code>handlerAdapter</code> 负责执行handler</p></li></ol><p>所以<code>Springboot</code>的自动配置就是将上面的一系列类初始化好，再启动<code>Tomcat</code>，将<code>servlet</code>配置到<code>tomcat</code>里面。</p><h2 id="1-WebMvcConfigurationSupport"><a href="#1-WebMvcConfigurationSupport" class="headerlink" title="1. WebMvcConfigurationSupport"></a>1. WebMvcConfigurationSupport</h2><p>​打开<code>WebMvcConfigurationSupport</code>类查看代码，我么上面讲到的<code>Springmvc</code>需要的组件全部在此类中定义，并且留了大量的钩子函数，供我们自定义，我们可以继承此类，重写其中的钩子函数，想要修改那部分就找到其中的钩子函数，可以完成定制。</p><p>​但是这种方式并不好，第一我们继承此类后，Springboot的自动配置就会失效，第二其他类如果想要定制Springmvc就不行了。</p><h2 id="2-EnableWebMvc注解"><a href="#2-EnableWebMvc注解" class="headerlink" title="2.@EnableWebMvc注解"></a>2.@EnableWebMvc注解</h2><p>​查看该注解的源码其引入了<code>DelegatingWebMvcConfiguration</code>类，这是一个代理类，并且继承<code>WebMvcConfigurationSupport</code>，他能自动查找<code>WebMvcConfigurer</code>，同样能对<code>Springmvc</code>进行定制，并且不止我们自己能能提供<code>WebMvcConfigurer</code>，其他框架也能提供<code>WebMvcConfigurer</code>，多个<code>WebMvcConfigurer</code>可以共存。所以比上面的方法更好。查看<code>WebMvcConfigurer</code>里面的方法，和<code>WebMvcConfigurationSupport</code>非常相似的。</p><h2 id="3-直接实现WebMvcConfigurer接口"><a href="#3-直接实现WebMvcConfigurer接口" class="headerlink" title="3. 直接实现WebMvcConfigurer接口"></a>3. 直接实现<code>WebMvcConfigurer</code>接口</h2><p>​查看<code>WebMvcAutoConfiguration</code>类，这是<code>Springboot</code>对<code>Springmvc</code>的自动配置类，其中有一个子类<code>EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration</code>，所以即使我么不使用<code>@EnableWebMvc</code>注解，也可以实现配置，并且此类中内置了大量有用的配置。</p><p>如默认资源路径配置，<code>OrderedHiddenHttpMethodFilter</code>，<code>OrderedFormContentFilter</code>等。</p><p>​由于继承了<code>DelegatingWebMvcConfiguration</code>，所以我们想要自定义可以直接实现<code>WebMvcConfigurer</code>接口。</p><p>上面三种方式都可以实现自定义<code>Springmvc</code>，第一种方式是强烈不推荐的，如果不想要<code>WebMvcAutoConfiguration</code>类内默认配置的那些东西，可以使用第二种方式，如果想要默认配置的东西，可以使用第三种方式，建议使用第三种方法，因为默认配置有不少有用的东西。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​综上所述，配置<code>Springmvc</code>的最优雅方式就是实现<code>WebMvcConfigurer</code>接口，并让工厂扫描到，所有的自定义配置都通过钩子函数完成，不要使用<code>@EnableWebMvc</code>注解，更不要直接继承<code>WebMvcConfigurationSupport</code>类。</p><p>​另外<code>SpringWebFlux</code>的配置思路和<code>Springmvc</code>基本一致，有兴趣学习webflux的可以顺着mvc的思路思考。</p>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>spring</tag>
      
      <tag>springmvc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springCloud-openFeign使用原理</title>
    <link href="/2775568942.html"/>
    <url>/2775568942.html</url>
    
    <content type="html"><![CDATA[<h1 id="springCloud-openFeign使用原理"><a href="#springCloud-openFeign使用原理" class="headerlink" title="springCloud-openFeign使用原理"></a>springCloud-openFeign使用原理</h1><p>​本文讲解<code>spring-cloud</code>环境下的<code>openFeign</code>的用法，探究<code>spring-cloud</code>是如何让<code>openfeign</code>开箱即用的。本文会假设读者已经熟练使用<code>openfeign</code>，对<code>openFeign</code>源码已有了解。</p><ul><li>TOC<br>{:toc}</li></ul><h2 id="1-先让项目运行起来"><a href="#1-先让项目运行起来" class="headerlink" title="1.先让项目运行起来"></a>1.先让项目运行起来</h2><p>新建<code>spring-cloud</code>项目，添加如下依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面以获取百度贴吧首页为例。</p><p>写一个接口，其中<code>@FeignClient</code>注解上<code>url属性</code>标识请求的域名，<code>@GetMapping</code>标注请求<code>method</code> 和<code>path</code>，<code>@RequestParam</code>标注请求参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//准备获取这个网页 https://tieba.baidu.com/f?kw=java</span><br><br><span class="hljs-meta">@FeignClient(name = &quot;javaBaCLient&quot;, url = &quot;https://tieba.baidu.com&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Baidu</span> &#123;<br><br><span class="hljs-meta">@GetMapping(value = &quot;/f&quot;)</span><br>String <span class="hljs-title function_">getMainPage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;kw&quot;)</span> String kw)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>启动类上添加注解<code>@EnableFeignClients</code></strong> 。</p><p>​将<code>Badu.class</code>类注入到其某个类中，并调用其中的方法，可以看到<code>spring-cloud</code>已经自动将上面的接口生成了代理类，一个开箱即用的案例就写好了。下面开始探究下它的实现原理和默认配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> Baidu baidu;<br><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">java</span> <span class="hljs-operator">=</span> baidu.getMainPage(<span class="hljs-string">&quot;java&quot;</span>);<br>    System.out.println(java);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​开箱即用，非常简单的就能将Demo跑起来。如果在已经存在的<code>SpringBoot</code>项目上添加<code>spring-cloud-openfeign</code>，要注意<code>spring-cloud</code>的版本必须匹配。这里有一个网址是<code>spring-cloud</code>项目的版本对应关系</p><p><a href="https://start.spring.io/actuator/info">https://start.spring.io/actuator/info</a></p><h2 id="2-自动装配"><a href="#2-自动装配" class="headerlink" title="2.自动装配"></a>2.自动装配</h2><p>​这里可能你会很好去，<code>spring-cloud</code>是怎么做的，他到底为我们做了什么？</p><p>首先从<code>@EnableFeignClients</code>注解上找到<code>org.springframework.cloud.openfeign.FeignClientsRegistrar</code>类</p><p>查看它的<code>registerBeanDefinitions</code>方法，它做了两件事情。</p><ol><li>找到<code>@EnableFeignClients</code>注解，将其属性<code>defaultConfiguration</code>对应的类注册为属性。</li><li>扫描带有<code>@FeignClien</code>注解的类，将其注册为<code>FeignClientFactoryBean</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata,</span><br><span class="hljs-params">                                    BeanDefinitionRegistry registry)</span> &#123;<br><br>    registerDefaultConfiguration(metadata, registry);<br>    registerFeignClients(metadata, registry);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里关键在<code>FeignClientFactoryBean</code>类，这是一个<code>工厂类</code>，它的<code>getObject()</code>方法里面是真正生成Feign接口代理类的。细节请看注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> getTarget();<br>&#125;<br><br><br>&lt;T&gt; T <span class="hljs-title function_">getTarget</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    1.获取FeignContext，相当于是ApplicationContext容器的子容器。</span><br><span class="hljs-comment">    有点类似于Springmvc的那个子容器一样</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">FeignContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationContext.getBean(FeignContext.class);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    2. 从容器里获取Builder，获取的build是经过配置的，下面有详细介绍此方法</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br>    Feign.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> feign(context);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    3.这个url就是@FeignClient注解上配置的url</span><br><span class="hljs-comment">    这里有意思的一点就是如果没有配置url只配置了name，那么他就会把name属性当成负载均衡的实例名称，这里底层要使用ribbon来做负载均衡，他就会尝试查找此name对应的实例。</span><br><span class="hljs-comment">    如果url不为空，如url配置的&#x27;http://www.baidu.com&#x27; 那么他就会以这个值为服务器地址。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (!StringUtils.hasText(<span class="hljs-built_in">this</span>.url)) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.name.startsWith(<span class="hljs-string">&quot;http&quot;</span>)) &#123;<br>            <span class="hljs-built_in">this</span>.url = <span class="hljs-string">&quot;http://&quot;</span> + <span class="hljs-built_in">this</span>.name;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.url = <span class="hljs-built_in">this</span>.name;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.url += cleanPath();<br>        <span class="hljs-comment">//url为空，使用负载均衡方式创建Feign</span><br>        <span class="hljs-keyword">return</span> (T) loadBalance(builder, context,<br>                               <span class="hljs-keyword">new</span> <span class="hljs-title class_">HardCodedTarget</span>&lt;&gt;(<span class="hljs-built_in">this</span>.type, <span class="hljs-built_in">this</span>.name, <span class="hljs-built_in">this</span>.url));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (StringUtils.hasText(<span class="hljs-built_in">this</span>.url) &amp;&amp; !<span class="hljs-built_in">this</span>.url.startsWith(<span class="hljs-string">&quot;http&quot;</span>)) &#123;<br>        <span class="hljs-built_in">this</span>.url = <span class="hljs-string">&quot;http://&quot;</span> + <span class="hljs-built_in">this</span>.url;<br>    &#125;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.url + cleanPath();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    4. 从容器里获取地城feign.Client，默认就是java原生的那个</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> getOptional(context, Client.class);<br>    <span class="hljs-keyword">if</span> (client != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (client <span class="hljs-keyword">instanceof</span> LoadBalancerFeignClient) &#123;<br>            <span class="hljs-comment">// not load balancing because we have a url,</span><br>            <span class="hljs-comment">// but ribbon is on the classpath, so unwrap</span><br>            client = ((LoadBalancerFeignClient) client).getDelegate();<br>        &#125;<br>        builder.client(client);<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    5.获取targeter，在targeter里面对实例进行配置</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">Targeter</span> <span class="hljs-variable">targeter</span> <span class="hljs-operator">=</span> get(context, Targeter.class);<br>    <span class="hljs-keyword">return</span> (T) targeter.target(<span class="hljs-built_in">this</span>, builder, context,<br>                               <span class="hljs-keyword">new</span> <span class="hljs-title class_">HardCodedTarget</span>&lt;&gt;(<span class="hljs-built_in">this</span>.type, <span class="hljs-built_in">this</span>.name, url));<br>&#125;<br><br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">获取Feign.Builder的过程，其实就是从容器里取各种各样的东西，配置进去</span><br><span class="hljs-comment">熟悉Feign的同学应该能看出来，分别是logger，encoder，decoder，contract</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">protected</span> Feign.Builder <span class="hljs-title function_">feign</span><span class="hljs-params">(FeignContext context)</span> &#123;<br><span class="hljs-type">FeignLoggerFactory</span> <span class="hljs-variable">loggerFactory</span> <span class="hljs-operator">=</span> get(context, FeignLoggerFactory.class);<br><span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> loggerFactory.create(<span class="hljs-built_in">this</span>.type);<br><br>Feign.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> get(context, Feign.Builder.class)<br><span class="hljs-comment">// required values</span><br>.logger(logger)<br>.encoder(get(context, Encoder.class))<br>.decoder(get(context, Decoder.class))<br>.contract(get(context, Contract.class));<br><br><span class="hljs-comment">//这里面也有一些配置，是根据配置文件或者注解上指定的配置类来配置的</span><br>        <span class="hljs-comment">//本文不讲这些</span><br>configureFeign(context, builder);<br><br><span class="hljs-keyword">return</span> builder;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>​通过<code>@EnableFeignClients</code>来引入一个<code>ImportBeanDefinitionRegistrar</code>。这个类里面注册了默认配置，扫描了所有的<code>@FeignClient</code>接口，将其注册为<code>FactoryBean</code>，真实使用时将会调用这个<code>FactoryBean</code>的<code>getObject</code>方法，此时才会产生代理类，并且生成代理类需要的各种组件都是从容器里获取的。</p><h2 id="3-默认配置"><a href="#3-默认配置" class="headerlink" title="3.默认配置"></a>3.默认配置</h2><p>根据<code>@EnableFeignClient</code>注解上的注释，找到了下面这个类<code>org.springframework.cloud.openfeign.FeignClientsConfiguration</code>，这是一个配置类，会被自动扫描到，它里面注入了以下组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//默认Decoder-&gt;SpringDecoder</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> Decoder <span class="hljs-title function_">feignDecoder</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptionalDecoder</span>(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntityDecoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringDecoder</span>(<span class="hljs-built_in">this</span>.messageConverters)));<br>&#125;<br><br><span class="hljs-comment">//默认Encoder-&gt;SpringEncoder</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-meta">@ConditionalOnMissingClass(&quot;org.springframework.data.domain.Pageable&quot;)</span><br><span class="hljs-keyword">public</span> Encoder <span class="hljs-title function_">feignEncoder</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringEncoder</span>(<span class="hljs-built_in">this</span>.messageConverters);<br>&#125;<br><br><span class="hljs-comment">//如果存在Pageable则用PageableSpringEncoder包装SpringEncoder</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnClass(name = &quot;org.springframework.data.domain.Pageable&quot;)</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> Encoder <span class="hljs-title function_">feignEncoderPageable</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageableSpringEncoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringEncoder</span>(<span class="hljs-built_in">this</span>.messageConverters));<br>&#125;<br><br><span class="hljs-comment">//默认Contract-&gt;SpringMvcContract</span><br><span class="hljs-comment">//在这里spring-cloud重用了springmvc里面的注解，抛弃了openfeign原生注解，可以看下此类的源码</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> Contract <span class="hljs-title function_">feignContract</span><span class="hljs-params">(ConversionService feignConversionService)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringMvcContract</span>(<span class="hljs-built_in">this</span>.parameterProcessors, feignConversionService);<br>&#125;<br><br><br><span class="hljs-comment">//默认重试策略为-&gt;NEVER_RETRY。因为一般要组合断路器使用，或者底层ribbon的重试，不需要Feign的重试</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> Retryer <span class="hljs-title function_">feignRetryer</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Retryer.NEVER_RETRY;<br>&#125;<br><br><span class="hljs-comment">//默认Builder,关闭重试</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> Feign.Builder <span class="hljs-title function_">feignBuilder</span><span class="hljs-params">(Retryer retryer)</span> &#123;<br>    <span class="hljs-keyword">return</span> Feign.builder().retryer(retryer);<br>&#125;<br><br><span class="hljs-comment">//默认的logger，没有配置的话默认是Slf4jLogger</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean(FeignLoggerFactory.class)</span><br><span class="hljs-keyword">public</span> FeignLoggerFactory <span class="hljs-title function_">feignLoggerFactory</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultFeignLoggerFactory</span>(<span class="hljs-built_in">this</span>.logger);<br>&#125;<br><br><span class="hljs-comment">//如果启用hystrix，则会使用HystrixFeign</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(&#123; HystrixCommand.class, HystrixFeign.class &#125;)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HystrixFeignConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-meta">@ConditionalOnProperty(name = &quot;feign.hystrix.enabled&quot;)</span><br>    <span class="hljs-keyword">public</span> Feign.Builder <span class="hljs-title function_">feignHystrixBuilder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> HystrixFeign.builder();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>上面就是<code>spring-cloud</code>对<code>Feign</code>的默认配置了，他们都是以bean的形式放在容器里，我们可以自己提供上面任何组件取而代之，这样我们替换其中任何组件都是非常简单的。</p><h2 id="4-默认客户端"><a href="#4-默认客户端" class="headerlink" title="4.默认客户端"></a>4.默认客户端</h2><p>​Feign默认使用的是Java原生的客户端，我们实际使用时一般要用<code>Apache Httpclient</code> 或者<code>okhttp</code>代替，<code>spring-cloud</code>为我们默认提供了这两种框架的自动配置，且是自动选择的。</p><p>​配置代码在<code>org.springframework.cloud.openfeign.FeignAutoConfiguration</code>里面，看名字就知道这是一个自动装配的配置类。</p><p>如果存在<code>HttpClient</code> 和 <code>feign.ApacheHttpClient</code>，则<code>HttpClient</code>就会生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(ApacheHttpClient.class)</span><br><span class="hljs-meta">@ConditionalOnMissingClass(&quot;com.netflix.loadbalancer.ILoadBalancer&quot;)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(CloseableHttpClient.class)</span><br><span class="hljs-meta">@ConditionalOnProperty(value = &quot;feign.httpclient.enabled&quot;, matchIfMissing = true)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClientFeignConfiguration</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Timer</span> <span class="hljs-variable">connectionManagerTimer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>(<br>        <span class="hljs-string">&quot;FeignApacheHttpClientConfiguration.connectionManagerTimer&quot;</span>, <span class="hljs-literal">true</span>);<br><br>    <span class="hljs-meta">@Autowired(required = false)</span><br>    <span class="hljs-keyword">private</span> RegistryBuilder registryBuilder;<br><br>    <span class="hljs-keyword">private</span> CloseableHttpClient httpClient;<br><br>    <span class="hljs-comment">//1.创建HttpClientConnectionManager</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean(HttpClientConnectionManager.class)</span><br>    <span class="hljs-keyword">public</span> HttpClientConnectionManager <span class="hljs-title function_">connectionManager</span><span class="hljs-params">(</span><br><span class="hljs-params">        ApacheHttpClientConnectionManagerFactory connectionManagerFactory,</span><br><span class="hljs-params">        FeignHttpClientProperties httpClientProperties)</span> &#123;<br>        <br>        <span class="hljs-comment">//这里的连接池最大连接数200</span><br>        <span class="hljs-comment">//每路由最大连接数50</span><br>        <span class="hljs-comment">//timeToLive默认900s</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">HttpClientConnectionManager</span> <span class="hljs-variable">connectionManager</span> <span class="hljs-operator">=</span> connectionManagerFactory<br>            .newConnectionManager(httpClientProperties.isDisableSslValidation(),<br>                                  httpClientProperties.getMaxConnections(),<br>                                  httpClientProperties.getMaxConnectionsPerRoute(),<br>                                  httpClientProperties.getTimeToLive(),<br>                                  httpClientProperties.getTimeToLiveUnit(),<br>                                  <span class="hljs-built_in">this</span>.registryBuilder);<br>        <br>        <span class="hljs-comment">//这里使用Timer类定时关闭连接池内的空闲连接，默认3s一次</span><br>        <span class="hljs-built_in">this</span>.connectionManagerTimer.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                connectionManager.closeExpiredConnections();<br>            &#125;<br>        &#125;, <span class="hljs-number">30000</span>, httpClientProperties.getConnectionTimerRepeat());<br>        <span class="hljs-keyword">return</span> connectionManager;<br>    &#125;<br><br>    <br>    <span class="hljs-comment">//2. 创建HttpClient</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CloseableHttpClient <span class="hljs-title function_">httpClient</span><span class="hljs-params">(ApacheHttpClientFactory httpClientFactory,</span><br><span class="hljs-params">                                          HttpClientConnectionManager httpClientConnectionManager,</span><br><span class="hljs-params">                                          FeignHttpClientProperties httpClientProperties)</span> &#123;<br>        <span class="hljs-type">RequestConfig</span> <span class="hljs-variable">defaultRequestConfig</span> <span class="hljs-operator">=</span> RequestConfig.custom()<br>            .setConnectTimeout(httpClientProperties.getConnectionTimeout())<br>            .setRedirectsEnabled(httpClientProperties.isFollowRedirects())<br>            .build();<br>        <span class="hljs-built_in">this</span>.httpClient = httpClientFactory.createBuilder()<br>            .setConnectionManager(httpClientConnectionManager)<br>            .setDefaultRequestConfig(defaultRequestConfig).build();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.httpClient;<br>    &#125;<br><br>    <span class="hljs-comment">//3. 创建feign的Client</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean(Client.class)</span><br>    <span class="hljs-keyword">public</span> Client <span class="hljs-title function_">feignClient</span><span class="hljs-params">(HttpClient httpClient)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApacheHttpClient</span>(httpClient);<br>    &#125;<br><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-built_in">this</span>.connectionManagerTimer.cancel();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.httpClient != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.httpClient.close();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果存在<code>okhttp</code>，则会使用下面的配置,这里就不做解释了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(OkHttpClient.class)</span><br><span class="hljs-meta">@ConditionalOnMissingClass(&quot;com.netflix.loadbalancer.ILoadBalancer&quot;)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(okhttp3.OkHttpClient.class)</span><br><span class="hljs-meta">@ConditionalOnProperty(&quot;feign.okhttp.enabled&quot;)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OkHttpFeignConfiguration</span> &#123;<br><br><span class="hljs-keyword">private</span> okhttp3.OkHttpClient okHttpClient;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean(ConnectionPool.class)</span><br><span class="hljs-keyword">public</span> ConnectionPool <span class="hljs-title function_">httpClientConnectionPool</span><span class="hljs-params">(</span><br><span class="hljs-params">FeignHttpClientProperties httpClientProperties,</span><br><span class="hljs-params">OkHttpClientConnectionPoolFactory connectionPoolFactory)</span> &#123;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">maxTotalConnections</span> <span class="hljs-operator">=</span> httpClientProperties.getMaxConnections();<br><span class="hljs-type">Long</span> <span class="hljs-variable">timeToLive</span> <span class="hljs-operator">=</span> httpClientProperties.getTimeToLive();<br><span class="hljs-type">TimeUnit</span> <span class="hljs-variable">ttlUnit</span> <span class="hljs-operator">=</span> httpClientProperties.getTimeToLiveUnit();<br><span class="hljs-keyword">return</span> connectionPoolFactory.create(maxTotalConnections, timeToLive, ttlUnit);<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> okhttp3.OkHttpClient <span class="hljs-title function_">client</span><span class="hljs-params">(OkHttpClientFactory httpClientFactory,</span><br><span class="hljs-params">ConnectionPool connectionPool,</span><br><span class="hljs-params">FeignHttpClientProperties httpClientProperties)</span> &#123;<br><span class="hljs-type">Boolean</span> <span class="hljs-variable">followRedirects</span> <span class="hljs-operator">=</span> httpClientProperties.isFollowRedirects();<br><span class="hljs-type">Integer</span> <span class="hljs-variable">connectTimeout</span> <span class="hljs-operator">=</span> httpClientProperties.getConnectionTimeout();<br><span class="hljs-type">Boolean</span> <span class="hljs-variable">disableSslValidation</span> <span class="hljs-operator">=</span> httpClientProperties.isDisableSslValidation();<br><span class="hljs-built_in">this</span>.okHttpClient = httpClientFactory.createBuilder(disableSslValidation)<br>.connectTimeout(connectTimeout, TimeUnit.MILLISECONDS)<br>.followRedirects(followRedirects).connectionPool(connectionPool)<br>.build();<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.okHttpClient;<br>&#125;<br><br><span class="hljs-meta">@PreDestroy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.okHttpClient != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.okHttpClient.dispatcher().executorService().shutdown();<br><span class="hljs-built_in">this</span>.okHttpClient.connectionPool().evictAll();<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean(Client.class)</span><br><span class="hljs-keyword">public</span> Client <span class="hljs-title function_">feignClient</span><span class="hljs-params">(okhttp3.OkHttpClient client)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>(client);<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>​</p><p>需要添加如下依赖，<code>Apache Httpclient</code>才会自动配置，注意要和Feign版本一致。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>10.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>​<code>spring-cloud</code>底层是可以根据项目存在的依赖选择使用<code>apache httpclient</code> 或者 <code>okhttp</code>来作为底层实现，而且<strong>默认配置都比较合理</strong>，几乎不用改动。</p><p>​需要注意的一点是，项目内只是存在<code>Apache Httpclient</code>的依赖是不够的，还需要添加<code>feign-httpclient</code>的依赖做适配包才可以。<code>okhttp</code>也是同理，都需要一个适配包。</p><h2 id="5-其他配置"><a href="#5-其他配置" class="headerlink" title="5.其他配置"></a>5.其他配置</h2><p>​还有一个配置类也会被自动扫描到，上面缺少的client相关的bean会从这里获取<code>org.springframework.cloud.commons.httpclient.HttpClientConfiguration</code>，以<code>Apache Httpclient</code>为例。他的源码是这样的，他的方法都带有<code>@ConditionalOnMissingBean</code>注解，所以优先级最低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnProperty(name = &quot;spring.cloud.httpclientfactories.apache.enabled&quot;, matchIfMissing = true)</span><br><span class="hljs-meta">@ConditionalOnClass(HttpClient.class)</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApacheHttpClientConfiguration</span> &#123;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> ApacheHttpClientConnectionManagerFactory <span class="hljs-title function_">connManFactory</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultApacheHttpClientConnectionManagerFactory</span>();<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> HttpClientBuilder <span class="hljs-title function_">apacheHttpClientBuilder</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> HttpClientBuilder.create();<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> ApacheHttpClientFactory <span class="hljs-title function_">apacheHttpClientFactory</span><span class="hljs-params">(</span><br><span class="hljs-params">HttpClientBuilder builder)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultApacheHttpClientFactory</span>(builder);<br>&#125;<br><br>&#125;<br>....<br>....<br>....    <br></code></pre></td></tr></table></figure><h3 id="控制日志等级"><a href="#控制日志等级" class="headerlink" title="控制日志等级"></a>控制日志等级</h3><p>​配置<code>loggerlevel bean</code>。<code>FeignFactory</code>创建时，会查找<code>Logger.Level</code>的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> feign.Logger.Level <span class="hljs-title function_">level</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> feign.Logger.Level.FULL;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="FeignClient接口方法上的注解解析过程"><a href="#FeignClient接口方法上的注解解析过程" class="headerlink" title="FeignClient接口方法上的注解解析过程"></a>FeignClient接口方法上的注解解析过程</h2><p>​代码里我们看到<code>spring-cloud-openfeign</code>没有使用feign提供的<code>Contract</code>，而是自己写了一个<code>SpringMvcContract</code>，所以对接口的解析已经不是原来的思路了，使用的注解也不一样。下面做简单介绍。</p><p>首先是解析类上的注解，这里会解析类上<code>RequestMapping</code>的value值作为url属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processAnnotationOnClass</span><span class="hljs-params">(MethodMetadata data, Class&lt;?&gt; clz)</span> &#123;<br><span class="hljs-keyword">if</span> (clz.getInterfaces().length == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">RequestMapping</span> <span class="hljs-variable">classAnnotation</span> <span class="hljs-operator">=</span> findMergedAnnotation(clz,<br>RequestMapping.class);<br><span class="hljs-keyword">if</span> (classAnnotation != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// Prepend path from class annotation if specified</span><br><span class="hljs-keyword">if</span> (classAnnotation.value().length &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">pathValue</span> <span class="hljs-operator">=</span> emptyToNull(classAnnotation.value()[<span class="hljs-number">0</span>]);<br>pathValue = resolve(pathValue);<br><span class="hljs-keyword">if</span> (!pathValue.startsWith(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>pathValue = <span class="hljs-string">&quot;/&quot;</span> + pathValue;<br>&#125;<br>data.template().uri(pathValue);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是解析方法上的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processAnnotationOnMethod</span><span class="hljs-params">(MethodMetadata data,</span><br><span class="hljs-params">                                         Annotation methodAnnotation, Method method)</span> &#123;<br>    <span class="hljs-comment">//1.方法上只能出现RequestMapping。或者getMapper postmapper这种</span><br>    <span class="hljs-keyword">if</span> (!RequestMapping.class.isInstance(methodAnnotation) &amp;&amp; !methodAnnotation<br>        .annotationType().isAnnotationPresent(RequestMapping.class)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">RequestMapping</span> <span class="hljs-variable">methodMapping</span> <span class="hljs-operator">=</span> findMergedAnnotation(method, RequestMapping.class);<br>    <span class="hljs-comment">// 解析请求method</span><br>    RequestMethod[] methods = methodMapping.method();<br>    <span class="hljs-keyword">if</span> (methods.length == <span class="hljs-number">0</span>) &#123;<br>        methods = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestMethod</span>[] &#123; RequestMethod.GET &#125;;<br>    &#125;<br>    checkOne(method, methods, <span class="hljs-string">&quot;method&quot;</span>);<br>    data.template().method(Request.HttpMethod.valueOf(methods[<span class="hljs-number">0</span>].name()));<br><br>    <span class="hljs-comment">// 解析path，这里将url append进去，拼接在类上解析的url后面</span><br>    <span class="hljs-keyword">if</span> (methodMapping.value().length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">pathValue</span> <span class="hljs-operator">=</span> emptyToNull(methodMapping.value()[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">if</span> (pathValue != <span class="hljs-literal">null</span>) &#123;<br>            pathValue = resolve(pathValue);<br>            <span class="hljs-comment">// Append path from @RequestMapping if value is present on method</span><br>            <span class="hljs-keyword">if</span> (!pathValue.startsWith(<span class="hljs-string">&quot;/&quot;</span>) &amp;&amp; !data.template().path().endsWith(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>                pathValue = <span class="hljs-string">&quot;/&quot;</span> + pathValue;<br>            &#125;<br>            data.template().uri(pathValue, <span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// produces</span><br>    parseProduces(data, method, methodMapping);<br><br>    <span class="hljs-comment">// consumes</span><br>    parseConsumes(data, method, methodMapping);<br><br>    <span class="hljs-comment">// headers</span><br>    parseHeaders(data, method, methodMapping);<br><br>    data.indexToExpander(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;Integer, Param.Expander&gt;());<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是解析参数上的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">processAnnotationsOnParameter</span><span class="hljs-params">(MethodMetadata data,</span><br><span class="hljs-params">Annotation[] annotations, <span class="hljs-type">int</span> paramIndex)</span> &#123;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isHttpAnnotation</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>AnnotatedParameterProcessor.<span class="hljs-type">AnnotatedParameterContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleAnnotatedParameterContext</span>(<br>data, paramIndex);<br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.processedMethods.get(data.configKey());<br><span class="hljs-keyword">for</span> (Annotation parameterAnnotation : annotations) &#123;<br><span class="hljs-type">AnnotatedParameterProcessor</span> <span class="hljs-variable">processor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.annotatedArgumentProcessors<br>.get(parameterAnnotation.annotationType());<br><span class="hljs-keyword">if</span> (processor != <span class="hljs-literal">null</span>) &#123;<br>Annotation processParameterAnnotation;<br><span class="hljs-comment">// synthesize, handling @AliasFor, while falling back to parameter name on</span><br><span class="hljs-comment">// missing String #value():</span><br>processParameterAnnotation = synthesizeWithMethodParameterNameAsFallbackValue(<br>parameterAnnotation, method, paramIndex);<br>isHttpAnnotation |= processor.processArgument(context,<br>processParameterAnnotation, method);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (isHttpAnnotation &amp;&amp; data.indexToExpander().get(paramIndex) == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-type">TypeDescriptor</span> <span class="hljs-variable">typeDescriptor</span> <span class="hljs-operator">=</span> createTypeDescriptor(method, paramIndex);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.conversionService.canConvert(typeDescriptor,<br>STRING_TYPE_DESCRIPTOR)) &#123;<br>Param.<span class="hljs-type">Expander</span> <span class="hljs-variable">expander</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.convertingExpanderFactory<br>.getExpander(typeDescriptor);<br><span class="hljs-keyword">if</span> (expander != <span class="hljs-literal">null</span>) &#123;<br>data.indexToExpander().put(paramIndex, expander);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> isHttpAnnotation;<br>&#125;<br></code></pre></td></tr></table></figure><p>​参数上的解析不是在此类里做的，而是委托给<code>annotatedArgumentProcessors</code>，来做，默认有下面四个解析器，分别可以解析<code>@PathVariable</code>， <code>@RequestParam</code> ，<code>@RequestHeader，</code> <code>@SpringQueryMap</code>注解。这里不展开将这四个解析器的源码了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">annotatedArgumentResolvers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PathVariableParameterProcessor</span>());<br>annotatedArgumentResolvers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestParamParameterProcessor</span>());<br>annotatedArgumentResolvers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestHeaderParameterProcessor</span>());<br>annotatedArgumentResolvers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryMapParameterProcessor</span>());<br></code></pre></td></tr></table></figure><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>​上面就是<code>SpringMvcContract</code>解析接口的过程，<code>spring-cloud-openfeign</code>抛弃了原来feign的注解，而是复用了<code>springmvc</code>里面的部分注解，降低了理解成本还是挺好的。</p><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>​</p><p>​以上就是<code>spring-cloud</code>配置<code>openfeign</code>的过程，读懂源码使用起来才能得心应手。从源码看出我们只要提供好底层依赖，依靠<code>spring-cloud</code>的默认配置就能的到一个不错效果。</p><p>​其实<code>spring-cloud</code>只使用了<code>openFeign</code>少部分自带功能，很多都是自己定制的如<code>encoder decoder contract</code>。还有一些组件是直接选择了固定的值如<strong>retry选择了no_retry，log选择了slf4j-feign</strong>等，主要是使用了Feign的思想而不是他的代码。</p><p>​下篇文章我们讲一讲<code>spring-cloud-Feign</code>负载均衡相关的源码，和<code>spring-cloud-Feign组合断路器</code>相关的源码。</p>]]></content>
    
    
    
    <tags>
      
      <tag>openfeign</tag>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot @EventListener注解的原理和使用</title>
    <link href="/1233211011.html"/>
    <url>/1233211011.html</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-EventListener注解的原理和使用"><a href="#SpringBoot-EventListener注解的原理和使用" class="headerlink" title="SpringBoot @EventListener注解的原理和使用"></a>SpringBoot @EventListener注解的原理和使用</h1><h2 id="1-观察者模式-监听者模式"><a href="#1-观察者模式-监听者模式" class="headerlink" title="1.观察者模式&#x2F;监听者模式"></a>1.观察者模式&#x2F;监听者模式</h2><p>​这个模式大家应该很熟悉，也经常被使用。但是如果我们使用的是<code>Spring</code>框架，其实它内置了一个好用的观察者模式的实现，用法也很简单。</p><h2 id="2-用法示例"><a href="#2-用法示例" class="headerlink" title="2.用法示例"></a>2.用法示例</h2><p>​下面的代码，首先在类里自动注入了<code>ApplicationEventPublisher</code>，这个也就是我们的<code>ApplicationCOntext</code>，它实现了这个接口。</p><p>再在post方法里，发送一条消息，这个消息其实就是一个类的实力。这样这条消息就会发送给监听器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.自动注入ApplicationEventPublisher</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> ApplicationEventPublisher applicationEventPublisher;<br><br><span class="hljs-comment">// 2.在类里面发送消息</span><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">post</span><span class="hljs-params">()</span>&#123;<br>applicationEventPublisher.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserCreateMessage</span>(<span class="hljs-string">&quot;张三&quot;</span>));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserCreateMessage</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">UserCreateMessage</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> Date createTime;<br>&#125;<br></code></pre></td></tr></table></figure><p>​在另一个类配置类里面使用注解<code>@EventListener</code>标记一个方法，这里注意参数是泛型的<code>PayloadApplicationEvent</code>，泛型就是我们的消息类型。因为上面发送的消息会被包装成<code>PayloadApplicationEvent</code>对象发送给监听者，<strong>只有泛型类型一致的才会匹配成功，且方法只能有一个参数</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//3. 这个方法就可以收到消息</span><br><span class="hljs-meta">@EventListener</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listener1</span><span class="hljs-params">(PayloadApplicationEvent&lt;UserCreateMessage&gt; event)</span>&#123;<br><span class="hljs-type">UserCreateMessage</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> event.getPayload();<br>System.out.println(payload);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​这就是最简单的用法，要保证上面的注解类会被注册到Spring里才行哦。</p><p>还有就是调用监听者是同步的，在监听方法里抛异常或堵塞都会影响发送消息的方法。</p><h2 id="3-原理"><a href="#3-原理" class="headerlink" title="3.原理"></a>3.原理</h2><p>其实上面添加<code>@EventListener</code>注解的方法被包装成了<code>ApplicationListener</code>对象，上面的类似于下面这种写法，这个应该比较好理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;PayloadApplicationEvent&lt;WebApplication.UserCreateMessage&gt;&gt; &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(PayloadApplicationEvent&lt;WebApplication.UserCreateMessage&gt; event)</span> &#123;<br>WebApplication.<span class="hljs-type">UserCreateMessage</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> event.getPayload();<br>System.out.println(payload);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>​那么Spring是什么时候做这件事的呢？</p><p>查看<code>SpringBoot</code>的源码，找到下面的代码,因为我是Tomcat环境，这里创建的<code>ApplicationContext</code>是<code>org.springframework.bootweb.servlet.context.AnnotationConfigServletWebServerApplicationContext</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> ConfigurableApplicationContext <span class="hljs-title function_">createApplicationContext</span><span class="hljs-params">()</span> &#123;<br>Class&lt;?&gt; contextClass = <span class="hljs-built_in">this</span>.applicationContextClass;<br><span class="hljs-keyword">if</span> (contextClass == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">switch</span> (<span class="hljs-built_in">this</span>.webApplicationType) &#123;<br><span class="hljs-keyword">case</span> SERVLET:<br>contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> REACTIVE:<br>contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br><span class="hljs-string">&quot;Unable create a default ApplicationContext, &quot;</span> + <span class="hljs-string">&quot;please specify an ApplicationContextClass&quot;</span>,<br>ex);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);<br>&#125;<br></code></pre></td></tr></table></figure><p>这是他的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AnnotationConfigServletWebServerApplicationContext</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">this</span>.reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotatedBeanDefinitionReader</span>(<span class="hljs-built_in">this</span>);<br><span class="hljs-built_in">this</span>.scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathBeanDefinitionScanner</span>(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>进到<code>AnnotatedBeanDefinitionReader</code>里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AnnotatedBeanDefinitionReader</span><span class="hljs-params">(BeanDefinitionRegistry registry, Environment environment)</span> &#123;<br>Assert.notNull(registry, <span class="hljs-string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);<br>Assert.notNull(environment, <span class="hljs-string">&quot;Environment must not be null&quot;</span>);<br><span class="hljs-built_in">this</span>.registry = registry;<br><span class="hljs-built_in">this</span>.conditionEvaluator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionEvaluator</span>(registry, environment, <span class="hljs-literal">null</span>);<br>AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="hljs-built_in">this</span>.registry);<br>&#125;<br></code></pre></td></tr></table></figure><p>再进到<code>AnnotationConfigUtis</code>的方法里面，省略了一部分代码，可以看到他注册了一个<code>EventListenerMethodProcessor</code>类到工厂了。这是一个<code>BeanFactory</code>的后置处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title function_">registerAnnotationConfigProcessors</span><span class="hljs-params">(</span><br><span class="hljs-params">BeanDefinitionRegistry registry, <span class="hljs-meta">@Nullable</span> Object source)</span> &#123;<br><br><span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> unwrapDefaultListableBeanFactory(registry);<br>......<br>    .....<br>    ......    <br><br><span class="hljs-keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;<br><span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">def</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(EventListenerMethodProcessor.class);<br>def.setSource(source);<br>beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));<br>&#125;<br>    <br>    ......<br>    ......<br><br><span class="hljs-keyword">return</span> beanDefs;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看这个<code>BeanFactory</code>的后置处理器<code>EventListenerMethodProcessor</code>，下面方法，他会遍历所有bean，找到其中带有<code>@EventListener</code>的方法，将它包装成<code>ApplicationListenerMethodAdapter</code>，注册到工厂里，这样就成功注册到Spring的监听系统里了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterSingletonsInstantiated</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">ConfigurableListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.beanFactory;<br>Assert.state(<span class="hljs-built_in">this</span>.beanFactory != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;No ConfigurableListableBeanFactory set&quot;</span>);<br>String[] beanNames = beanFactory.getBeanNamesForType(Object.class);<br><span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br><span class="hljs-keyword">if</span> (!ScopedProxyUtils.isScopedTarget(beanName)) &#123;<br>Class&lt;?&gt; type = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>type = AutoProxyUtils.determineTargetClass(beanFactory, beanName);<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br><span class="hljs-comment">// An unresolvable bean type, probably from a lazy bean - let&#x27;s ignore it.</span><br><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>logger.debug(<span class="hljs-string">&quot;Could not resolve target class for bean with name &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (type != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (ScopedObject.class.isAssignableFrom(type)) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>Class&lt;?&gt; targetClass = AutoProxyUtils.determineTargetClass(<br>beanFactory, ScopedProxyUtils.getTargetBeanName(beanName));<br><span class="hljs-keyword">if</span> (targetClass != <span class="hljs-literal">null</span>) &#123;<br>type = targetClass;<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br><span class="hljs-comment">// An invalid scoped proxy arrangement - let&#x27;s ignore it.</span><br><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>logger.debug(<span class="hljs-string">&quot;Could not resolve target bean for scoped proxy &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>processBean(beanName, type);<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInitializationException</span>(<span class="hljs-string">&quot;Failed to process @EventListener &quot;</span> +<br><span class="hljs-string">&quot;annotation on bean with name &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> Class&lt;?&gt; targetType)</span> &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.nonAnnotatedClasses.contains(targetType) &amp;&amp;<br>!targetType.getName().startsWith(<span class="hljs-string">&quot;java&quot;</span>) &amp;&amp;<br>!isSpringContainerClass(targetType)) &#123;<br><br>Map&lt;Method, EventListener&gt; annotatedMethods = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>annotatedMethods = MethodIntrospector.selectMethods(targetType,<br>(MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt;<br>AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class));<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br><span class="hljs-comment">// An unresolvable type in a method signature, probably from a lazy bean - let&#x27;s ignore it.</span><br><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>logger.debug(<span class="hljs-string">&quot;Could not resolve methods for bean with name &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(annotatedMethods)) &#123;<br><span class="hljs-built_in">this</span>.nonAnnotatedClasses.add(targetType);<br><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>logger.trace(<span class="hljs-string">&quot;No @EventListener annotations found on bean class: &quot;</span> + targetType.getName());<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Non-empty set of methods</span><br><span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationContext;<br>Assert.state(context != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;No ApplicationContext set&quot;</span>);<br>List&lt;EventListenerFactory&gt; factories = <span class="hljs-built_in">this</span>.eventListenerFactories;<br>Assert.state(factories != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;EventListenerFactory List not initialized&quot;</span>);<br><span class="hljs-keyword">for</span> (Method method : annotatedMethods.keySet()) &#123;<br><span class="hljs-keyword">for</span> (EventListenerFactory factory : factories) &#123;<br><span class="hljs-keyword">if</span> (factory.supportsMethod(method)) &#123;<br><span class="hljs-type">Method</span> <span class="hljs-variable">methodToUse</span> <span class="hljs-operator">=</span> AopUtils.selectInvocableMethod(method, context.getType(beanName));<br>ApplicationListener&lt;?&gt; applicationListener =<br>factory.createApplicationListener(beanName, targetType, methodToUse);<br><span class="hljs-keyword">if</span> (applicationListener <span class="hljs-keyword">instanceof</span> ApplicationListenerMethodAdapter) &#123;<br>((ApplicationListenerMethodAdapter) applicationListener).init(context, <span class="hljs-built_in">this</span>.evaluator);<br>&#125;<br>context.addApplicationListener(applicationListener);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>logger.debug(annotatedMethods.size() + <span class="hljs-string">&quot; @EventListener methods processed on bean &#x27;&quot;</span> +<br>beanName + <span class="hljs-string">&quot;&#x27;: &quot;</span> + annotatedMethods);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由方法生成<code>Listener</code>的逻辑由<code>EventListenerFactory</code>完成的，这又分为两种，一种是普通的<code>@EventLintener</code>  另一种是<code>@TransactionalEventListener</code> ，是由两个工厂处理的。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>​上面介绍了<code>@EventListener</code>的原理，其实上面方法里还有一个<code>@TransactionalEventListener</code>注解，其实原理是一模一样的，只是这个监听者可以选择在事务完成后才会被执行，事务执行失败就不会被执行。</p><p>​这两个注解的逻辑是一模一样的，并且<code>@TransactionalEventListener</code>本身就被标记有<code>@EventListener</code>，</p><p>只是最后生成监听器时所用的工厂不一样而已。</p>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>观察者模式</tag>
      
      <tag>监听器模式</tag>
      
      <tag>@EventListerer注解</tag>
      
      <tag>springboot消息机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven依赖的作用域</title>
    <link href="/38886229.html"/>
    <url>/38886229.html</url>
    
    <content type="html"><![CDATA[<h1 id="maven依赖的作用域"><a href="#maven依赖的作用域" class="headerlink" title="maven依赖的作用域"></a>maven依赖的作用域</h1><p>maven下面五种作用域，除去system外，其他四种的作用在下面讲解。</p><p>​</p><p>​配置的方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h2><p>​不填默认就是这个。</p><p>代码里可以使用，测试代码里也可以使用，会被打包到jar包里。</p><h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>​只能使用在测试代码里，正式代码里用不了，不会被打包到jar里。</p><h2 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h2><p>​不可以在代码里直接使用，但是会被打包到jar包里。</p><p>典型例子就是mysql jdbc驱动，我们不能直接在代码里new，而是使用的java提供的接口。接口通过反射获取驱动。</p><h2 id="provided"><a href="#provided" class="headerlink" title="provided"></a>provided</h2><p>​可以在代码里用，但不会被打包，因为他假设环境里存在能获取到。</p><p>典型例子就是<code>servlet-api</code>，开发时使用它，但不会被打包，因为运行它假设环境内一定存在。</p><h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><p>配置依赖文件从本地磁盘获取。</p>]]></content>
    
    
    
    <tags>
      
      <tag>maven</tag>
      
      <tag>maven依赖的作用域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven生命周期和常用插件</title>
    <link href="/2553918943.html"/>
    <url>/2553918943.html</url>
    
    <content type="html"><![CDATA[<h1 id="maven生命周期和常用插件"><a href="#maven生命周期和常用插件" class="headerlink" title="maven生命周期和常用插件"></a>maven生命周期和常用插件</h1><p>​</p><p>本文讲解下maven的生命周期和常用插件。</p><h2 id="maven的生命周期共分为下面三个部分，每个部分由多个步骤组成。"><a href="#maven的生命周期共分为下面三个部分，每个部分由多个步骤组成。" class="headerlink" title="maven的生命周期共分为下面三个部分，每个部分由多个步骤组成。"></a>maven的生命周期共分为下面三个部分，每个部分由多个步骤组成。</h2><h3 id="1-清理部分"><a href="#1-清理部分" class="headerlink" title="1. 清理部分"></a>1. 清理部分</h3><table><thead><tr><th align="left">步骤</th><th>描述</th></tr></thead><tbody><tr><td align="left"><code>pre-clean</code></td><td>在实际项目清理之前执行所需的过程</td></tr><tr><td align="left"><code>clean</code></td><td>删除以前的版本生成的所有文件</td></tr><tr><td align="left"><code>post-clean</code></td><td>执行完成项目清理所需的过程</td></tr></tbody></table><h3 id="2-编译部分"><a href="#2-编译部分" class="headerlink" title="2. 编译部分"></a>2. 编译部分</h3><table><thead><tr><th>步骤</th><th>描述</th></tr></thead><tbody><tr><td><code>validate</code></td><td>验证项目正确无误，并提供所有必要的信息。</td></tr><tr><td><code>initialize</code></td><td>初始化构建状态，例如设置属性或创建目录。</td></tr><tr><td><code>generate-sources</code></td><td>生成任何要包含在编译中的源代码。</td></tr><tr><td><code>process-sources</code></td><td>处理源代码，例如过滤任何值。</td></tr><tr><td><code>generate-resources</code></td><td>生成资源以包含在包中。</td></tr><tr><td><code>process-resources</code></td><td>将资源复制并处理到目标目录中，以备打包。</td></tr><tr><td><code>compile</code></td><td>编译项目的源代码。</td></tr><tr><td><code>process-classes</code></td><td>对编译后生成的文件进行后处理，例如对Java类进行字节码增强。</td></tr><tr><td><code>generate-test-sources</code></td><td>生成任何测试源代码以包含在编译中。</td></tr><tr><td><code>process-test-sources</code></td><td>处理测试源代码，例如过滤所有值。</td></tr><tr><td><code>generate-test-resources</code></td><td>创建测试资源。</td></tr><tr><td><code>process-test-resources</code></td><td>将资源复制并处理到测试目标目录中。</td></tr><tr><td><code>test-compile</code></td><td>将测试源代码编译到测试目标目录中</td></tr><tr><td><code>process-test-classes</code></td><td>从测试编译中对生成的文件进行后处理，例如对Java类进行字节码增强。</td></tr><tr><td><code>test</code></td><td>使用合适的单元测试框架运行测试。这些测试不应要求将代码打包或部署。</td></tr><tr><td><code>prepare-package</code></td><td>在实际包装之前执行准备包装所需的任何操作。这通常会导致包装的未包装，已处理版本。</td></tr><tr><td><code>package</code></td><td>获取编译后的代码，并将其打包为可分发格式，例如JAR。</td></tr><tr><td><code>pre-integration-test</code></td><td>在执行集成测试之前执行所需的操作。这可能涉及诸如设置所需环境的事情。</td></tr><tr><td><code>integration-test</code></td><td>处理该程序包，并在必要时将其部署到可以运行集成测试的环境中。</td></tr><tr><td><code>post-integration-test</code></td><td>在执行集成测试后执行所需的操作。这可能包括清理环境。</td></tr><tr><td><code>verify</code></td><td>运行任何检查以确认包装有效并符合质量标准。</td></tr><tr><td><code>install</code></td><td>将软件包安装到本地存储库中，以作为本地其他项目中的依赖项。</td></tr><tr><td><code>deploy</code></td><td>在集成或发布环境中完成后，将最终程序包复制到远程存储库，以便与其他开发人员和项目共享。</td></tr></tbody></table><h3 id="3-站点部分"><a href="#3-站点部分" class="headerlink" title="3. 站点部分"></a>3. 站点部分</h3><table><thead><tr><th>步骤</th><th>描述</th></tr></thead><tbody><tr><td><code>pre-site</code></td><td>在实际项目站点生成之前执行所需的过程</td></tr><tr><td><code>site</code></td><td>生成项目的站点文档</td></tr><tr><td><code>post-site</code></td><td>执行完成网站生成并为网站部署做准备所需的过程</td></tr><tr><td><code>site-deploy</code></td><td>将生成的站点文档部署到指定的Web服务器</td></tr></tbody></table><h2 id="生命周期调用逻辑"><a href="#生命周期调用逻辑" class="headerlink" title="生命周期调用逻辑"></a>生命周期调用逻辑</h2><p>​我们看到生命周期一共分为三个部分，每个部分有多个步骤组成。调用每个步骤时，会先调用其上面的步骤。</p><p>例如:</p><blockquote><p>我们调用<code>post-clean</code>步骤时，会先调用<code>pre-clean</code>，<code>clean</code> 才会调用<code>post-clean</code>。</p></blockquote><p>​但是不同部分的步骤不会影响。如果我们调用编译部分的<code>process-sources</code>步骤，在执行此步骤前会调用</p><p><code>validate</code>  <code>initialize</code> <code>generate-sources</code>，但是并不会执行清理部分里面的步骤。</p><h2 id="步骤调用方式"><a href="#步骤调用方式" class="headerlink" title="步骤调用方式"></a>步骤调用方式</h2><p>​调用maven的步骤很简单就像下面这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maven">mvn clean   调用清理周期内的clean步骤，！！注意这里同时也会调用clean上面的pre-clean步骤。<br><br><br>mvn package   调用编译部分的从validate到package(含)之间的所有步骤。<br></code></pre></td></tr></table></figure><h2 id="插件的绑定"><a href="#插件的绑定" class="headerlink" title="插件的绑定"></a>插件的绑定</h2><p>​我们通常执行下面命令来清理并打包项目。这个命令就执行了清理周期里面的<code>pre-clean</code> ，<code>clean</code>，以及打包周期里面的从<code>validate</code> 到 <code>package</code> 之间的所有步骤。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mvn clean <span class="hljs-keyword">package</span><br></code></pre></td></tr></table></figure><p>​maven真正的执行都是由插件完成的，插件只需要将自己绑定到maven的步骤上，当maven执行到相应步骤时就会调用插件里面的方法。插件是由Java编写的，也就是会回调插件的某个指定方法。</p><p>​如果某个步骤上没有被插件绑定，那么执行这个步骤时不会有任何效果。并不是每个步骤上都被插件绑定的。</p><h2 id="默认的绑定行为"><a href="#默认的绑定行为" class="headerlink" title="默认的绑定行为"></a>默认的绑定行为</h2><p>​默认我们什么也不做，maven就已经自带一些插件并绑定在周期的步骤上，当执行到该步骤时会自动调用插件的指定方法。</p><p>​如清理周期内的<code>maven-clean-plugin</code>绑定在<code>clean</code>步骤上，<code>maven-resources-plugin</code>插件将多个方法绑定在多个步骤上，分别实现复制资源和复制test资源，<code>maven-jar-plugin</code>插件可以将编译完成的文件打包成jar包。</p><h4 id="默认清理周期内的绑定"><a href="#默认清理周期内的绑定" class="headerlink" title="默认清理周期内的绑定"></a>默认清理周期内的绑定</h4><table><thead><tr><th align="left">Phase</th><th align="left">plugin:goal</th></tr></thead><tbody><tr><td align="left"><code>clean</code></td><td align="left"><code>clean:clean</code></td></tr></tbody></table><h4 id="默认编译周期内的绑定-ejb-ejb3-jar-par-rar-war"><a href="#默认编译周期内的绑定-ejb-ejb3-jar-par-rar-war" class="headerlink" title="默认编译周期内的绑定  ejb &#x2F; ejb3 &#x2F; jar &#x2F; par &#x2F; rar &#x2F; war"></a>默认编译周期内的绑定  <code>ejb</code> &#x2F; <code>ejb3</code> &#x2F; <code>jar</code> &#x2F; <code>par</code> &#x2F; <code>rar</code> &#x2F; <code>war</code></h4><table><thead><tr><th align="left">Phase</th><th align="left">plugin:goal</th></tr></thead><tbody><tr><td align="left"><code>process-resources</code></td><td align="left"><code>resources:resources</code></td></tr><tr><td align="left"><code>compile</code></td><td align="left"><code>compiler:compile</code></td></tr><tr><td align="left"><code>process-test-resources</code></td><td align="left"><code>resources:testResources</code></td></tr><tr><td align="left"><code>test-compile</code></td><td align="left"><code>compiler:testCompile</code></td></tr><tr><td align="left"><code>test</code></td><td align="left"><code>surefire:test</code></td></tr><tr><td align="left"><code>package</code></td><td align="left"><code>ejb:ejb</code> <em>or</em> <code>ejb3:ejb3</code> <em>or</em> <code>jar:jar</code> <em>or</em> <code>par:par</code> <em>or</em> <code>rar:rar</code> <em>or</em> <code>war:war</code></td></tr><tr><td align="left"><code>install</code></td><td align="left"><code>install:install</code></td></tr><tr><td align="left"><code>deploy</code></td><td align="left"><code>deploy:deploy</code></td></tr></tbody></table><h4 id="默认站点周期内的绑定"><a href="#默认站点周期内的绑定" class="headerlink" title="默认站点周期内的绑定"></a>默认站点周期内的绑定</h4><table><thead><tr><th align="left">Phase</th><th align="left">plugin:goal</th></tr></thead><tbody><tr><td align="left"><code>site</code></td><td align="left"><code>site:site</code></td></tr><tr><td align="left"><code>site-deploy</code></td><td align="left"><code>site:deploy</code></td></tr></tbody></table><p>​</p><h2 id="手动绑定插件到周期上"><a href="#手动绑定插件到周期上" class="headerlink" title="手动绑定插件到周期上"></a>手动绑定插件到周期上</h2><p>​有时这些默认的插件无法满足我们的需求，我么需要配置一些插件到周期上，下面以<code>maven-assembly-plugin</code>插件为例，验证插件的绑定。</p><p>​首先pom.xml文件里添加该插件，注意看<code>execution</code>里面已经将插件的<code>single</code>绑定到<code>package</code>步骤上，</p><p>因为一个插件可以绑定多个步骤，所以外面才会有一个<code>executions</code>标签。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">descriptorRefs</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">descriptorRef</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">descriptorRefs</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>assembly_build<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>single<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>下面执行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mvn clean <span class="hljs-keyword">package</span><br></code></pre></td></tr></table></figure><p>​可以看到<code>jar-plugin</code> 下面执行了<code>assembly-plugin</code>的<code>single</code>方法。生成的文件里出现一个包含第三方依赖的jar包，这正是<code>assembly</code> 插件的作用之一，将第三方依赖打包进jar包里。</p><p><img src="/img/in/2020-07-30-maven%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/image-20200730205526670.png" alt="image-20200730205526670"></p><p>​<img src="/img/in/2020-07-30-maven%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/image-20200730205649969.png" alt="image-20200730205649969"></p><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><p><code>maven-checkstyle-plugin</code> 代码格式检查</p><p><code>maven-dependency-plugin</code> 依赖相关的功能，如检查依赖，复制出依赖，等等</p><p><code>maven-assembly-plugin</code> 将一些文档、第三方依赖、等等打包到一个包里面。</p><p><code>maven-shade-plugin</code> 和<code>assembly</code>类似，也可以将第三方依赖打包成一个jar文件，而且可以分析第三方依赖里那些类是没有使用到的，排除掉他们使打包的体积更小。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>通常我们不会主动调用使用连字符的步骤如<code>pre-*</code> , <code>post-*</code> ，<code>process-*</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html">maven官网生命周期部分</a></p><p><a href="https://maven.apache.org/plugins/index.html">maven官网插件部分</a></p><p><a href="https://maven.apache.org/plugin-developers/index.html">maven官网插件开发部分</a></p><p><a href="https://maven.apache.org/guides/getting-started/index.html">maven官网入门指南</a></p><p>​</p>]]></content>
    
    
    
    <tags>
      
      <tag>maven</tag>
      
      <tag>maven生命周期</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springSecurity限制多用户登录</title>
    <link href="/1889842632.html"/>
    <url>/1889842632.html</url>
    
    <content type="html"><![CDATA[<h1 id="springSecurity限制多用户登录"><a href="#springSecurity限制多用户登录" class="headerlink" title="springSecurity限制多用户登录"></a>springSecurity限制多用户登录</h1><p>​</p><p>​限制用户多次登录的原理就是，每次用户登录时，将用户的<code>sessionId</code>存储起来，下次在登录时检查已经存在的<code>sessionId</code>列表里此用户登陆了几次，就能据此做处理了。</p><p>​最简单的就像这样设置，这样做以后后面登录的会将前面最近未使用的session挤掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">http.sessionManagement().maximumSessions(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>​</p><p>​如果想要禁止后面人的登录，而不是挤掉前面的人，可以这么做。可以拒绝后面登录的请求。这么做前面的人只是关闭浏览器而没有退出，也是处于在线状态的，后面人也是无法登录的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">http.sessionManagement().maximumSessions(<span class="hljs-number">1</span>).maxSessionsPreventsLogin(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>​但是还有一个问题，被挤掉的人的session信息仍然存储在<code>SessionRegistry</code>里，需要配置一个监听器，监听到session死亡时将其删除。这里只需要配置一个监听器即可。</p><p>​这个监听器在监听到session死亡时，会发送事件通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br>  <span class="hljs-keyword">public</span> HttpSessionEventPublisher <span class="hljs-title function_">httpSessionEventPublisher</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpSessionEventPublisher</span>();<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>​默认被挤掉的用户再次访问时，会通过write输出一段话，下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onExpiredSessionDetected</span><span class="hljs-params">(SessionInformationExpiredEvent event)</span><br>    <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> event.getResponse();<br>    response.getWriter().print(<br>        <span class="hljs-string">&quot;This session has been expired (possibly due to multiple concurrent &quot;</span><br>        + <span class="hljs-string">&quot;logins being attempted as the same user).&quot;</span>);<br>    response.flushBuffer();<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p><p>​这显然不是我们想要的效果，我么想输出一段<code>json</code>或者重定向到首页这样的操作。那么可以这样配置都可以。下面两种配置方式中选择一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">//自定义处理器   </span><br>http.sessionManagement().maximumSessions(<span class="hljs-number">1</span>).expiredSessionStrategy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SessionInformationExpiredStrategy</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onExpiredSessionDetected</span><span class="hljs-params">(SessionInformationExpiredEvent event)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>                <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> event.getResponse();<br>                response.setContentType(<span class="hljs-string">&quot;application/json&quot;</span>);<br>                response.getWriter().write(<span class="hljs-string">&quot;&#123;\&quot;status\&quot;:\&quot;200\&quot;&#125;&quot;</span>);<br>            &#125;<br>        &#125;);<br><br><span class="hljs-comment">//或者配置一个链接， 将会重定向到此链接</span><br>        http.sessionManagement().maximumSessions(<span class="hljs-number">1</span>).expiredUrl(<span class="hljs-string">&quot;/home&quot;</span>);<br>        <br></code></pre></td></tr></table></figure><p>​</p><p>​会话固定攻击导致的问题</p><p>​为了防止会话固定攻击，每次登录完成后会改变<code>sessionId</code>。这将导致一个问题，如果在登录状态下，再次调用登录接口，<code>SessionRegistry</code>里会将新登录的<code>sessionId</code>记录下来，但不会删除旧登录的<code>sessionId</code>，因为旧的session只是改Id了，并没有销毁。</p><p>解决这个问题可以使用下面的办法。配置会话固定攻击的策略为<code>migrateSession</code>。这样会创建一个新的session，并将旧session里的内容复制进来。这样做会触发session销毁的监听器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">http.sessionManagement().maximumSessions(<span class="hljs-number">1</span>)<br>        .and()<br>        .sessionFixation().migrateSession();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>springSecurity</tag>
      
      <tag>AuthenticationManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springSecurity认证管理器</title>
    <link href="/4256921896.html"/>
    <url>/4256921896.html</url>
    
    <content type="html"><![CDATA[<h1 id="springSecurity认证管理器"><a href="#springSecurity认证管理器" class="headerlink" title="springSecurity认证管理器"></a>springSecurity认证管理器</h1><p>​</p><p>​SpringSecurity负责验证用户身份需要用到认证管理器（AuthenticationManager）。</p><p>认证管理器的接口很简单，只有一个方法，将用户名密码传入此认证器，如果不报错则为认证通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AuthenticationManager</span> &#123;<br>Authentication <span class="hljs-title function_">authenticate</span><span class="hljs-params">(Authentication authentication)</span><br><span class="hljs-keyword">throws</span> AuthenticationException;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="认证管理器"><a href="#认证管理器" class="headerlink" title="认证管理器"></a>认证管理器</h2><p>​在springSecurity里，我们可以配置多个认证管理器，将多个认证管理器合并成一个<code>ProviderManager</code>对外提供服务，只要有一个认证管理器认证通过，则表示通过，是一种责任链模式。</p><p>​<img src="/img/in/2020-07-20-springSecurity%E8%AE%A4%E8%AF%81%E7%AE%A1%E7%90%86%E5%99%A8/image-20200720125330662.png" alt="image-20200720125330662"></p><p>​将多个authenticationProviders合并成一个的代码实现在这里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder#performBuild </span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> ProviderManager <span class="hljs-title function_">performBuild</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//将多个authenticationProviders合并成一个</span><br><span class="hljs-type">ProviderManager</span> <span class="hljs-variable">providerManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProviderManager</span>(authenticationProviders,<br>parentAuthenticationManager);<br>        <span class="hljs-comment">//验证通过是否擦除密码</span><br><span class="hljs-keyword">if</span> (eraseCredentials != <span class="hljs-literal">null</span>) &#123;<br>providerManager.setEraseCredentialsAfterAuthentication(eraseCredentials);<br>&#125;<br><span class="hljs-keyword">if</span> (eventPublisher != <span class="hljs-literal">null</span>) &#123;<br>providerManager.setAuthenticationEventPublisher(eventPublisher);<br>&#125;<br>providerManager = postProcess(providerManager);<br><span class="hljs-keyword">return</span> providerManager;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="配置认证管理器"><a href="#配置认证管理器" class="headerlink" title="配置认证管理器"></a>配置认证管理器</h2><p>配置的方式有两种，一种是重写下面的方法，配置好<code>userDetailService</code> 和 <code>passwoedEncoder</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    auth.userDetailsService(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDetailsService</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> UserDetails <span class="hljs-title function_">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException &#123;<br>            <span class="hljs-comment">//此处从数据库加载用户信息，并构造出userDetail的实例返回</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;).passwordEncoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PasswordEncoder</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">encode</span><span class="hljs-params">(CharSequence rawPassword)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//验证前传入的密码和数据库里的密码是否正确</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(CharSequence rawPassword, String encodedPassword)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码则会自动配置一个<code>DaoAuthentication</code>。</p><p>​另一种方式是将<code>userDetailService</code> 和 <code>passwordEncoder</code> 配置成spring的bean，框架就能自动查找到。</p><p>具体实现请查看在<code>@EnableGlobalAuthentication</code>注解是如何做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//配置初始化userDetail的配置</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InitializeUserDetailsBeanManagerConfigurer <span class="hljs-title function_">initializeUserDetailsBeanManagerConfigurer</span><span class="hljs-params">(ApplicationContext context)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitializeUserDetailsBeanManagerConfigurer</span>(context);<br>&#125;<br><br><span class="hljs-comment">//配置会被自动注入进来</span><br><span class="hljs-meta">@Autowired(required = false)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setGlobalAuthenticationConfigurers</span><span class="hljs-params">(</span><br><span class="hljs-params">    List&lt;GlobalAuthenticationConfigurerAdapter&gt; configurers)</span> &#123;<br>    configurers.sort(AnnotationAwareOrderComparator.INSTANCE);<br>    <span class="hljs-built_in">this</span>.globalAuthConfigurers = configurers;<br>&#125;<br><br><span class="hljs-comment">//配置内部的实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InitializeUserDetailsManagerConfigurer</span><br><span class="hljs-keyword">extends</span> <span class="hljs-title class_">GlobalAuthenticationConfigurerAdapter</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-keyword">if</span> (auth.isConfigured()) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>            <span class="hljs-comment">//从容器内获取UserDetailsService</span><br><span class="hljs-type">UserDetailsService</span> <span class="hljs-variable">userDetailsService</span> <span class="hljs-operator">=</span> getBeanOrNull(<br>UserDetailsService.class);<br><span class="hljs-keyword">if</span> (userDetailsService == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//从容器内获取PasswordEncoder</span><br><span class="hljs-type">PasswordEncoder</span> <span class="hljs-variable">passwordEncoder</span> <span class="hljs-operator">=</span> getBeanOrNull(PasswordEncoder.class);<br><span class="hljs-type">UserDetailsPasswordService</span> <span class="hljs-variable">passwordManager</span> <span class="hljs-operator">=</span> getBeanOrNull(UserDetailsPasswordService.class);<br><br>            <span class="hljs-comment">//创建DaoAuthenticationProvider</span><br><span class="hljs-type">DaoAuthenticationProvider</span> <span class="hljs-variable">provider</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DaoAuthenticationProvider</span>();<br>provider.setUserDetailsService(userDetailsService);<br><span class="hljs-keyword">if</span> (passwordEncoder != <span class="hljs-literal">null</span>) &#123;<br>provider.setPasswordEncoder(passwordEncoder);<br>&#125;<br><span class="hljs-keyword">if</span> (passwordManager != <span class="hljs-literal">null</span>) &#123;<br>provider.setUserDetailsPasswordService(passwordManager);<br>&#125;<br>provider.afterPropertiesSet();<br><br>auth.authenticationProvider(provider);<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>​上面两种配置方式都是可以的，本人更推荐第一种方式。一方面代码几种在一个配置文件里，比较方便查找，一方面如果想配置多个<code>HttpSecurity</code>，每个有独立的<code>UserDetailService</code>也更方便。</p><h2 id="框架对两种配置方式如何选择的"><a href="#框架对两种配置方式如何选择的" class="headerlink" title="框架对两种配置方式如何选择的"></a>框架对两种配置方式如何选择的</h2><p>​查看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter#authenticationManager<br></code></pre></td></tr></table></figure><p>​通过<code>configure</code>方法重写，如果没重写则为自动配置，重写了就是手动配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> AuthenticationManager <span class="hljs-title function_">authenticationManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">//如果没初始化则初始化</span><br>       <span class="hljs-keyword">if</span> (!authenticationManagerInitialized) &#123;<br><span class="hljs-comment">//默认将disableLocalConfigureAuthenticationBldr设置true</span><br>           configure(localConfigureAuthenticationBldr);<br><span class="hljs-comment">//使用本地自定义配置，就是配置1</span><br><span class="hljs-keyword">if</span> (disableLocalConfigureAuthenticationBldr) &#123;<br>authenticationManager = authenticationConfiguration<br>.getAuthenticationManager();<br>&#125;<br><span class="hljs-comment">//使用自动配置，配置2</span><br><span class="hljs-keyword">else</span> &#123;<br>authenticationManager = localConfigureAuthenticationBldr.build();<br>&#125;<br>authenticationManagerInitialized = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> authenticationManager;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-built_in">this</span>.disableLocalConfigureAuthenticationBldr = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>springSecurity</tag>
      
      <tag>AuthenticationManager</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springSecurity 退出登录</title>
    <link href="/218147151.html"/>
    <url>/218147151.html</url>
    
    <content type="html"><![CDATA[<h1 id="springSecurity-退出登录"><a href="#springSecurity-退出登录" class="headerlink" title="springSecurity 退出登录"></a>springSecurity 退出登录</h1><p>​</p><p>​这个<code>filter</code>比较简单，它要做的事情就是拦截退出登录的请求，执行退出逻辑，执行退出完成逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span><br><span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br><span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (HttpServletRequest) req;<br><span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> (HttpServletResponse) res;<br><span class="hljs-comment">//匹配到是退出请求，默认是/logout</span><br><span class="hljs-keyword">if</span> (requiresLogout(request, response)) &#123;<br><span class="hljs-type">Authentication</span> <span class="hljs-variable">auth</span> <span class="hljs-operator">=</span> SecurityContextHolder.getContext().getAuthentication();<br><br><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>logger.debug(<span class="hljs-string">&quot;Logging out user &#x27;&quot;</span> + auth<br>+ <span class="hljs-string">&quot;&#x27; and transferring to logout destination&quot;</span>);<br>&#125;<br><span class="hljs-comment">//执行退出逻辑</span><br><span class="hljs-built_in">this</span>.handler.logout(request, response, auth);<br>           <span class="hljs-comment">//执行退出完成成功，回掉逻辑</span><br>logoutSuccessHandler.onLogoutSuccess(request, response, auth);<br><br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>chain.doFilter(request, response);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="修改默认退出路径"><a href="#修改默认退出路径" class="headerlink" title="修改默认退出路径"></a>修改默认退出路径</h2><p>​下面这样配置可以修改默认退出路径，原理是创建<code>LogoutFilter</code>时，将里面的匹配规则改为我们设置的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">http.logout().logoutUrl(<span class="hljs-string">&quot;/my/logout&quot;</span>)<br></code></pre></td></tr></table></figure><p>​ 值得注意的是，如果开启csrf功能，则退出请求只支持post，否则可以支持四种请求方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> RequestMatcher <span class="hljs-title function_">getLogoutRequestMatcher</span><span class="hljs-params">(H http)</span> &#123;<br><span class="hljs-keyword">if</span> (logoutRequestMatcher != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> logoutRequestMatcher;<br>&#125;<br><span class="hljs-keyword">if</span> (http.getConfigurer(CsrfConfigurer.class) != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.logoutRequestMatcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathRequestMatcher</span>(<span class="hljs-built_in">this</span>.logoutUrl, <span class="hljs-string">&quot;POST&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">this</span>.logoutRequestMatcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrRequestMatcher</span>(<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathRequestMatcher</span>(<span class="hljs-built_in">this</span>.logoutUrl, <span class="hljs-string">&quot;GET&quot;</span>),<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathRequestMatcher</span>(<span class="hljs-built_in">this</span>.logoutUrl, <span class="hljs-string">&quot;POST&quot;</span>),<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathRequestMatcher</span>(<span class="hljs-built_in">this</span>.logoutUrl, <span class="hljs-string">&quot;PUT&quot;</span>),<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathRequestMatcher</span>(<span class="hljs-built_in">this</span>.logoutUrl, <span class="hljs-string">&quot;DELETE&quot;</span>)<br>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.logoutRequestMatcher;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="默认退出逻辑"><a href="#默认退出逻辑" class="headerlink" title="默认退出逻辑"></a>默认退出逻辑</h2><p>​在<code>LogoutConfigurer</code>类里可以看到，默认会添加两个退出逻辑。</p><p>​首先删除session内的用户信息，再删除<code>SecurityContextHolder</code>保存的用户信息，这样就算退出完成了。</p><p>如果项目里用户信息是保存在数据库里的，可与添加自定义的<code>logoutHandler</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> LogoutFilter <span class="hljs-title function_">createLogoutFilter</span><span class="hljs-params">(H http)</span> &#123;<br>    <span class="hljs-comment">//这是是删除session，删除SecurityContextHolder</span><br>logoutHandlers.add(contextLogoutHandler);<br>       <span class="hljs-comment">//这个是发送事件的</span><br>logoutHandlers.add(postProcess(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LogoutSuccessEventPublishingLogoutHandler</span>()));<br>LogoutHandler[] handlers = logoutHandlers.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LogoutHandler</span>[<span class="hljs-number">0</span>]);<br><span class="hljs-type">LogoutFilter</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogoutFilter</span>(getLogoutSuccessHandler(), handlers);<br>result.setLogoutRequestMatcher(getLogoutRequestMatcher(http));<br>result = postProcess(result);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="添加自定义logoutHandler"><a href="#添加自定义logoutHandler" class="headerlink" title="添加自定义logoutHandler"></a>添加自定义logoutHandler</h2><p>​可以看到自己添加的<code>LogoutHandler</code>会添加到<code>logoutHandlers</code>这个List里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">http.logout().addLogoutHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LogoutHandler</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logout</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> &#123;<br>        System.out.println(authentication.getPrincipal() + <span class="hljs-string">&quot;退出了&quot;</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-keyword">public</span> LogoutConfigurer&lt;H&gt; <span class="hljs-title function_">addLogoutHandler</span><span class="hljs-params">(LogoutHandler logoutHandler)</span> &#123;<br>    <span class="hljs-built_in">this</span>.logoutHandlers.add(logoutHandler);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="退出时自动删除Cookie"><a href="#退出时自动删除Cookie" class="headerlink" title="退出时自动删除Cookie"></a>退出时自动删除Cookie</h2><p>​下面这样配置，可以在退出时自动删除指定的Cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">http.logout().deleteCookies(<span class="hljs-string">&quot;sessionId&quot;</span>,<span class="hljs-string">&quot;usertoken&quot;</span>);<br></code></pre></td></tr></table></figure><p>​原理就是添加了<code>CookieClearingLogoutHandler</code>，在退出时向<code>response</code>添加同名<code>cookie</code>，将客户端的覆盖掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> LogoutConfigurer&lt;H&gt; <span class="hljs-title function_">deleteCookies</span><span class="hljs-params">(String... cookieNamesToClear)</span> &#123;<br>    <span class="hljs-keyword">return</span> addLogoutHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CookieClearingLogoutHandler</span>(cookieNamesToClear));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="退出成功执行逻辑"><a href="#退出成功执行逻辑" class="headerlink" title="退出成功执行逻辑"></a>退出成功执行逻辑</h2><p>​默认会重定向到<code>/login?logout</code>页面上，可以自定义重定向地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义退出成功Url,会重定向到此url</span><br>http.logout().logoutSuccessUrl(<span class="hljs-string">&quot;/my/login&quot;</span>);<br></code></pre></td></tr></table></figure><p>​重定向的原理就是用我们指定的路径创建一个<code>SimpleUrlLogoutSuccessHandler</code>。这个SuccessHandler调用时会做重定向操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> LogoutSuccessHandler <span class="hljs-title function_">getLogoutSuccessHandler</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">LogoutSuccessHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.logoutSuccessHandler;<br>    <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>) &#123;<br>        handler = createDefaultSuccessHandler();<br>    &#125;<br>    <span class="hljs-keyword">return</span> handler;<br>&#125;<br><br><span class="hljs-keyword">private</span> LogoutSuccessHandler <span class="hljs-title function_">createDefaultSuccessHandler</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">SimpleUrlLogoutSuccessHandler</span> <span class="hljs-variable">urlLogoutHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleUrlLogoutSuccessHandler</span>();<br>    urlLogoutHandler.setDefaultTargetUrl(logoutSuccessUrl);<br>    <span class="hljs-keyword">if</span> (defaultLogoutSuccessHandlerMappings.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> urlLogoutHandler;<br>    &#125;<br>    <span class="hljs-type">DelegatingLogoutSuccessHandler</span> <span class="hljs-variable">successHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegatingLogoutSuccessHandler</span>(defaultLogoutSuccessHandlerMappings);<br>    successHandler.setDefaultLogoutSuccessHandler(urlLogoutHandler);<br>    <span class="hljs-keyword">return</span> successHandler;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自定义-logoutSuccessHandler"><a href="#自定义-logoutSuccessHandler" class="headerlink" title="自定义 logoutSuccessHandler"></a>自定义 logoutSuccessHandler</h2><p>​有时候退出后不想重定向，而是数据给前台（前后端分离的项目应该都是这样）。可以自定义退出成功执行逻辑，可以覆盖上面的重定向操作。</p><p>​下面这样就是退出成功后，输出字符串到前台。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">http.logout().logoutSuccessHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LogoutSuccessHandler</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        response.getWriter().write(<span class="hljs-string">&quot;logou success&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="多退出路径"><a href="#多退出路径" class="headerlink" title="多退出路径"></a>多退出路径</h2><p>退出后可以对页面进行重定向，也可以返回Json数据，有时候想要两者共存怎么办呢？</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">如访问 <span class="hljs-regexp">/api/</span>logout，则返回json<br>访问 <span class="hljs-regexp">/page/</span>logout，执行重定向到首页<br></code></pre></td></tr></table></figure><p>也是可以做到的。</p><p>​首先自定义退出匹配规则，这样就能匹配多个退出路径了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义退出匹配规则</span><br>http.logout().logoutRequestMatcher(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrRequestMatcher</span>(<br>   <span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathRequestMatcher</span>(<span class="hljs-string">&quot;/api/logout&quot;</span>),<br>   <span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathRequestMatcher</span>(<span class="hljs-string">&quot;/page/logout&quot;</span>)<br>));<br><br></code></pre></td></tr></table></figure><p>​为其中一个退出路径指定<code>logoutSuccessHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//指定匹配/api/logout的退出路径，退出成功后执行逻辑</span><br>http.logout().defaultLogoutSuccessHandlerFor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LogoutSuccessHandler</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        response.getWriter().write(<span class="hljs-string">&quot;log success&quot;</span>);<br>    &#125;<br>&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathRequestMatcher</span>(<span class="hljs-string">&quot;/api/logout&quot;</span>));<br>        <br></code></pre></td></tr></table></figure><p>​剩下的那个<code>/page/logout</code>没有指定处理逻辑，则会走默认的重定向到<code>logoutSuccessUrl</code>。</p><p>这样就实现了拥有两个退出方式，且返回方式不同。</p><h2 id="所有配置"><a href="#所有配置" class="headerlink" title="所有配置"></a>所有配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>     <span class="hljs-comment">//1. 添加自定义退出路径</span><br>     http.logout().logoutUrl(<span class="hljs-string">&quot;/my/logout&quot;</span>);<br>     <span class="hljs-comment">//2. 添加自定义退出操作，如在这里修改数据库用户状态</span><br>     http.logout().addLogoutHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LogoutHandler</span>() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logout</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> &#123;<br>             System.out.println(authentication.getPrincipal() + <span class="hljs-string">&quot;退出了&quot;</span>);<br>         &#125;<br>     &#125;);<br>     <span class="hljs-comment">//3. 删除指定cookie</span><br>     http.logout().deleteCookies(<span class="hljs-string">&quot;sessionId&quot;</span>, <span class="hljs-string">&quot;usertoken&quot;</span>);<br>     <span class="hljs-comment">//4. 自定义退出成功重定向到Url</span><br>     http.logout().logoutSuccessUrl(<span class="hljs-string">&quot;/my/login&quot;</span>);<br><br>     <span class="hljs-comment">//5. 自定义退出成功Handler，此功能会覆盖4中的重定向操作</span><br>     http.logout().logoutSuccessHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LogoutSuccessHandler</span>() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>             response.getWriter().write(<span class="hljs-string">&quot;logou success&quot;</span>);<br>         &#125;<br>     &#125;);<br><br>     <span class="hljs-comment">//6.自定义退出匹配规则，可以存在多个。会覆盖1中的自定义路径</span><br>     http.logout().logoutRequestMatcher(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OrRequestMatcher</span>(<br>             <span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathRequestMatcher</span>(<span class="hljs-string">&quot;/api/logout&quot;</span>),<br>             <span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathRequestMatcher</span>(<span class="hljs-string">&quot;/page/logout&quot;</span>)<br>     ));<br>     <span class="hljs-comment">//7. 指定匹配/api/logout的退出路径，退出成功后执行逻辑</span><br><span class="hljs-comment">//满足匹配的走这里面的逻辑，不满足的走默认逻辑，默认逻辑是 4或者5</span><br>     http.logout().defaultLogoutSuccessHandlerFor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LogoutSuccessHandler</span>() &#123;<br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>             response.getWriter().write(<span class="hljs-string">&quot;log success&quot;</span>);<br>         &#125;<br>     &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathRequestMatcher</span>(<span class="hljs-string">&quot;/api/logout&quot;</span>));<br><br>     <span class="hljs-comment">//8.是否删除session，删除ContentSecurityHolder内的认证</span><br>     http.logout().invalidateHttpSession(<span class="hljs-literal">true</span>);<br>     http.logout().clearAuthentication(<span class="hljs-literal">true</span>);<br>     <span class="hljs-comment">//9.允许退出请求访问</span><br>     http.logout().permitAll();<br>     <br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​<code>SpringSecurity</code>的退出操作很简单，也很灵活。</p>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>springSecurity</tag>
      
      <tag>logoutFilter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springSecurity 防止csrf攻击</title>
    <link href="/1516389516.html"/>
    <url>/1516389516.html</url>
    
    <content type="html"><![CDATA[<h1 id="springSecurity-防止csrf攻击"><a href="#springSecurity-防止csrf攻击" class="headerlink" title="springSecurity 防止csrf攻击"></a>springSecurity 防止csrf攻击</h1><p>​</p><p>​启用csrf filter。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        http.csrf();<br>&#125;<br></code></pre></td></tr></table></figure><p>​CsrfFilter处理方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">HttpServletResponse response, FilterChain filterChain)</span><br><span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>request.setAttribute(HttpServletResponse.class.getName(), response);<br><br>    <span class="hljs-comment">//从存储token容器内获取，默认是session中获取</span><br><span class="hljs-type">CsrfToken</span> <span class="hljs-variable">csrfToken</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.tokenRepository.loadToken(request);<br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">missingToken</span> <span class="hljs-operator">=</span> csrfToken == <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//如果不存在则创建一个</span><br><span class="hljs-keyword">if</span> (missingToken) &#123;<br>csrfToken = <span class="hljs-built_in">this</span>.tokenRepository.generateToken(request);<br><span class="hljs-built_in">this</span>.tokenRepository.saveToken(csrfToken, request, response);<br>&#125;<br>request.setAttribute(CsrfToken.class.getName(), csrfToken);<br>request.setAttribute(csrfToken.getParameterName(), csrfToken);<br><br>    <br>    <span class="hljs-comment">//这里判断某些请求不进行csrf过滤，默认将&quot;GET&quot;, &quot;HEAD&quot;, &quot;TRACE&quot;, &quot;OPTIONS&quot;请求方式排除掉</span><br>    <span class="hljs-comment">//因为不建议使用上面四种方式做数据更新</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.requireCsrfProtectionMatcher.matches(request)) &#123;<br>filterChain.doFilter(request, response);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>    <span class="hljs-comment">//从head或paran里获取csrf token</span><br><span class="hljs-type">String</span> <span class="hljs-variable">actualToken</span> <span class="hljs-operator">=</span> request.getHeader(csrfToken.getHeaderName());<br><span class="hljs-keyword">if</span> (actualToken == <span class="hljs-literal">null</span>) &#123;<br>actualToken = request.getParameter(csrfToken.getParameterName());<br>&#125;<br>    <span class="hljs-comment">//比较请求上传的token与session存储的token是否一致</span><br><span class="hljs-keyword">if</span> (!csrfToken.getToken().equals(actualToken)) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isDebugEnabled()) &#123;<br><span class="hljs-built_in">this</span>.logger.debug(<span class="hljs-string">&quot;Invalid CSRF token found for &quot;</span><br>+ UrlUtils.buildFullRequestUrl(request));<br>&#125;<br>            <span class="hljs-comment">//不一致或session里缺少token走拒绝分支，返回403啥的</span><br><span class="hljs-keyword">if</span> (missingToken) &#123;<br><span class="hljs-built_in">this</span>.accessDeniedHandler.handle(request, response,<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">MissingCsrfTokenException</span>(actualToken));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">this</span>.accessDeniedHandler.handle(request, response,<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidCsrfTokenException</span>(csrfToken, actualToken));<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>filterChain.doFilter(request, response);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​上面要求客户端在进行如 <code>post，put，delete</code>请求时，在参数或head里携带登录时生成的token。<code>get head</code>  等不拦截，要求服务端符合<code>Restful</code>规范，不要用get更新用户数据。</p><h3 id="前端获取token"><a href="#前端获取token" class="headerlink" title="前端获取token"></a>前端获取token</h3><p>​像上面那样简单的启用<code>csrf</code>，用户登录时会设置<code>token</code>到<code>session</code>里，那前端怎么获取呢？ 可以开一个接口返回此token，因为跨域原因，第三方网站是无法获取的，自己网站在打开页面时获取一下存储在页面上。</p><h3 id="Token有效期和服务重启问题"><a href="#Token有效期和服务重启问题" class="headerlink" title="Token有效期和服务重启问题"></a>Token有效期和服务重启问题</h3><p>​  因为<code>token</code>存储在<code>session</code>里的，有效期就是<code>session</code>的有效期，在此期间如果服务器被强制重启<code>session</code>来不及钝化这将导致客户端使用正确的<code>token</code>，但无法验证通过，影响用户体验，可以将<code>token</code>存储在<code>redis</code>或数据库里，并设置有效期定期删除。</p><h3 id="百度贴吧的例子"><a href="#百度贴吧的例子" class="headerlink" title="百度贴吧的例子"></a>百度贴吧的例子</h3><p>​参考一下百度贴吧发帖请求时需要参数tbs，这个参数可以从接口 <a href="http://tieba.baidu.com/dc/common/tbs">http://tieba.baidu.com/dc/common/tbs</a> 上获取，每次请求都返回一个不一样的token，发帖时将携带token才能发帖成功。他的做法应该是每次调用接口都生成一个token，服务端保存最新的若干个token，发帖时只要和其中一个token一致即可验证通过。</p><h3 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h3><p>​除了将 token 存储在<code>session</code>里外，还可以存储在<code>cookie</code>里。</p><p>​用户登录成功后，生成<code>token</code>放入<code>cookie</code>里，客户端发起请求时将<code>cookie</code>里的<code>token</code>取出来放在参数上。服务端比较参数上的<code>token</code>和<code>cookie</code>里的<code>token</code>是否一致即可。因为第三方网站无法获取本站的<code>cookie</code>，也就无法伪造参数上的token，所以这种方案也是安全的。</p><p>​</p><h2 id="springSecurity-csrf的主要配置方法"><a href="#springSecurity-csrf的主要配置方法" class="headerlink" title="springSecurity csrf的主要配置方法"></a>springSecurity csrf的主要配置方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-comment">//设置session策略，登录成功后会回调此策略</span><br>http.csrf().sessionAuthenticationStrategy();<br><span class="hljs-comment">//设置token存储仓库，默认是存储在session里，可以设置存储在数据库里，或客户端cookie里      </span><br>http.csrf().csrfTokenRepository();<br><span class="hljs-comment">//需要忽略的路径</span><br>http.csrf().ignoringAntMatchers();<br><span class="hljs-comment">//强制验证的路径，即使是get也验证</span><br>http.csrf().requireCsrfProtectionMatcher()<br>    <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>springSecurity</tag>
      
      <tag>csrf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven utf8控制台下乱码</title>
    <link href="/3799814089.html"/>
    <url>/3799814089.html</url>
    
    <content type="html"><![CDATA[<h1 id="maven命令-GitBash控制台下乱码"><a href="#maven命令-GitBash控制台下乱码" class="headerlink" title="maven命令 GitBash控制台下乱码"></a>maven命令 GitBash控制台下乱码</h1><p>​添加环境变量</p><p>键 MAVEN_OPTS</p><p>值 -Dfile.encoding&#x3D;UTF-8</p><p>​重启GItBash，再试。</p>]]></content>
    
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>logback输出彩色日志，每个请求一种颜色</title>
    <link href="/2412438885.html"/>
    <url>/2412438885.html</url>
    
    <content type="html"><![CDATA[<h1 id="logback输出彩色日志，每个请求一种颜色，提高工作效率"><a href="#logback输出彩色日志，每个请求一种颜色，提高工作效率" class="headerlink" title="logback输出彩色日志，每个请求一种颜色，提高工作效率"></a>logback输出彩色日志，每个请求一种颜色，提高工作效率</h1><ul><li>TOC<br>{:toc}<br>​ <code>Java</code>项目，日志使用的时<code>slf4j + logback</code>，在服务器上查看日志时，都是黑白的，想要在服务器上输出的日志是彩色的，可以大大提高查看效率。</li></ul><p>​配合<code>slf4j</code>的<code>MDC</code>功能可以实现，可以实现一个请求链输出同一种颜色。</p><h2 id="输出颜色的基本原理"><a href="#输出颜色的基本原理" class="headerlink" title="输出颜色的基本原理"></a>输出颜色的基本原理</h2><p>​<code>linux</code>是自带<code>ANSI</code>功能是支持彩色日志的，可以这样测试下,下面的代码会输出绿色的 <code>日志</code>两个字。</p><p>想知道的更多，可以自行搜索下<code>ANSI</code>关键词</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e &quot;\033[32m 日志 \033[0m&quot;<br></code></pre></td></tr></table></figure><p>​所以只要我们将要输出的日志字符串用<code>\033[32m   \033[0m]</code>包起来,则查看就是绿色的，</p><p>​同理除了绿色外还有其他颜色,只要切换数字即可，具体颜色如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">BLACK_FG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;30&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">RED_FG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;31&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">GREEN_FG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;32&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">YELLOW_FG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;33&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">BLUE_FG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;34&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">MAGENTA_FG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;35&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">CYAN_FG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;36&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">WHITE_FG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;37&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_FG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;39&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="简单颜色输出测试"><a href="#简单颜色输出测试" class="headerlink" title="简单颜色输出测试"></a>简单颜色输出测试</h2><p>创建<code>Test.java</code>,在<code>linux</code>下编译运行下面函数，输出确实变成了绿色。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\033[32m&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\033[0m&quot;</span>;<br><br>    System.out.println(start + <span class="hljs-string">&quot;日志1&quot;</span> + end);<br>    System.out.println(start + <span class="hljs-string">&quot;日志2&quot;</span> + end);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="logback对彩色日志的支持"><a href="#logback对彩色日志的支持" class="headerlink" title="logback对彩色日志的支持"></a>logback对彩色日志的支持</h2><p>​一般<code>logback</code>的配置大概像下面这样，其中的<code>encoder</code>默认是<code>PatternLayoutEncoder</code>类，它包装了<code>PatternLayout</code>类对日志进行处理格式化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;appender name=<span class="hljs-string">&quot;CONSOLE&quot;</span> class=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;<br>    &lt;encoder&gt;<br>        &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %C:%L-%m%n&lt;/pattern&gt;<br>    &lt;/encoder&gt;<br>&lt;/appender&gt;<br></code></pre></td></tr></table></figure><p><code>PatternLayout</code>内有多个<code>converter</code>，每个<code>converter</code>处理模式的一部分，如常用的<code>%d</code>，<code>%p</code>，<code>%C</code>都是已经注册好的，还有一些如<code>%red</code> <code>%blue</code>就是处理颜色的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PatternLayout</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PatternLayoutBase</span>&lt;ILoggingEvent&gt; &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; defaultConverterMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">HEADER_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;#logback.classic pattern: &quot;</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        defaultConverterMap.putAll(Parser.DEFAULT_COMPOSITE_CONVERTER_MAP);<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;d&quot;</span>, DateConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;date&quot;</span>, DateConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;r&quot;</span>, RelativeTimeConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;relative&quot;</span>, RelativeTimeConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;level&quot;</span>, LevelConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;le&quot;</span>, LevelConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;p&quot;</span>, LevelConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;t&quot;</span>, ThreadConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;thread&quot;</span>, ThreadConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;lo&quot;</span>, LoggerConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;logger&quot;</span>, LoggerConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;c&quot;</span>, LoggerConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;m&quot;</span>, MessageConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;msg&quot;</span>, MessageConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;message&quot;</span>, MessageConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;C&quot;</span>, ClassOfCallerConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;class&quot;</span>, ClassOfCallerConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;M&quot;</span>, MethodOfCallerConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;method&quot;</span>, MethodOfCallerConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;L&quot;</span>, LineOfCallerConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;line&quot;</span>, LineOfCallerConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;F&quot;</span>, FileOfCallerConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;file&quot;</span>, FileOfCallerConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;X&quot;</span>, MDCConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;mdc&quot;</span>, MDCConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;ex&quot;</span>, ThrowableProxyConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;exception&quot;</span>, ThrowableProxyConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;rEx&quot;</span>, RootCauseFirstThrowableProxyConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;rootException&quot;</span>, RootCauseFirstThrowableProxyConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;throwable&quot;</span>, ThrowableProxyConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;xEx&quot;</span>, ExtendedThrowableProxyConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;xException&quot;</span>, ExtendedThrowableProxyConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;xThrowable&quot;</span>, ExtendedThrowableProxyConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;nopex&quot;</span>, NopThrowableInformationConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;nopexception&quot;</span>, NopThrowableInformationConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;cn&quot;</span>, ContextNameConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;contextName&quot;</span>, ContextNameConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;caller&quot;</span>, CallerDataConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;marker&quot;</span>, MarkerConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;property&quot;</span>, PropertyConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;n&quot;</span>, LineSeparatorConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;black&quot;</span>, BlackCompositeConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;red&quot;</span>, RedCompositeConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;green&quot;</span>, GreenCompositeConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;yellow&quot;</span>, YellowCompositeConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;blue&quot;</span>, BlueCompositeConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;magenta&quot;</span>, MagentaCompositeConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;cyan&quot;</span>, CyanCompositeConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;white&quot;</span>, WhiteCompositeConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;gray&quot;</span>, GrayCompositeConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;boldRed&quot;</span>, BoldRedCompositeConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;boldGreen&quot;</span>, BoldGreenCompositeConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;boldYellow&quot;</span>, BoldYellowCompositeConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;boldBlue&quot;</span>, BoldBlueCompositeConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;boldMagenta&quot;</span>, BoldMagentaCompositeConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;boldCyan&quot;</span>, BoldCyanCompositeConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;boldWhite&quot;</span>, BoldWhiteCompositeConverter.class.getName());<br>        defaultConverterMap.put(<span class="hljs-string">&quot;highlight&quot;</span>, HighlightingCompositeConverter.class.getName());<br><br>        defaultConverterMap.put(<span class="hljs-string">&quot;lsn&quot;</span>, LocalSequenceNumberConverter.class.getName());<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PatternLayout</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.postCompileProcessor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EnsureExceptionHandling</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Map&lt;String, String&gt; <span class="hljs-title function_">getDefaultConverterMap</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> defaultConverterMap;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doLayout</span><span class="hljs-params">(ILoggingEvent event)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isStarted()) &#123;<br>            <span class="hljs-keyword">return</span> CoreConstants.EMPTY_STRING;<br>        &#125;<br>        <span class="hljs-keyword">return</span> writeLoopOnConverters(event);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">getPresentationHeaderPrefix</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> HEADER_PREFIX;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="测试logback自带的颜色处理"><a href="#测试logback自带的颜色处理" class="headerlink" title="测试logback自带的颜色处理"></a>测试logback自带的颜色处理</h3><p>​上面的<code>PatternLayout</code>自带了一些颜色，我们测试下能否正常使用。</p><p>​创建项目，添加<code>logback</code>依赖，配置文件和代码如下，可以看到输出的颜色被改变了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-comment">&lt;!--使用%red()将要变色的模式包起来--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Pattern</span>&gt;</span>%red(%d&#123;yyyy-MM-dd HH:mm:ss&#125;) %-5p %C:%L-%m%n<span class="hljs-tag">&lt;/<span class="hljs-name">Pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;debug&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Test.class);<br><br>    log.info(<span class="hljs-string">&quot;日志&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/in/2020-06-28-logback%E8%BE%93%E5%87%BA%E5%BD%A9%E8%89%B2%E6%97%A5%E5%BF%97/image-20200629105812064.png" alt="image-20200629105812064"></p><p>可以看到，使用<code>%red()</code>将想变色的部分包起来，就会变色。这个颜色在<code>idea</code>的控制台，或者<code>linux</code>下能看到。</p><h2 id="logback变色的实现原理"><a href="#logback变色的实现原理" class="headerlink" title="logback变色的实现原理"></a>logback变色的实现原理</h2><p>​下面是<code>ForegroundCompositeConverterBase</code>的源码，可以看到它会在消息两端拼接上<code>\033[xm</code>这样的字符，和我们上面实例里手动拼接是一样的,所以才能展示不同的日志颜色。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">ESC_START</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\033[&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">ESC_END</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;m&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">SET_DEFAULT_COLOR</span> <span class="hljs-operator">=</span> ESC_START + <span class="hljs-string">&quot;0;&quot;</span> + DEFAULT_FG + ESC_END;<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> String <span class="hljs-title function_">transform</span><span class="hljs-params">(E event, String in)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    sb.append(ESC_START);<br>    sb.append(getForegroundColorCode(event));<br>    sb.append(ESC_END);<br>    sb.append(in);<br>    sb.append(SET_DEFAULT_COLOR);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="根据日志Level展示不同的颜色"><a href="#根据日志Level展示不同的颜色" class="headerlink" title="根据日志Level展示不同的颜色"></a>根据日志Level展示不同的颜色</h2><p>​<code>SpringBoot</code>是可以根据不同的日志级别展示不同颜色的，如<code>error</code>级别显示红色，<code>info</code>级别显示绿色。查看它的源码，发现它注册了自己写的<code>Converter</code>到<code>logback</code>里，名字叫<code>clr</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;clr&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;org.springframework.boot.logging.logback.ColorConverter&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>​配置<code>Pattern</code>是这样的,后面的<code>&#123;faint&#125;</code>是这个转换器的参数，通过<code>getFirstOption()</code>能获取到。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">%</span><span class="language-bash">clr(%d&#123;<span class="hljs-variable">$&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;</span>&#125;)&#123;faint&#125;</span><br></code></pre></td></tr></table></figure><p>​这里逻辑很简单，她先调用<code>getFirstOption()</code>拿到配置的颜色，如果没有配置，则获取日志等级，从<code>LEVELS</code>里获取该等级对应的颜色，然后用该等级对应的颜色拼接在日志两端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> String <span class="hljs-title function_">transform</span><span class="hljs-params">(ILoggingEvent event, String in)</span> &#123;<br>       <span class="hljs-comment">//ELEMENTS是一个map</span><br><span class="hljs-type">AnsiElement</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> ELEMENTS.get(getFirstOption());<br><span class="hljs-keyword">if</span> (element == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// LEVELS是一个map</span><br>element = LEVELS.get(event.getLevel().toInteger());<br>element = (element != <span class="hljs-literal">null</span>) ? element : AnsiColor.GREEN;<br>&#125;<br><span class="hljs-keyword">return</span> toAnsiString(in, element);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="MDC功能"><a href="#MDC功能" class="headerlink" title="MDC功能"></a>MDC功能</h2><p>​<code>servlet</code>的线程模型是每个请求创建一个线程处理，如果我们在请求开始向<code>ThreadLocal</code>里存入一个值，则整个请求链都能拿到相同的值，利用这一点可以实现一个请求链显示同一种颜色的日志。</p><p>​<code>MDC</code>就是<code>slf4j</code>提供的<code>ThreadLocal</code>，存入里面的值可以在配置中配置输出到日志里。我们可以在请求开始时存入颜色到<code>MDC</code>里，输出日志时根据我们配置的颜色输出。</p><h3 id="实验MDC功能"><a href="#实验MDC功能" class="headerlink" title="实验MDC功能"></a>实验MDC功能</h3><p>​在输出日志前将当前时间戳存入mdc，请求结束后移除mdc中对应的key。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//存入当前时间戳到MDC里，键为 mdc_key</span><br>      MDC.put(<span class="hljs-string">&quot;mdc_key&quot;</span>, String.valueOf(System.currentTimeMillis()));<br><br>      <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Test.class);<br>      log.info(<span class="hljs-string">&quot;日志&quot;</span>);<br><br>      MDC.remove(<span class="hljs-string">&quot;mdc_key&quot;</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><p><code>logback</code>里使用<code>%X&#123;&#125;</code>取出存入的值 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Pattern</span>&gt;</span>%X&#123;mdc_key&#125; %d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %C:%L-%m%n<span class="hljs-tag">&lt;/<span class="hljs-name">Pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/in/2020-06-28-logback%E8%BE%93%E5%87%BA%E5%BD%A9%E8%89%B2%E6%97%A5%E5%BF%97/image-20200629112323480.png" alt="image-20200629112323480"></p><p>日志中成功的输出了输出日之前存入<code>MDC</code>里的内容。</p><h2 id="使用MDC实现每个请求输出一种颜色"><a href="#使用MDC实现每个请求输出一种颜色" class="headerlink" title="使用MDC实现每个请求输出一种颜色"></a>使用MDC实现每个请求输出一种颜色</h2><p>创建一个<code>Converter</code> 继承<code>ForegroundCompositeConverterBase</code>，并将此<code>Converter</code>配置到<code>logback</code>的配置文件里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MdcColorConverter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForegroundCompositeConverterBase</span>&lt;ILoggingEvent&gt; &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MDCCOLORCONVERTER_KEY&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">getForegroundColorCode</span><span class="hljs-params">(ILoggingEvent event)</span> &#123;<br>        <span class="hljs-comment">//从event中获取MDCMap，再获取里面的key对应的值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> event.getMDCPropertyMap().get(key);<br>        <span class="hljs-comment">//如果没有返回默认颜色数值</span><br>        <span class="hljs-keyword">if</span> (color == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> ANSIConstants.DEFAULT_FG;<br>        &#125;<br>        <span class="hljs-comment">//否则返回对应颜色的数值</span><br>        <span class="hljs-keyword">return</span> color;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>创建一个<code>filter</code>，在请求进入<code>servelt</code>前，将随机颜色存入<code>MDC</code>内,并配置到<code>spring</code>里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MdcColorFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><br>    &#123;<br>        list.add(ANSIConstants.MAGENTA_FG); <span class="hljs-comment">//洋红/紫色</span><br>        list.add(ANSIConstants.BLUE_FG); <span class="hljs-comment">//蓝色</span><br>        list.add(ANSIConstants.CYAN_FG); <span class="hljs-comment">//青色</span><br>        list.add(ANSIConstants.GREEN_FG); <span class="hljs-comment">//绿色</span><br>        list.add(ANSIConstants.YELLOW_FG); <span class="hljs-comment">//黄色</span><br>        list.add(ANSIConstants.RED_FG); <span class="hljs-comment">//红色</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//循环调用list内的颜色</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> atm.getAndIncrement() % list.size();<br><span class="hljs-comment">//将颜色对用的数值存入MDC</span><br>            MDC.put(MdcColorConverter.key, list.get(Math.abs(index)));<br>            chain.doFilter(request, response);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//从MDC中删除键值</span><br>            MDC.remove(MdcColorConverter.key);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>创建一个<code>servlet</code>进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(TestController.class);<br><br>    <span class="hljs-meta">@RequestMapping(&quot;test&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        logger.info(<span class="hljs-string">&quot;日志1&quot;</span>);<br>        logger.warn(<span class="hljs-string">&quot;日志1&quot;</span>);<br>        logger.error(<span class="hljs-string">&quot;日志1&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>将<code>Converter</code>注册到<code>logback</code>上，配置如下,模式上使用我们注册的<code>Converter</code>将模式包起来。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 注册converter --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;mdcColor&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;com.test.util.MdcColorConverter&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;console_pattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%mdcColor(%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %C:%L-%m%n)&quot;</span>/&gt;</span><br>   <br><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;console_pattern&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br></code></pre></td></tr></table></figure><p>输出日志如下，每个请求一种颜色，非常便于人类查看。</p><p><img src="/img/in/2020-06-28-logback%E8%BE%93%E5%87%BA%E5%BD%A9%E8%89%B2%E6%97%A5%E5%BF%97/image-20200629113356747.png" alt="image-20200629113356747"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​以上就是输出彩色日志的方法，除了输出到控制台，也可以输出到文件里，在<code>linux</code>下使用<code>tail -f</code> 查看文件，或者使用 <code>less -r</code> 查看就是彩色的，注意这里的<code>less -r</code>需要加<code>-r</code>参数才可以。</p><p>​在本机调试时，因为只有自己访问，按照日志Level切换颜色看起来比较清晰，生产环境下，访问量大，多个请求日志之间的会交叉，使用<code>MDC</code>实现每个请求一种颜色比较便于人类观察。</p>]]></content>
    
    
    
    <tags>
      
      <tag>slf4j</tag>
      
      <tag>logback</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git rebase使用场景</title>
    <link href="/806832644.html"/>
    <url>/806832644.html</url>
    
    <content type="html"><![CDATA[<h1 id="git-rebase使用场景"><a href="#git-rebase使用场景" class="headerlink" title="git rebase使用场景"></a>git rebase使用场景</h1><ul><li>TOC<br>{:toc}</li></ul><h2 id="场景1，多用户对同一远程仓库进行提交"><a href="#场景1，多用户对同一远程仓库进行提交" class="headerlink" title="场景1，多用户对同一远程仓库进行提交"></a>场景1，多用户对同一远程仓库进行提交</h2><p>A，B同时从仓库pull下来代码，此时两人代码是一样的。</p><p>​首先是A，进行了修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">//修改文件a.txt<br>git add a.txt<br>git commit -m &quot;修复bug1&quot;<br></code></pre></td></tr></table></figure><p>​此时A的log是：</p><p>![image-20200629144439490](&#x2F;img&#x2F;in&#x2F;2020-06-29-git rebase使用场景&#x2F;image-20200629144439490.png)</p><p>​然后是B进行了修改,并推送到远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">//修改文件a.txt<br>git add a.txt<br>git commit -m &quot;修复bug2&quot;<br><br>//修改文件a.txt<br>git add a.txt<br>git commit -m &quot;修复bug3&quot;<br><br>git push origin master<br></code></pre></td></tr></table></figure><p>​此时B的log是下图两个提交，由于B已经push到远程分支了，远程分支的提交记录是和B一样的。</p><p>![image-20200629144513989](&#x2F;img&#x2F;in&#x2F;2020-06-29-git rebase使用场景&#x2F;image-20200629144513989.png)</p><p>​然后A想push时，会发现报错了，自己需要先pull合并，再push，于是A</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git pull origin master<br>//解决冲突<br>git add a.txt<br>git commit -m &quot;解决冲突&quot;<br></code></pre></td></tr></table></figure><p>​此时A的log变成了这样</p><p>![image-20200629144741125](&#x2F;img&#x2F;in&#x2F;2020-06-29-git rebase使用场景&#x2F;image-20200629144741125.png)</p><p>​这是因为需要把B提交的东西合并过来，所以产生了一个用于解决合并冲突的提交。强迫症觉得很不舒服。</p><p>但是如果B提交后，A再拉取代码，在B提交基础上进行开发就不会产生分叉。这里可以使用<code>rebase</code>命令进行<code>变基</code>,将<code>基</code>变成<code>修复bug3</code>的那次提交。</p><p>​A想到使用变基方法，于是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rebase origin/master<br>//解决冲突<br>git add a.txt<br>git rebase --continue<br></code></pre></td></tr></table></figure><p>​ 此时提交日志变成这样</p><p>![image-20200629145328469](&#x2F;img&#x2F;in&#x2F;2020-06-29-git rebase使用场景&#x2F;image-20200629145328469.png)</p><p>​通过对比上面的提交日志，可以看到<code>修复bug1</code>变成基于<code>修复bug3</code>那次提交，而不是原来那个提交了。这样就解决了分叉。</p><p><strong>rebase 后面跟的分支名，意思是将当前分支的基线，变成指定的分支。</strong></p><h2 id="场景2，多分支之间的冲突"><a href="#场景2，多分支之间的冲突" class="headerlink" title="场景2，多分支之间的冲突"></a>场景2，多分支之间的冲突</h2><p>A的本地初始版本是这样的</p><p>![image-20200629145915238](&#x2F;img&#x2F;in&#x2F;2020-06-29-git rebase使用场景&#x2F;image-20200629145915238.png)</p><p>A想创建一个dev分支进行开发，于是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b dev<br><br>git add a.txt<br>git commit -m &quot;正常开发1&quot;<br><br>git add a.txt<br>git commit -m &quot;正常开发1&quot;<br><br></code></pre></td></tr></table></figure><p>A进行两次正常提交后log是这样的，dev分支超过master分支两次提交</p><p>![image-20200629150243087](&#x2F;img&#x2F;in&#x2F;2020-06-29-git rebase使用场景&#x2F;image-20200629150243087.png)</p><p>这是遇到一个紧急bug需要修复，于是A从master分支开启一个分支进行紧急修复,并合并到主线。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout master<br>//修复<br>git add a.txt<br>git commit -m &quot;进行修复紧急&quot;<br></code></pre></td></tr></table></figure><p>此时master分支的log是这样的</p><p>![image-20200629150613982](&#x2F;img&#x2F;in&#x2F;2020-06-29-git rebase使用场景&#x2F;image-20200629150613982.png)</p><p>A继续回到dev分支开发，开发完成后想要将dev分支合并到master，因为dev分支的基线和当前master的是不一致的，就会产生分叉。</p><p>![image-20200629150845866](&#x2F;img&#x2F;in&#x2F;2020-06-29-git rebase使用场景&#x2F;image-20200629150845866.png)</p><p>所以这里不要直接将dev分支合并到master，要先对dev分支进行rebase，将基线变成当前master，然后再合并。</p><p>撤销上面的合并操作，先进行下面操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout dev<br>git rebase master<br>//解决冲突<br>git add a.txt<br>git rebase --continue<br></code></pre></td></tr></table></figure><p>此时dev分支的log是这样的，发现<code>进行紧急修复</code>的提交已经过来了,且成为了dev分支的基线。</p><p>![image-20200629152103287](&#x2F;img&#x2F;in&#x2F;2020-06-29-git rebase使用场景&#x2F;image-20200629152103287.png)</p><p>这是再进行合并，就可以无冲突合并了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout master<br>git merge dev<br></code></pre></td></tr></table></figure><p>![image-20200629152216064](&#x2F;img&#x2F;in&#x2F;2020-06-29-git rebase使用场景&#x2F;image-20200629152216064.png)</p><h2 id="场景3，合并多次提交记录为一次"><a href="#场景3，合并多次提交记录为一次" class="headerlink" title="场景3，合并多次提交记录为一次"></a>场景3，合并多次提交记录为一次</h2><p>​解决一个问题可能进行了多次提交，但每次提交更改的都比较少，或者是经过反复修改，想在想要将多次提交合并成一个可以这么做。</p><p>起初日志是这样的:</p><p>![image-20200629154137050](&#x2F;img&#x2F;in&#x2F;2020-06-29-git rebase使用场景&#x2F;image-20200629154137050.png)</p><p>然后问题解决了提交记录就成了这样，中间两次提交都是没有意义的。</p><p>![image-20200629154320358](&#x2F;img&#x2F;in&#x2F;2020-06-29-git rebase使用场景&#x2F;image-20200629154320358.png)</p><p>下面将三次提交合并成一次</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rebase -i HEAD~3<br></code></pre></td></tr></table></figure><p>弹出编辑框如下，可以仔细阅读下面的命令。</p><p>![image-20200629154447769](&#x2F;img&#x2F;in&#x2F;2020-06-29-git rebase使用场景&#x2F;image-20200629154447769.png)</p><p>我们将后两个提交的命令改为<code>squash</code>,意思就是合并到前一个提交上去，然后保存</p><p>![image-20200629154716993](&#x2F;img&#x2F;in&#x2F;2020-06-29-git rebase使用场景&#x2F;image-20200629154716993.png)</p><p>保存后还有一次重写提交日志的机会。保存后的记录成了这样，三次提交汇总成了一次。</p><p>![image-20200629154850867](&#x2F;img&#x2F;in&#x2F;2020-06-29-git rebase使用场景&#x2F;image-20200629154850867.png)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​以上就是<code>rebase</code>的基本用法，用好<code>rebase</code>可以让我么的git记录更清晰。</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>git rebase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springmvc异常处理</title>
    <link href="/1579615193.html"/>
    <url>/1579615193.html</url>
    
    <content type="html"><![CDATA[<h1 id="Springmvc全局异常处理-实现原理"><a href="#Springmvc全局异常处理-实现原理" class="headerlink" title="Springmvc全局异常处理,实现原理"></a>Springmvc全局异常处理,实现原理</h1><p>​<code>Springmvc</code>的异常处理是由下面这个接口提供的，只有一个方法，用来处理异常。称之为<code>异常处理器</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HandlerExceptionResolver</span> &#123;<br><br>ModelAndView <span class="hljs-title function_">resolveException</span><span class="hljs-params">(</span><br><span class="hljs-params">HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>​<code>DispatcherServlet</code>在初始化时，会调用下面这个方法，在这里初始化所有的异常处理器。这里的逻辑是如果容器内存在该类型的实例，就用容器内的，如果不存在就使用默认<code>spring.factories</code>文件里写的默认值。</p><p>​并且可以选择是搜索所有<code>HandlerExceptionResolver.class</code>类型的<code>bean</code>，还是只搜索名字叫<code>handlerExceptionResolver</code>的<code>bean</code>，由字段<code>detectAllHandlerExceptionResolvers</code>决定，默认搜索全部的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initHandlerExceptionResolvers</span><span class="hljs-params">(ApplicationContext context)</span> &#123;<br><span class="hljs-built_in">this</span>.handlerExceptionResolvers = <span class="hljs-literal">null</span>;<br><br>       <br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.detectAllHandlerExceptionResolvers) &#123;<br>Map&lt;String, HandlerExceptionResolver&gt; matchingBeans = BeanFactoryUtils<br>.beansOfTypeIncludingAncestors(context, HandlerExceptionResolver.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (!matchingBeans.isEmpty()) &#123;<br><span class="hljs-built_in">this</span>.handlerExceptionResolvers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;HandlerExceptionResolver&gt;(matchingBeans.values());<br><span class="hljs-comment">// We keep HandlerExceptionResolvers in sorted order.</span><br>OrderComparator.sort(<span class="hljs-built_in">this</span>.handlerExceptionResolvers);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">HandlerExceptionResolver</span> <span class="hljs-variable">her</span> <span class="hljs-operator">=</span><br>context.getBean(HANDLER_EXCEPTION_RESOLVER_BEAN_NAME, HandlerExceptionResolver.class);<br><span class="hljs-built_in">this</span>.handlerExceptionResolvers = Collections.singletonList(her);<br>&#125;<br><span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br><span class="hljs-comment">// Ignore, no HandlerExceptionResolver is fine too.</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.handlerExceptionResolvers == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.handlerExceptionResolvers = getDefaultStrategies(context, HandlerExceptionResolver.class);<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​<code>doDispatch</code>方法里，将查找<code>controller</code>并调用。渲染结果会调用下面这个方法，用于处理结果返回值。其中参数<code>exception</code>不为空时表示有错误发生的，就用到了异常处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processDispatchResult</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="hljs-meta">@Nullable</span> ModelAndView mv,</span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> Exception exception)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">errorView</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">//异常不为空</span><br><span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> ModelAndViewDefiningException) &#123;<br>logger.debug(<span class="hljs-string">&quot;ModelAndViewDefiningException encountered&quot;</span>, exception);<br>mv = ((ModelAndViewDefiningException) exception).getModelAndView();<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (mappedHandler != <span class="hljs-literal">null</span> ? mappedHandler.getHandler() : <span class="hljs-literal">null</span>);<br>               <span class="hljs-comment">//处理异常，返回处理结果</span><br>mv = processHandlerException(request, response, handler, exception);<br>errorView = (mv != <span class="hljs-literal">null</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Did the handler return a view to render?</span><br><span class="hljs-keyword">if</span> (mv != <span class="hljs-literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;<br>render(mv, request, response);<br><span class="hljs-keyword">if</span> (errorView) &#123;<br>WebUtils.clearErrorRequestAttributes(request);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>logger.trace(<span class="hljs-string">&quot;No view rendering, null ModelAndView returned.&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;<br><span class="hljs-comment">// Concurrent handling started during a forward</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-literal">null</span>) &#123;<br>mappedHandler.triggerAfterCompletion(request, response, <span class="hljs-literal">null</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​多个异常处理器会以责任链模式调用，这里可以看出，如果配置多个异常处理器，通过返回值是否为<code>null</code>来判断是否处理完成了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title function_">processHandlerException</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><span class="hljs-comment">// Success and error responses may use different content types</span><br>request.removeAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);<br><br><span class="hljs-comment">// </span><br><span class="hljs-type">ModelAndView</span> <span class="hljs-variable">exMv</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.handlerExceptionResolvers != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//责任链模式</span><br><span class="hljs-keyword">for</span> (HandlerExceptionResolver resolver : <span class="hljs-built_in">this</span>.handlerExceptionResolvers) &#123;<br>exMv = resolver.resolveException(request, response, handler, ex);<br><span class="hljs-keyword">if</span> (exMv != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (exMv != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (exMv.isEmpty()) &#123;<br>request.setAttribute(EXCEPTION_ATTRIBUTE, ex);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">// We might still need view name translation for a plain error model...</span><br><span class="hljs-keyword">if</span> (!exMv.hasView()) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">defaultViewName</span> <span class="hljs-operator">=</span> getDefaultViewName(request);<br><span class="hljs-keyword">if</span> (defaultViewName != <span class="hljs-literal">null</span>) &#123;<br>exMv.setViewName(defaultViewName);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>logger.trace(<span class="hljs-string">&quot;Using resolved error view: &quot;</span> + exMv, ex);<br>&#125;<br><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>logger.debug(<span class="hljs-string">&quot;Using resolved error view: &quot;</span> + exMv);<br>&#125;<br>WebUtils.exposeErrorRequestAttributes(request, ex, getServletName());<br><span class="hljs-keyword">return</span> exMv;<br>&#125;<br><br><span class="hljs-keyword">throw</span> ex;<br>&#125;<br></code></pre></td></tr></table></figure><p>​下面介绍<code>ExceptionHandlerExceptionResolver</code>源码，我们经常使用的就是这个，他需要配合</p><p><code>RequestMappingHandlerMapping</code>，<code>RequestMappingHandlerAdapter</code>使用。这是我们最常用的组合。</p><p>​处理异常的逻辑如下，这里会优先查找<code>controller</code>里面的<code>@ExceptionHandler</code>注解标注的方法，如果没有则使用全局<code>@ControllerAdvice</code>里面的<code>@ExceptionHandler</code>标记的全局处理函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title function_">doResolveHandlerMethodException</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">HttpServletResponse response, HandlerMethod handlerMethod, Exception exception)</span> &#123;<br><span class="hljs-comment">//查找该异常类型对应的处理函数</span><br><span class="hljs-type">ServletInvocableHandlerMethod</span> <span class="hljs-variable">exceptionHandlerMethod</span> <span class="hljs-operator">=</span> getExceptionHandlerMethod(handlerMethod, exception);<br><span class="hljs-keyword">if</span> (exceptionHandlerMethod == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">//这里设置了参数处理器，和返回值处理器exceptionHandlerMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);exceptionHandlerMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);</span><br><br><span class="hljs-type">ServletWebRequest</span> <span class="hljs-variable">webRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletWebRequest</span>(request, response);<br><span class="hljs-type">ModelAndViewContainer</span> <span class="hljs-variable">mavContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndViewContainer</span>();<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//开始回掉异常处理函数</span><br>exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception);<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception invocationEx) &#123;<br>logger.error(<span class="hljs-string">&quot;Failed to invoke @ExceptionHandler method: &quot;</span> + exceptionHandlerMethod, invocationEx);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (mavContainer.isRequestHandled()) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>();<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mav</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>().addAllObjects(mavContainer.getModel());<br>mav.setViewName(mavContainer.getViewName());<br><span class="hljs-keyword">if</span> (!mavContainer.isViewReference()) &#123;<br>mav.setView((View) mavContainer.getView());<br>&#125;<br><span class="hljs-keyword">return</span> mav;<br>&#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">protected</span> ServletInvocableHandlerMethod <span class="hljs-title function_">getExceptionHandlerMethod</span><span class="hljs-params">(HandlerMethod handlerMethod, Exception exception)</span> &#123;<br>    <span class="hljs-comment">//优先解析类里面的处理函数</span><br><span class="hljs-keyword">if</span> (handlerMethod != <span class="hljs-literal">null</span>) &#123;<br>Class&lt;?&gt; handlerType = handlerMethod.getBeanType();<br><span class="hljs-type">ExceptionHandlerMethodResolver</span> <span class="hljs-variable">resolver</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.exceptionHandlerCache.get(handlerType);<br><span class="hljs-keyword">if</span> (resolver == <span class="hljs-literal">null</span>) &#123;<br>resolver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionHandlerMethodResolver</span>(handlerType);<br><span class="hljs-built_in">this</span>.exceptionHandlerCache.put(handlerType, resolver);<br>&#125;<br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> resolver.resolveMethod(exception);<br><span class="hljs-keyword">if</span> (method != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletInvocableHandlerMethod</span>(handlerMethod.getBean(), method);<br>&#125;<br>&#125;<br>    <span class="hljs-comment">//其次查找全局的处理函数</span><br><span class="hljs-keyword">for</span> (Entry&lt;ControllerAdviceBean, ExceptionHandlerMethodResolver&gt; entry : <span class="hljs-built_in">this</span>.exceptionHandlerAdviceCache.entrySet()) &#123;<br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> entry.getValue().resolveMethod(exception);<br><span class="hljs-keyword">if</span> (method != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletInvocableHandlerMethod</span>(entry.getKey().resolveBean(), method);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​</p><p>​还有一点，<code>@ExceptionHandler</code>注解能添加<code>exception</code>类型的<code>value</code>值，只有匹配的异常类型才会使用此函数处理。如果没有在注解上标识能处理那种异常，则会解析方法的参数，参数中存在哪种异常就处理哪种。所以下面两种写法是等同的。</p><p>​如果同时存在，则以注解上的为准。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">exception</span><span class="hljs-params">(RuntimeException e)</span> &#123;<br><span class="hljs-keyword">return</span> e.getMessage();<br>&#125;<br><br><span class="hljs-meta">@ExceptionHandler(value = RuntimeException.class)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">exception</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​还有一种常用的用法，用于接口的异常处理中，返回值是需要转成<code>Json</code>形式的，这里要在处理器上添加<code>@ResponseBody</code>注解，并且返回值是一个可以序列化成<code>Json</code>的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> JsonResource <span class="hljs-title function_">exception</span><span class="hljs-params">(Exception e)</span> &#123;<br><span class="hljs-keyword">return</span> JsonResource.ofFail(e.toString());<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​这种情况下需要配置返回值处理器，查看<code>ExceptionHandlerExceptionResolver</code>内的代码，其在初始化方法里初始化了<code>returnValueHandlers</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.argumentResolvers == <span class="hljs-literal">null</span>) &#123;<br>List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();<br><span class="hljs-built_in">this</span>.argumentResolvers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerMethodArgumentResolverComposite</span>().addResolvers(resolvers);<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.returnValueHandlers == <span class="hljs-literal">null</span>) &#123;<br>List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();<br><span class="hljs-built_in">this</span>.returnValueHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerMethodReturnValueHandlerComposite</span>().addHandlers(handlers);<br>&#125;<br>initExceptionHandlerAdviceCache();<br>&#125;<br><br><br><span class="hljs-keyword">protected</span> List&lt;HandlerMethodReturnValueHandler&gt; <span class="hljs-title function_">getDefaultReturnValueHandlers</span><span class="hljs-params">()</span> &#123;<br>List&lt;HandlerMethodReturnValueHandler&gt; handlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;HandlerMethodReturnValueHandler&gt;();<br><br><span class="hljs-comment">// Single-purpose return value types</span><br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndViewMethodReturnValueHandler</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelMethodProcessor</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewMethodReturnValueHandler</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpEntityMethodProcessor</span>(getMessageConverters(), <span class="hljs-built_in">this</span>.contentNegotiationManager));<br><br><span class="hljs-comment">// Annotation-based return value types</span><br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAttributeMethodProcessor</span>(<span class="hljs-literal">false</span>));<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestResponseBodyMethodProcessor</span>(getMessageConverters(), <span class="hljs-built_in">this</span>.contentNegotiationManager));<br><br><span class="hljs-comment">// Multi-purpose return value types</span><br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewNameMethodReturnValueHandler</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MapMethodProcessor</span>());<br><br><span class="hljs-comment">// Custom return value types</span><br><span class="hljs-keyword">if</span> (getCustomReturnValueHandlers() != <span class="hljs-literal">null</span>) &#123;<br>handlers.addAll(getCustomReturnValueHandlers());<br>&#125;<br><br><span class="hljs-comment">// Catch-all</span><br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAttributeMethodProcessor</span>(<span class="hljs-literal">true</span>));<br><br><span class="hljs-keyword">return</span> handlers;<br>&#125;<br></code></pre></td></tr></table></figure><p>​<code>returnValueHandlers</code>不是本文要将的，这里说明一点<code>RequestResponseBodyMethodProcessor</code>是用来处理带有<code>@ResponseBody</code>注解的方法返回值，它的构造方法是要传入<code>MessageConverters</code>，要想将对象转成Json，需要给他配置一个<code>MappingJackson2HttpMessageConverter</code>才可以。</p><p>​</p><p>​如果是<code>xml</code>方式配置，就是下面这样。。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;messageConverters&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;stringHttpMessageConverter&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;jacksonHttpMessageConverter&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​</p><p>​使用<code>java</code>代码方式也是同理的，就是要将能处理返回值的<code>messageConverter</code>加入到<code>messageConverter</code>列表里。这里是继承它，在构造方法里加入<code>messageConverter</code>即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerExceptionResolvers</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ExceptionHandlerExceptionResolver</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HandlerExceptionResolvers</span><span class="hljs-params">()</span> &#123;<br>        getMessageConverters().add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MappingJackson2HttpMessageConverter</span>());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h4 id="一般组合"><a href="#一般组合" class="headerlink" title="一般组合"></a>一般组合</h4><p>​一般是要使用<code>ExceptionHandlerExceptionResolver</code> + <code>RequestMappingHandlerMapping</code> + <code>RequestMappingHandlerAdapter</code>这一组组合来处理请求的，<code>spring4.x</code>版本默认也是这样。</p><h4 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h4><p>​通过在方法上添加<code>@ExceptionHandler</code>注解可以将方法标记为一个异常处理器，并且在<code>Controller</code>里面写的异常处理器优先级大于<code>@ControllerAdvice</code>类里写的。</p><p>​<code>@ExceptionHandler</code>注解上或者方法参数上都可以指定能够处理的异常类型，一般写在参数里就可以。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>​异常处理的返回值会使用返回值处理器做处理，所以也需要配置返回值处理器，和配置<code>RequestMappingHandlerAdapter</code>是一样的。通用做法就是注入<code>MappingJackson2HttpMessageConverter</code>进去。</p><p>​</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>全局异常处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java web请求乱码问题</title>
    <link href="/3145821321.html"/>
    <url>/3145821321.html</url>
    
    <content type="html"><![CDATA[<h1 id="java-web请求乱码问题"><a href="#java-web请求乱码问题" class="headerlink" title="java web请求乱码问题"></a>java web请求乱码问题</h1><h2 id="1-get请求路径参数内的中文"><a href="#1-get请求路径参数内的中文" class="headerlink" title="1.get请求路径参数内的中文"></a>1.get请求路径参数内的中文</h2><p>发起请求 <code>/test?name=黄</code><br>1.因为有汉字，浏览器会将其编码为Url编码，使用哪种字符集浏览器决定，但是多数应该都是utf-8<br>2.tomcat解析此处的参数为<code>name=%E9%BB%84</code>的形式<br>3.代码调用<code>request.getParameterMap()</code> 此时会进行Url解码<br>4.tomcat将<code>name=%E9%BB%84</code>解码，使用utf-8字符集，此字符集是硬编码在代码里的。</p><p>请查看类<code>org.apache.tomcat.util.http.Parameters</code>类，此类有个字段<code>queryStringCharset</code>默认就是utf-8,默认情况下使用utf-8解析路径上的参数。</p><h2 id="2-post请求，x-www-form-urlencoded"><a href="#2-post请求，x-www-form-urlencoded" class="headerlink" title="2.post请求，x-www-form-urlencoded"></a>2.post请求，x-www-form-urlencoded</h2><p>此类型的请求体的参数是由tomcat解析的。<br>1.如果调用过<code>request.setCharacterEncoding()</code>,设置过字符集，则使用设置的。<br>2.为空的话，尝试从<code>content-type</code>里获取</p><p>​3.为空的话，尝试从<code>Context</code>上获取</p><p>​4.为空的话，返回默认<code>iso8859-1</code></p><p>tomcat内获取字符集源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">private</span> Charset <span class="hljs-title function_">getCharset</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">Charset</span> <span class="hljs-variable">charset</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">//如果设置过的返回设置的，否则尝试从content-type里获取</span><br>          charset = coyoteRequest.getCharset();<br>      &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (charset != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> charset;<br>      &#125;<br><span class="hljs-comment">//从context里获取</span><br>      <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> getContext();<br>      <span class="hljs-keyword">if</span> (context != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-type">String</span> <span class="hljs-variable">encoding</span> <span class="hljs-operator">=</span> context.getRequestCharacterEncoding();<br>          <span class="hljs-keyword">if</span> (encoding != <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-keyword">return</span> B2CConverter.getCharset(encoding);<br>              &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>                  <span class="hljs-comment">// Ignore</span><br>              &#125;<br>          &#125;<br>      &#125;<br><span class="hljs-comment">//返回默认iso8859-1</span><br>      <span class="hljs-keyword">return</span> org.apache.coyote.Constants.DEFAULT_BODY_CHARSET;<br>  &#125;<br><br><br> <span class="hljs-keyword">public</span> Charset <span class="hljs-title function_">getCharset</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException &#123;<br>     <span class="hljs-comment">//这个charset就是调用request.setCharacterEncoding()设置的</span><br>     <span class="hljs-keyword">if</span> (charset == <span class="hljs-literal">null</span>) &#123;<br>          getCharacterEncoding();<br>          <span class="hljs-keyword">if</span> (characterEncoding != <span class="hljs-literal">null</span>) &#123;<br>              charset = B2CConverter.getCharset(characterEncoding);<br>          &#125;<br>       &#125;<br><br>      <span class="hljs-keyword">return</span> charset;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCharacterEncoding</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">if</span> (characterEncoding == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">//从contentType里获取</span><br>          characterEncoding = getCharsetFromContentType(getContentType());<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> characterEncoding;<br>  &#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-post请求，form-data"><a href="#3-post请求，form-data" class="headerlink" title="3.post请求，form-data"></a>3.post请求，form-data</h2><p>​获取请求体内参数的过程和<code>x-www-form-urlencoded</code>是一样的，<br>​只是解析的方式不一样，但获取字符集过程是一样的。</p><h2 id="4-post请求体内的中文，application-json"><a href="#4-post请求体内的中文，application-json" class="headerlink" title="4.post请求体内的中文，application&#x2F;json"></a>4.post请求体内的中文，application&#x2F;json</h2><p><code>Tomcat</code>不会处理此类型的请求体，会当成<code>inputstream</code>的形式放入<code>request</code>里。</p><p><code>Controller</code>内使用<code>@RequestBody</code>接收参数，参数类型为<code>String</code>。</p><p>​</p><p>​<code>Springmvc</code>会帮我们将它映射到参数上，根据参数类型不同，映射方法也不同，如果是Pojo则会使用配置的<code>MappingJackson2HttpMessageConverter</code> 或者<code>FastJsonHttpMessageConverter</code>将流转成Pojo，现在我们讨论转成字符串的形式。</p><p>​处理参数映射时，从多个<code>MessageConverter</code>中选择一个能处理的<code>Converter</code>，因为参数是字符串，这里选择到的是<code>StringMessageConverter</code>。</p><p>在下面代码16行处，调用了<code>inputMessage.getHeaders()</code>，这里会解析出所有的请求头，且会将字符集设置到<code>content-type</code>上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters()<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; Object <span class="hljs-title function_">readWithMessageConverters</span><span class="hljs-params">(HttpInputMessage inputMessage, MethodParameter parameter,</span><br><span class="hljs-params">Type targetType)</span> <span class="hljs-keyword">throws</span> IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException &#123;<br><br>MediaType contentType;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">noContentType</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">       在这里获取过一次getHeaders</span><br><span class="hljs-comment">       如果原始的Content-Type:application/json</span><br><span class="hljs-comment">       则会被修改成 application/json;charset=request.getCharsetEncoding()</span><br><span class="hljs-comment">       */</span><br>contentType = inputMessage.getHeaders().getContentType();<br>&#125;<br><span class="hljs-keyword">catch</span> (InvalidMediaTypeException ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpMediaTypeNotSupportedException</span>(ex.getMessage());<br>&#125;<br><br><br>Class&lt;?&gt; contextClass = parameter.getContainingClass();<br>Class&lt;T&gt; targetClass = (targetType <span class="hljs-keyword">instanceof</span> Class ? (Class&lt;T&gt;) targetType : <span class="hljs-literal">null</span>);<br><br><br><span class="hljs-type">HttpMethod</span> <span class="hljs-variable">httpMethod</span> <span class="hljs-operator">=</span> (inputMessage <span class="hljs-keyword">instanceof</span> HttpRequest ? ((HttpRequest) inputMessage).getMethod() : <span class="hljs-literal">null</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> NO_VALUE;<br><br>EmptyBodyCheckingHttpInputMessage message;<br><span class="hljs-keyword">try</span> &#123;<br>message = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyBodyCheckingHttpInputMessage</span>(inputMessage);<br><br>            <span class="hljs-comment">//获取到StringMessageConverter</span><br><span class="hljs-keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="hljs-built_in">this</span>.messageConverters) &#123;<br>Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass();<br>GenericHttpMessageConverter&lt;?&gt; genericConverter =<br>(converter <span class="hljs-keyword">instanceof</span> GenericHttpMessageConverter ? (GenericHttpMessageConverter&lt;?&gt;) converter : <span class="hljs-literal">null</span>);<br><span class="hljs-keyword">if</span> (genericConverter != <span class="hljs-literal">null</span> ? genericConverter.canRead(targetType, contextClass, contentType) :<br>(targetClass != <span class="hljs-literal">null</span> &amp;&amp; converter.canRead(targetClass, contentType))) &#123;<br><span class="hljs-keyword">if</span> (message.hasBody()) &#123;<br><span class="hljs-type">HttpInputMessage</span> <span class="hljs-variable">msgToUse</span> <span class="hljs-operator">=</span><br>getAdvice().beforeBodyRead(message, parameter, targetType, converterType);<br>body = (genericConverter != <span class="hljs-literal">null</span> ? genericConverter.read(targetType, contextClass, msgToUse) :<br>((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, msgToUse));<br>body = getAdvice().afterBodyRead(body, msgToUse, parameter, targetType, converterType);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>body = getAdvice().handleEmptyBody(<span class="hljs-literal">null</span>, message, parameter, targetType, converterType);<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ex) &#123;<br><br>&#125;<br><br><span class="hljs-keyword">return</span> body;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是获取<code>Heads</code>过程，注释处将获取<code>servletRequest.getCharacterEncoding()</code>拼接在<code>content-type</code>上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> HttpHeaders <span class="hljs-title function_">getHeaders</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.headers == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.headers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHeaders</span>();<br><span class="hljs-comment">//获取到所有的请求头</span><br><span class="hljs-keyword">for</span> (Enumeration&lt;?&gt; names = <span class="hljs-built_in">this</span>.servletRequest.getHeaderNames(); names.hasMoreElements();) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">headerName</span> <span class="hljs-operator">=</span> (String) names.nextElement();<br><span class="hljs-keyword">for</span> (Enumeration&lt;?&gt; headerValues = <span class="hljs-built_in">this</span>.servletRequest.getHeaders(headerName);<br>headerValues.hasMoreElements();) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">headerValue</span> <span class="hljs-operator">=</span> (String) headerValues.nextElement();<br><span class="hljs-built_in">this</span>.headers.add(headerName, headerValue);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-comment">//如果没有字符集，则从request中获取，拼接进去</span><br><span class="hljs-keyword">if</span> (contentType != <span class="hljs-literal">null</span> &amp;&amp; contentType.getCharset() == <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-comment">//获取request上的字符集    </span><br><span class="hljs-type">String</span> <span class="hljs-variable">requestEncoding</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.servletRequest.getCharacterEncoding();<br><span class="hljs-keyword">if</span> (StringUtils.hasLength(requestEncoding)) &#123;<br><span class="hljs-type">Charset</span> <span class="hljs-variable">charSet</span> <span class="hljs-operator">=</span> Charset.forName(requestEncoding);<br>Map&lt;String, String&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedCaseInsensitiveMap</span>&lt;&gt;();<br>params.putAll(contentType.getParameters());<br>params.put(<span class="hljs-string">&quot;charset&quot;</span>, charSet.toString());<br><span class="hljs-type">MediaType</span> <span class="hljs-variable">mediaType</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MediaType</span>(contentType.getType(), contentType.getSubtype(), params);<br><span class="hljs-built_in">this</span>.headers.setContentType(mediaType);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (InvalidMediaTypeException ex) &#123;<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.headers.getContentLength() &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">requestContentLength</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.servletRequest.getContentLength();<br><span class="hljs-keyword">if</span> (requestContentLength != -<span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">this</span>.headers.setContentLength(requestContentLength);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.headers;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在<code>StringmessageConverter</code>读取数据时，会先从<code>content-type</code>中获取，再使用默认的，这里的<code>content-type</code>已经在上面被改写了。所以默认的字符集只有在没有主动调用<code>request.setCharEncoding</code>，也无法从<code>content-type</code>上获取到字符集时才会使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> String <span class="hljs-title function_">readInternal</span><span class="hljs-params">(Class&lt;? extends String&gt; clazz, HttpInputMessage inputMessage)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-type">Charset</span> <span class="hljs-variable">charset</span> <span class="hljs-operator">=</span> getContentTypeCharset(inputMessage.getHeaders().getContentType());<br><span class="hljs-keyword">return</span> StreamUtils.copyToString(inputMessage.getBody(), charset);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><hr><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>对于get请求路径上的中文字符，默认是utf-8就可以，一般不会有问题。</p><hr><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>对于post请求中的<code>form-data</code>和<code>x-www-form-urlencoded</code>，参数是由Tomcat解析的，对字符集的优先级是:</p><p><code>request.getEncoding()</code> &gt;<code> Content-Type上的</code> &gt;  <code>context.getRequestCharacterEncoding()</code> &gt; <code>默认的iso8859-1</code></p><hr><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>对于post请求是<code>application/json</code>的，解析操作由<code>Springmvc</code>处理，优先级为:</p><p><code> Content-Type上的</code>  &gt;  <code>request.getEncoding()</code> &gt; <code>StringMessageConverter指定的</code></p><hr><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>对<code>Request</code>设置字符集需要在第一次获取参数前设置才可以，所以可以添加一个<code>Filter</code>在最前面，将指定的字符集设置进去。<code>Spring</code>为我们提供了一个<code>CharacterEncodingFilter</code>来做这样的事。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>乱码问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Bean初始化过程</title>
    <link href="/1446921230.html"/>
    <url>/1446921230.html</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Bean初始化过程"><a href="#Spring-Bean初始化过程" class="headerlink" title="Spring Bean初始化过程"></a>Spring Bean初始化过程</h1><p>​本文讨论Spring容器下的Bean初始化过程。</p><p>创建SpringBoot项目，创建如下类，通过它研究Bean的初始化过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextAware</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;cat 被创建&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        System.out.println(<span class="hljs-string">&quot;aware&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>直接将断点定位到<code>org.springframework.beans.factory.support.DefaultListableBeanFactory#preInstantiateSingletons</code>方法上，执行到这里容器已经将Bean全部解析出来，然后逐个初始化，我们直接查看初始化过程。</p><p>​可以看出，他是遍历beanNames列表，逐个初始化，遍历有两个分支，下面的分支是调用<code>getBean(beanName)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>logger.trace(<span class="hljs-string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span><br><span class="hljs-comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span><br>List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">this</span>.beanDefinitionNames);<br><br><span class="hljs-comment">// Trigger initialization of all non-lazy singleton beans...</span><br><span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br><span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br><span class="hljs-keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;<br><span class="hljs-keyword">if</span> (isFactoryBean(beanName)) &#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);<br><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> FactoryBean) &#123;<br><span class="hljs-keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;<br><span class="hljs-type">boolean</span> isEagerInit;<br><span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span> &amp;&amp; factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean) &#123;<br>isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)<br>((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,<br>getAccessControlContext());<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>isEagerInit = (factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean &amp;&amp;<br>((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());<br>&#125;<br><span class="hljs-keyword">if</span> (isEagerInit) &#123;<br>getBean(beanName);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>getBean(beanName);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Trigger post-initialization callback for all applicable beans...</span><br><span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">singletonInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName);<br><span class="hljs-keyword">if</span> (singletonInstance <span class="hljs-keyword">instanceof</span> SmartInitializingSingleton) &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">SmartInitializingSingleton</span> <span class="hljs-variable">smartSingleton</span> <span class="hljs-operator">=</span> (SmartInitializingSingleton) singletonInstance;<br><span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123;<br>AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;<br>smartSingleton.afterSingletonsInstantiated();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;, getAccessControlContext());<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>smartSingleton.afterSingletonsInstantiated();<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​继续按照断点走，最后来到这里。这里要做的是,使用反射创建Bean，对Bean进行初始化。</p><p>详细解释看注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> RootBeanDefinition mbd, <span class="hljs-keyword">final</span> <span class="hljs-meta">@Nullable</span> Object[] args)</span><br><span class="hljs-keyword">throws</span> BeanCreationException &#123;<br><br><span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">//解析出beanName的类型，并通过反射new 出来 </span><br>    <span class="hljs-comment">//这里new出来的只是半成品，还没有注入属性</span><br>instanceWrapper = createBeanInstance(beanName, mbd, args);<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> instanceWrapper.getWrappedInstance();<br>Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();<br>    <span class="hljs-comment">//将此半成品添加到列表里，处理循环依赖</span><br>    <span class="hljs-comment">//假设此类是A，如果依赖B，将会去创建B，但B又依赖A，则会将这个半成品的A给B，这样B就算构造完成了（虽然给他的A是半成品），然后继续构造A，就能解决循环依赖的问题。</span><br>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br><br><span class="hljs-comment">// Initialize the bean instance.</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br><span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//在这里进行依赖注入</span><br>populateBean(beanName, mbd, instanceWrapper);<br>            <span class="hljs-comment">//这里是对bean的初始化，回掉各种aware</span><br>exposedObject = initializeBean(beanName, exposedObject, mbd);<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br><br>&#125;<br><span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>下面是初始化Bean的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">initializeBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> Object bean, <span class="hljs-meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;<br><br>    <span class="hljs-comment">//回掉BeanNameAware，BeanClassLoaderAware，BeanFactoryAware</span><br>invokeAwareMethods(beanName, bean);<br><br><span class="hljs-type">Object</span> <span class="hljs-variable">wrappedBean</span> <span class="hljs-operator">=</span> bean;<br><br>       <span class="hljs-comment">//使用ApplicationContextAwareProcessor，回掉</span><br>       <span class="hljs-comment">//EnvironmentAware，EmbeddedValueResolverAware，ResourceLoaderAware，ApplicationEventPublisherAware，MessageSourceAware，ApplicationContextAware</span><br>wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br><br><span class="hljs-comment">//回掉初始化方法</span><br>invokeInitMethods(beanName, wrappedBean, mbd);<br><br>wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br><br><br><span class="hljs-keyword">return</span> wrappedBean;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一个正常的Bean就创建完成了，这个Bean经历了</p><p>​反射创建</p><p>​依赖注入 （通过InstantiationAwareBeanPostProcessor实现的）</p><p>​回掉各种Aware</p><p>​回掉Init方法</p><h2 id="具有循环依赖的Bean的创建过程"><a href="#具有循环依赖的Bean的创建过程" class="headerlink" title="具有循环依赖的Bean的创建过程"></a>具有循环依赖的Bean的创建过程</h2><p>在Cat类里，注入People类，同样的创建一个People类，注入Cat类。People类省略了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>  &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;cat 被创建&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> People people;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPeople</span><span class="hljs-params">(People people)</span> &#123;<br>        <span class="hljs-built_in">this</span>.people = people;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>再看<code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor</code></p><p>的下面方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> PropertyValues <span class="hljs-title function_">postProcessProperties</span><span class="hljs-params">(PropertyValues pvs, Object bean, String beanName)</span> &#123;<br>       <span class="hljs-comment">//发现需要注入的方法或字段</span><br><span class="hljs-type">InjectionMetadata</span> <span class="hljs-variable">metadata</span> <span class="hljs-operator">=</span> findAutowiringMetadata(beanName, bean.getClass(), pvs);<br><span class="hljs-keyword">try</span> &#123;<br>metadata.inject(bean, beanName, pvs);<br>&#125;<br><span class="hljs-keyword">catch</span> (BeanCreationException ex) &#123;<br><span class="hljs-keyword">throw</span> ex;<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(beanName, <span class="hljs-string">&quot;Injection of autowired dependencies failed&quot;</span>, ex);<br>&#125;<br><span class="hljs-keyword">return</span> pvs;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inject</span><span class="hljs-params">(Object target, <span class="hljs-meta">@Nullable</span> String beanName, <span class="hljs-meta">@Nullable</span> PropertyValues pvs)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>Collection&lt;InjectedElement&gt; checkedElements = <span class="hljs-built_in">this</span>.checkedElements;<br>Collection&lt;InjectedElement&gt; elementsToIterate =<br>(checkedElements != <span class="hljs-literal">null</span> ? checkedElements : <span class="hljs-built_in">this</span>.injectedElements);<br><span class="hljs-keyword">if</span> (!elementsToIterate.isEmpty()) &#123;<br><span class="hljs-keyword">for</span> (InjectedElement element : elementsToIterate) &#123;<br>element.inject(target, beanName, pvs);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​注入的过程就是找到需要注入的方法或字段，如果是方法解析出对应的参数，让后尝试从工厂里获取参数对应的bean，如果工厂里没有，工厂就会自己创建。</p><p>​上面的示例将会走如下逻辑</p><p>​先初始化Cat -&gt;需要注入Peoper但不存在 -&gt; 创建People-&gt;People需要Cat进行注入向工厂要-&gt;工厂内已经有了Cat的实例，只是尚未初始化完成是个半成品，返回此半成品-&gt;people初始化完成 -&gt;Cat初始化完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inject</span><span class="hljs-params">(Object bean, <span class="hljs-meta">@Nullable</span> String beanName, <span class="hljs-meta">@Nullable</span> PropertyValues pvs)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><span class="hljs-keyword">if</span> (checkPropertySkipping(pvs)) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> (Method) <span class="hljs-built_in">this</span>.member;<br>Object[] arguments;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.cached) &#123;<br><span class="hljs-comment">// Shortcut for avoiding synchronization...</span><br>arguments = resolveCachedArguments(beanName);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>Class&lt;?&gt;[] paramTypes = method.getParameterTypes();<br>arguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[paramTypes.length];<br>DependencyDescriptor[] descriptors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DependencyDescriptor</span>[paramTypes.length];<br>Set&lt;String&gt; autowiredBeans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(paramTypes.length);<br>Assert.state(beanFactory != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;No BeanFactory available&quot;</span>);<br><span class="hljs-type">TypeConverter</span> <span class="hljs-variable">typeConverter</span> <span class="hljs-operator">=</span> beanFactory.getTypeConverter();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arguments.length; i++) &#123;<br><span class="hljs-type">MethodParameter</span> <span class="hljs-variable">methodParam</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodParameter</span>(method, i);<br><span class="hljs-type">DependencyDescriptor</span> <span class="hljs-variable">currDesc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DependencyDescriptor</span>(methodParam, <span class="hljs-built_in">this</span>.required);<br>currDesc.setContainingClass(bean.getClass());<br>descriptors[i] = currDesc;<br><span class="hljs-keyword">try</span> &#123;<br>                       <span class="hljs-comment">//这里解析出参数，并尝试从工厂中获取参数</span><br>                       <span class="hljs-comment">//如果工厂中不存在，则工厂会自己创建</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">arg</span> <span class="hljs-operator">=</span> beanFactory.resolveDependency(currDesc, beanName, autowiredBeans, typeConverter);<br><span class="hljs-keyword">if</span> (arg == <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-built_in">this</span>.required) &#123;<br>arguments = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>arguments[i] = arg;<br>&#125;<br><span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsatisfiedDependencyException</span>(<span class="hljs-literal">null</span>, beanName, <span class="hljs-keyword">new</span> <span class="hljs-title class_">InjectionPoint</span>(methodParam), ex);<br>&#125;<br>&#125;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.cached) &#123;<br><span class="hljs-keyword">if</span> (arguments != <span class="hljs-literal">null</span>) &#123;<br>Object[] cachedMethodArguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[paramTypes.length];<br>System.arraycopy(descriptors, <span class="hljs-number">0</span>, cachedMethodArguments, <span class="hljs-number">0</span>, arguments.length);<br>registerDependentBeans(beanName, autowiredBeans);<br><span class="hljs-keyword">if</span> (autowiredBeans.size() == paramTypes.length) &#123;<br>Iterator&lt;String&gt; it = autowiredBeans.iterator();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; paramTypes.length; i++) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">autowiredBeanName</span> <span class="hljs-operator">=</span> it.next();<br><span class="hljs-keyword">if</span> (beanFactory.containsBean(autowiredBeanName) &amp;&amp;<br>beanFactory.isTypeMatch(autowiredBeanName, paramTypes[i])) &#123;<br>cachedMethodArguments[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShortcutDependencyDescriptor</span>(<br>descriptors[i], autowiredBeanName, paramTypes[i]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">this</span>.cachedMethodArguments = cachedMethodArguments;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">this</span>.cachedMethodArguments = <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-built_in">this</span>.cached = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (arguments != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>ReflectionUtils.makeAccessible(method);<br>                   <span class="hljs-comment">//使用解析出来的参数，回掉方法</span><br>method.invoke(bean, arguments);<br>&#125;<br><span class="hljs-keyword">catch</span> (InvocationTargetException ex) &#123;<br><span class="hljs-keyword">throw</span> ex.getTargetException();<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​</p><p> 查看doGetBean方法里的getSingleton(beanName)调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; T <span class="hljs-title function_">doGetBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name, <span class="hljs-meta">@Nullable</span> <span class="hljs-keyword">final</span> Class&lt;T&gt; requiredType,</span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> <span class="hljs-keyword">final</span> Object[] args, <span class="hljs-type">boolean</span> typeCheckOnly)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> transformedBeanName(name);<br>Object bean;<br><br><span class="hljs-comment">// Eagerly check singleton cache for manually registered singletons.</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName);<br></code></pre></td></tr></table></figure><p>​</p><p>此方法将尝试获取尚未构建完成的Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-type">boolean</span> allowEarlyReference)</span> &#123;<br><span class="hljs-comment">//从单例实例map里获取</span><br>       <span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br><span class="hljs-comment">//没获取到，且当前正在循环依赖的列表里</span><br>       <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br><span class="hljs-comment">//从earlySingletonObjects列表里获取，没取不到则从singletonFactory中创建</span><br>               singletonObject = <span class="hljs-built_in">this</span>.earlySingletonObjects.get(beanName);<br><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span> &amp;&amp; allowEarlyReference) &#123;<br>ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-built_in">this</span>.singletonFactories.get(beanName);<br><span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-literal">null</span>) &#123;<br>singletonObject = singletonFactory.getObject();<br><span class="hljs-built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);<br><span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> singletonObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>什么时候将尚未初始化的Bean放入map里的呢？</p><p>​原来是创建完成后，尚未初始化前放入的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> RootBeanDefinition mbd, <span class="hljs-keyword">final</span> <span class="hljs-meta">@Nullable</span> Object[] args)</span><br><span class="hljs-keyword">throws</span> BeanCreationException &#123;<br><br><span class="hljs-comment">// Instantiate the bean.</span><br><span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>instanceWrapper = createBeanInstance(beanName, mbd, args);<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> instanceWrapper.getWrappedInstance();<br>Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();<br><span class="hljs-comment">//在这里半成品的Bean放入singletonFactories里</span><br>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br><br><br><br><span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
      <tag>Bean初始化过程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot使用Websocket总结</title>
    <link href="/3087924092.html"/>
    <url>/3087924092.html</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot使用Websocket总结"><a href="#SpringBoot使用Websocket总结" class="headerlink" title="SpringBoot使用Websocket总结"></a>SpringBoot使用Websocket总结</h1><h2 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-写处理器"><a href="#2-写处理器" class="headerlink" title="2.写处理器"></a>2.写处理器</h2><p>写一个类实现<code>org.springframework.web.socket.WebSocketHandler</code>，</p><p>更推荐继承<code>org.springframework.web.socket.handler.AbstractWebSocketHandler</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractWebSocketHandler</span> &#123;<br><br>    <span class="hljs-comment">//处理textmessage</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleTextMessage</span><span class="hljs-params">(WebSocketSession session, TextMessage message)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-built_in">super</span>.handleTextMessage(session, message);<br>    &#125;<br><br>    <span class="hljs-comment">//处理binarymessage</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleBinaryMessage</span><span class="hljs-params">(WebSocketSession session, BinaryMessage message)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-built_in">super</span>.handleBinaryMessage(session, message);<br>    &#125;<br><br>    <span class="hljs-comment">//处理pong</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlePongMessage</span><span class="hljs-params">(WebSocketSession session, PongMessage message)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-built_in">super</span>.handlePongMessage(session, message);<br>    &#125;<br><br>    <span class="hljs-comment">//报错时</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleTransportError</span><span class="hljs-params">(WebSocketSession session, Throwable exception)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-built_in">super</span>.handleTransportError(session, exception);<br>    &#125;<br><br>    <span class="hljs-comment">//连接关闭时</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterConnectionClosed</span><span class="hljs-params">(WebSocketSession session, CloseStatus status)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-built_in">super</span>.afterConnectionClosed(session, status);<br>    &#125;<br><br>    <span class="hljs-comment">//连接成功时</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterConnectionEstablished</span><span class="hljs-params">(WebSocketSession session)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-built_in">super</span>.afterConnectionEstablished(session);<br>    &#125;<br><br>    <span class="hljs-comment">//是否支持报文拆包</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supportsPartialMessages</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.supportsPartialMessages();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-配置路径和拦截器"><a href="#3-配置路径和拦截器" class="headerlink" title="3.配置路径和拦截器"></a>3.配置路径和拦截器</h2><p>​在一个<code>Configuration</code>类上，添加<code>EnableWebSocket</code>注解启动<code>Websocket</code>。</p><p>​注入<code>WebSocketConfigurer</code>的<code>Bean</code>即可启动<code>websocket</code>服务端。</p><p>​<code>addInterceptors</code>方法是添加拦截器，这个拦截器拦截在<code>http</code>协议转向<code>websocket</code>的那个请求上，如果底层使用的是<code>servlet</code>可以强转成<code>ServletServerHttpRequest</code>，在这里能拿到<code>websocket</code>连接时携带的<code>param</code>和<code>head</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebSocket</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebsocketConfig</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(WebsocketConfig.class);<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> WebSocketConfigurer <span class="hljs-title function_">wsc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> registry -&gt; registry.addHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestHandler</span>(), <span class="hljs-string">&quot;/websocket/test&quot;</span>)<br>                .addInterceptors(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HandshakeInterceptor</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">beforeHandshake</span><span class="hljs-params">(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attributes)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        <span class="hljs-type">ServletServerHttpRequest</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> (ServletServerHttpRequest) request;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterHandshake</span><span class="hljs-params">(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Exception exception)</span> &#123;<br><br>                    &#125;<br>                &#125;).setAllowedOrigins(<span class="hljs-string">&quot;*&quot;</span>);<br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-技巧"><a href="#4-技巧" class="headerlink" title="4.技巧"></a>4.技巧</h2><ol><li><p>拦截器返回<code>false</code>，则不会进行<code>websocket</code>协议的转换，如必须要登录才能连接的情况，可以在拦截器里拿到请求<code>session_id</code>来判断,也可以获取参数判断。</p></li><li><p>拦截器里的第三个参数，是一个<code>map</code>，放入此<code>map</code>的值可以从<code>WebSocketHandler</code>里面的<code>WebSocketSession</code>身上拿出来。</p></li><li><p><code>supportsPartialMessages</code>回调方法是决定是否接受半包，因为<code>websocket</code>协议比较底层，好像<code>Tcp</code>协议一样，如果发送大消息可能会拆成多个小报文。如果不希望处理不完整的报文，希望底层帮忙聚合成完整消息将此方法返回<code>false</code>,这样底层会等待完整报文到达聚合后才回调。</p></li><li><p><code>WebSocketSession</code>身上能设置最大报文大小，如果报文过大则会报错的,可以将限制调大。可以在<code>afterConnectionEstablished</code>方法里对<code>WebSocketSession</code>进行设置。<code>tomcat</code>的<code>session</code>默认大小就是     <code>8*1024</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterConnectionEstablished</span><span class="hljs-params">(WebSocketSession session)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       session.setBinaryMessageSizeLimit(<span class="hljs-number">8</span> * <span class="hljs-number">1024</span>);<br>       session.setTextMessageSizeLimit(<span class="hljs-number">8</span> * <span class="hljs-number">1024</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><ol start="5"><li><p><code>WebSocketSession</code>是不支持并发发送消息的，要么自己做同步，要么包装<code>WebSocketSession</code>为<code>ConcurrentWebSocketSessionDecorator</code>，关于<code>ConcurrentWebSocketSessionDecorator</code>的使用可以参考<a href="/2020/06/07/Spring%E5%B9%B6%E5%8F%91%E5%8F%91%E9%80%81Websocket%E6%B6%88%E6%81%AF/">Spring并发发送Websocket消息</a>。</p></li><li><p><code>setAllowedOrigins(&quot;*&quot;)</code>为控制跨域的，测试阶段可以设成<code>*</code>,不然不允许跨域链接<code>Websocket</code>。</p></li><li><p>百度搜<code>在线websocket</code>，有在线连接<code>Websocket</code>的网站，这样后端自己做测试比较方便。</p></li></ol></li></ol><h2 id="5-原理"><a href="#5-原理" class="headerlink" title="5.原理"></a>5.原理</h2><p><code>EnableWebSocket</code>引入了<code>DelegatingWebSocketConfiguration</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Import(DelegatingWebSocketConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableWebSocket &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p><p>先看<code>DelegatingWebSocketConfiguration</code>这个类。首先类被构造后，会自动注入<code>WebSocketConfigurer</code>，这个就是我们配置的<code>Bean</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired(required = false)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setConfigurers</span><span class="hljs-params">(List&lt;WebSocketConfigurer&gt; configurers)</span> &#123;<br><span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;<br><span class="hljs-built_in">this</span>.configurers.addAll(configurers);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后父类会注入一个<code>HandlerMapping</code>，会创建一个<code>ServletWebSocketHandlerRegistry</code>，调用所有的</p><p><code>configurer.registerWebSocketHandlers(registry);</code>方法进行配置。</p><p>最后从<code>registry.getHandlerMapping()</code>获取<code>HandlerMapping</code>，这个<code>HandlerMapping</code>最终会注册到<code>Springmvc</code>里，接受到请求时会使用该<code>HandlerMapping</code>来处理请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> HandlerMapping <span class="hljs-title function_">webSocketHandlerMapping</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">ServletWebSocketHandlerRegistry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> initHandlerRegistry();<br><span class="hljs-keyword">if</span> (registry.requiresTaskScheduler()) &#123;<br><span class="hljs-type">TaskScheduler</span> <span class="hljs-variable">scheduler</span> <span class="hljs-operator">=</span> defaultSockJsTaskScheduler();<br>Assert.notNull(scheduler, <span class="hljs-string">&quot;Expected default TaskScheduler bean&quot;</span>);<br>registry.setTaskScheduler(scheduler);<br>&#125;<br>       <span class="hljs-comment">//使用我们的配置，构造出HandlerMapping</span><br><span class="hljs-keyword">return</span> registry.getHandlerMapping();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ServletWebSocketHandlerRegistry <span class="hljs-title function_">initHandlerRegistry</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.handlerRegistry == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.handlerRegistry = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletWebSocketHandlerRegistry</span>();<br>registerWebSocketHandlers(<span class="hljs-built_in">this</span>.handlerRegistry);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.handlerRegistry;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerWebSocketHandlers</span><span class="hljs-params">(WebSocketHandlerRegistry registry)</span> &#123;<br><span class="hljs-keyword">for</span> (WebSocketConfigurer configurer : <span class="hljs-built_in">this</span>.configurers) &#123;<br>configurer.registerWebSocketHandlers(registry);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是获取<code>HandlerMapping</code>的过程</p><p>​这里会创建一个<code>WebSocketHandlerMapping</code>，并设置<code>urlMap</code>，<code>urlMap</code>里面存放的是url 和对应的<code>HttpRequestHandle</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> AbstractHandlerMapping <span class="hljs-title function_">getHandlerMapping</span><span class="hljs-params">()</span> &#123;<br>Map&lt;String, Object&gt; urlMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (ServletWebSocketHandlerRegistration registration : <span class="hljs-built_in">this</span>.registrations) &#123;<br>MultiValueMap&lt;HttpRequestHandler, String&gt; mappings = registration.getMappings();<br>mappings.forEach((httpHandler, patterns) -&gt; &#123;<br><span class="hljs-keyword">for</span> (String pattern : patterns) &#123;<br>urlMap.put(pattern, httpHandler);<br>&#125;<br>&#125;);<br>&#125;<br>       <br><span class="hljs-type">WebSocketHandlerMapping</span> <span class="hljs-variable">hm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketHandlerMapping</span>();<br>hm.setUrlMap(urlMap);<br>hm.setOrder(<span class="hljs-built_in">this</span>.order);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.urlPathHelper != <span class="hljs-literal">null</span>) &#123;<br>hm.setUrlPathHelper(<span class="hljs-built_in">this</span>.urlPathHelper);<br>&#125;<br><span class="hljs-keyword">return</span> hm;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是将我们的配置构建成一个<code>WebSocketHttpRequestHandler</code>来处理请求，其中包含了<code>路径，拦截器，WebSocketHandler，HandshakeInterceptor，HandshakeHandler</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWebSocketHandlerMapping</span><span class="hljs-params">(MultiValueMap&lt;HttpRequestHandler, String&gt; mappings,</span><br><span class="hljs-params">WebSocketHandler webSocketHandler, HandshakeHandler handshakeHandler,</span><br><span class="hljs-params">HandshakeInterceptor[] interceptors, String path)</span> &#123;<br><br><span class="hljs-type">WebSocketHttpRequestHandler</span> <span class="hljs-variable">httpHandler</span> <span class="hljs-operator">=</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketHttpRequestHandler</span>(webSocketHandler, handshakeHandler);<br><br><span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;<br>httpHandler.setHandshakeInterceptors(Arrays.asList(interceptors));<br>&#125;<br>mappings.add(httpHandler, path);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>HandshakeHandler</code>这个类也是可以自定义的，他与协议转换有关，spring会自动根据底层实现来决定这个是什么，一般不要自己写。</p><p>​<code>HttpRequestHandle</code>处理过程如下，先调用拦截器的before，再掉用<code>HandshakeHandler</code>做协议转换，再调用拦截器的after。这里调用拦截器前创建的Map <code>attributes</code>，最终会设置到<code>WebsocketSession</code>上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(HttpServletRequest servletRequest, HttpServletResponse servletResponse)</span><br><span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br><br><span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletServerHttpRequest</span>(servletRequest);<br><span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletServerHttpResponse</span>(servletResponse);<br><br><span class="hljs-type">HandshakeInterceptorChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandshakeInterceptorChain</span>(<span class="hljs-built_in">this</span>.interceptors, <span class="hljs-built_in">this</span>.wsHandler);<br><span class="hljs-type">HandshakeFailureException</span> <span class="hljs-variable">failure</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>logger.debug(servletRequest.getMethod() + <span class="hljs-string">&quot; &quot;</span> + servletRequest.getRequestURI());<br>&#125;<br>Map&lt;String, Object&gt; attributes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <span class="hljs-comment">//调用拦截器</span><br><span class="hljs-keyword">if</span> (!chain.applyBeforeHandshake(request, response, attributes)) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>            <span class="hljs-comment">//处理握手</span><br><span class="hljs-built_in">this</span>.handshakeHandler.doHandshake(request, response, <span class="hljs-built_in">this</span>.wsHandler, attributes);<br>            <span class="hljs-comment">//再调用拦截器</span><br>chain.applyAfterHandshake(request, response, <span class="hljs-literal">null</span>);<br>&#125;<br><span class="hljs-keyword">catch</span> (HandshakeFailureException ex) &#123;<br>failure = ex;<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>failure = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandshakeFailureException</span>(<span class="hljs-string">&quot;Uncaught failure for request &quot;</span> + request.getURI(), ex);<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (failure != <span class="hljs-literal">null</span>) &#123;<br>chain.applyAfterHandshake(request, response, failure);<br>response.close();<br><span class="hljs-keyword">throw</span> failure;<br>&#125;<br>response.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是协议升级前做的操作，创建<code>StandardWebSocketSession</code>时将<code>attr</code>也就是那个拦截器里的<code>map</code>设置进去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">upgrade</span><span class="hljs-params">(ServerHttpRequest request, ServerHttpResponse response,</span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> String selectedProtocol, List&lt;WebSocketExtension&gt; selectedExtensions,</span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> Principal user, WebSocketHandler wsHandler, Map&lt;String, Object&gt; attrs)</span><br><span class="hljs-keyword">throws</span> HandshakeFailureException &#123;<br><br><span class="hljs-type">HttpHeaders</span> <span class="hljs-variable">headers</span> <span class="hljs-operator">=</span> request.getHeaders();<br><span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">localAddr</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>localAddr = request.getLocalAddress();<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception ex) &#123;<br><span class="hljs-comment">// Ignore</span><br>&#125;<br><span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">remoteAddr</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>remoteAddr = request.getRemoteAddress();<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception ex) &#123;<br><span class="hljs-comment">// Ignore</span><br>&#125;<br><span class="hljs-comment">//创建此类时将attrs作为参数传进去</span><br><span class="hljs-type">StandardWebSocketSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardWebSocketSession</span>(headers, attrs, localAddr, remoteAddr, user);<br><span class="hljs-type">StandardWebSocketHandlerAdapter</span> <span class="hljs-variable">endpoint</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardWebSocketHandlerAdapter</span>(wsHandler, session);<br><br>List&lt;Extension&gt; extensions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (WebSocketExtension extension : selectedExtensions) &#123;<br>extensions.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketToStandardExtensionAdapter</span>(extension));<br>&#125;<br><br>upgradeInternal(request, response, selectedProtocol, extensions, endpoint);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Springmvc处理过程"><a href="#Springmvc处理过程" class="headerlink" title="Springmvc处理过程"></a>Springmvc处理过程</h2><p>​在<code>DispatcherServlet</code>里面，<code>websocket</code>升级的请求是由<code>HttpRequestHandlerAdapter</code>处理的，这个类是在</p><p><code>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#httpRequestHandlerAdapter</code>方法里注册进来的。</p><p>处理过程也很简单,直接强转调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br><span class="hljs-keyword">throws</span> Exception &#123;<br><br>((HttpRequestHandler) handler).handleRequest(request, response);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
      <tag>websocket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring并发发送Websocket消息</title>
    <link href="/2107132598.html"/>
    <url>/2107132598.html</url>
    
    <content type="html"><![CDATA[<h1 id="Spring并发发送Websocket消息"><a href="#Spring并发发送Websocket消息" class="headerlink" title="Spring并发发送Websocket消息"></a>Spring并发发送Websocket消息</h1><p>​服务器的<code>Websocket</code>被客户端连接后，会创建一个<code>WebsocketSession</code>表示客户端连接，如想向客户端发送消息直接使用<code>WebsocketSession</code>发送即可。但是按照协议规范这个类是不是线程安全的，且发送过程是堵塞式的。</p><p>在此<code>Spring</code>提供一个代理类，他能处理线程安全问题，</p><p>他就是<code>org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator</code>。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>delegate</code> 需要代理的session</p><p><code>sendTimeLimit</code>  表示发送单个消息的最大时间</p><p><code>bufferSizeLimit</code>  表示发送消息的队列最大字节数，不是消息的数量而是消息的总大小</p><p><code>overflowStrategy</code>  表示大小超过限制时的策略，默认是断开连接，还有个选项就是丢弃最老的数据，直到大小满足</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentWebSocketSessionDecorator</span><span class="hljs-params">(</span><br><span class="hljs-params">WebSocketSession delegate, <span class="hljs-type">int</span> sendTimeLimit, <span class="hljs-type">int</span> bufferSizeLimit, OverflowStrategy overflowStrategy)</span> &#123;<br><br><span class="hljs-built_in">super</span>(delegate);<br><span class="hljs-built_in">this</span>.sendTimeLimit = sendTimeLimit;<br><span class="hljs-built_in">this</span>.bufferSizeLimit = bufferSizeLimit;<br><span class="hljs-built_in">this</span>.overflowStrategy = overflowStrategy;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="发送方法"><a href="#发送方法" class="headerlink" title="发送方法"></a>发送方法</h2><p>​这个方法允许多线程调用，每个线程调用此方法时会对两个标志位<code>limitExceeded</code> ， <code>closeInProgress</code>进行检测，第一个表示已超过最大限制（时间或总大小），第二个表示此session正在关闭中。</p><p>​然后将数据放入队列里，调用<code>tryFlushMessageBuffer</code>发送队列里的数据。当然只有第一个到达的线程来发送数据，后面的线程因为获取不到锁，会对线队列大小和发送时间进行检测。</p><p>​第一个获取到发送锁的线程，每次从队列里拿到一个消息，每次发送完检测标志位，因为发送过程是堵塞的，在发送期间，如果其他线程发现超时了，并不能直接打断它，而是设置<code>limitExceeded</code> 标志位为true，等待发送线程自己判断，并停止发送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(WebSocketMessage&lt;?&gt; message)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//检测标志位</span><br>    <span class="hljs-keyword">if</span> (shouldNotSend()) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//放入队列，增加大小</span><br><span class="hljs-built_in">this</span>.buffer.add(message);<br><span class="hljs-built_in">this</span>.bufferSize.addAndGet(message.getPayloadLength());<br><br><span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//尝试发送消息，因为要加锁，只有一个线程负责发送所有消息</span><br><span class="hljs-keyword">if</span> (!tryFlushMessageBuffer()) &#123;<br><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>logger.trace(String.format(<span class="hljs-string">&quot;Another send already in progress: &quot;</span> +<br><span class="hljs-string">&quot;session id &#x27;%s&#x27;:, \&quot;in-progress\&quot; send time %d (ms), buffer size %d bytes&quot;</span>,<br>getId(), getTimeSinceSendStarted(), getBufferSize()));<br>&#125;<br>            <span class="hljs-comment">//没获取锁的线程，对当前buffer和时间检测</span><br>checkSessionLimits();<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.buffer.isEmpty() &amp;&amp; !shouldNotSend());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldNotSend</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.limitExceeded || <span class="hljs-built_in">this</span>.closeInProgress);<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryFlushMessageBuffer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <br>   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.flushLock.tryLock()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//死循环发送消息</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                WebSocketMessage&lt;?&gt; message = <span class="hljs-built_in">this</span>.buffer.poll();<br>                <span class="hljs-comment">//每次发送消息前，先检测是否允许发送</span><br>                <span class="hljs-keyword">if</span> (message == <span class="hljs-literal">null</span> || shouldNotSend()) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-built_in">this</span>.bufferSize.addAndGet(-message.getPayloadLength());<br>                <span class="hljs-built_in">this</span>.sendStartTime = System.currentTimeMillis();<br>                getDelegate().sendMessage(message);<br>                <span class="hljs-built_in">this</span>.sendStartTime = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-built_in">this</span>.sendStartTime = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">this</span>.flushLock.unlock();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//检查是否超时，是否超过队列限制的部分</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkSessionLimits</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!shouldNotSend() &amp;&amp; <span class="hljs-built_in">this</span>.closeLock.tryLock()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//检测是否发送超时</span><br>            <span class="hljs-keyword">if</span> (getTimeSinceSendStarted() &gt; getSendTimeLimit()) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Send time %d (ms) for session &#x27;%s&#x27; exceeded the allowed limit %d&quot;</span>;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">reason</span> <span class="hljs-operator">=</span> String.format(format, getTimeSinceSendStarted(), getId(), getSendTimeLimit());<br>                limitExceeded(reason);<br>            &#125;<br>            <span class="hljs-comment">//检测buffer大小，根据策略要么抛异常，要么丢弃数据</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (getBufferSize() &gt; getBufferSizeLimit()) &#123;<br>                <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">this</span>.overflowStrategy) &#123;<br>                    <span class="hljs-keyword">case</span> TERMINATE:<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Buffer size %d bytes for session &#x27;%s&#x27; exceeds the allowed limit %d&quot;</span>;<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">reason</span> <span class="hljs-operator">=</span> String.format(format, getBufferSize(), getId(), getBufferSizeLimit());<br>                        limitExceeded(reason);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> DROP:<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                        <span class="hljs-keyword">while</span> (getBufferSize() &gt; getBufferSizeLimit()) &#123;<br>                            WebSocketMessage&lt;?&gt; message = <span class="hljs-built_in">this</span>.buffer.poll();<br>                            <span class="hljs-keyword">if</span> (message == <span class="hljs-literal">null</span>) &#123;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            <span class="hljs-built_in">this</span>.bufferSize.addAndGet(-message.getPayloadLength());<br>                            i++;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                            logger.debug(<span class="hljs-string">&quot;Dropped &quot;</span> + i + <span class="hljs-string">&quot; messages, buffer size: &quot;</span> + getBufferSize());<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        <span class="hljs-comment">// Should never happen..</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Unexpected OverflowStrategy: &quot;</span> + <span class="hljs-built_in">this</span>.overflowStrategy);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-built_in">this</span>.closeLock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//超过限制则抛异常</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">limitExceeded</span><span class="hljs-params">(String reason)</span> &#123;<br>    <span class="hljs-built_in">this</span>.limitExceeded = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SessionLimitExceededException</span>(reason,CloseStatus.SESSION_NOT_RELIABLE);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​上面代码能看到，一旦有一条消息发送超时，或者发送数据大于限制，<code>limitExceeded</code> 标志位就会被设置成true，标志这这个<code>session</code>被关闭，后面的发送调用都是直接返回不处理，但只是被标记为关闭连接本身可能实际上并没有关闭，这是一个坑点需要注意。可以在发送的代码里捕捉<code>SessionLimitExceededException</code>并主动关闭连接。</p>]]></content>
    
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>websocket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java的CopyOnWriteArrayList</title>
    <link href="/3390972126.html"/>
    <url>/3390972126.html</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="Java的-CopyOnWriteArrayList"><a href="#Java的-CopyOnWriteArrayList" class="headerlink" title="Java的 CopyOnWriteArrayList"></a>Java的 CopyOnWriteArrayList</h1><p>​<code>CopyOnWriteArrayList</code>会在每次更新时更换底层数组，这样你使用增强for循环或者iterator遍历时，遍历的数组一定和你第一次获取的数组相同，不会出现遍历过程中修改<code>List</code>，导致<code>List</code>混乱的问题。</p><p>查看下<code>CopyOnWriteArrayList的forEach()</code>方法：</p><p>​这个方法会获取底层数组作为局部变量保存，然后遍历此数组，并且不担心遍历期间数组被修改。</p><p>因为底层数组是只读的，每次修改都会创建新的代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; action)</span> &#123;<br>    <span class="hljs-keyword">if</span> (action == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">//获取底层数组，作为局部变量</span><br>    Object[] elements = getArray();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) elements[i];<br>        action.accept(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看下<code>Add</code>方法:</p><p>​这是add方法，它创建一个长度等于原长度+1的数组，并将底层数组切换成新创建的数组。这样其他读线程遍历期间拿到的数组不会收到影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object[] elements = getArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> elements.length;<br>        <span class="hljs-comment">//创建新的数组</span><br>        Object[] newElements = Arrays.copyOf(elements, len + <span class="hljs-number">1</span>);<br>        newElements[len] = e;<br>        <span class="hljs-comment">//将底层数组替换为这个数组，所以其他线程获取的旧数组不受影响</span><br>        setArray(newElements);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setArray</span><span class="hljs-params">(Object[] a)</span> &#123;<br>        array = a;<br>    &#125;<br></code></pre></td></tr></table></figure><p>案例，遍历集合时需要操作集合：</p><p>​这里存在一个User集合，send方法遍历集合调用<code>user.send</code>方法,但是send方法中有可能会从<code>list</code>中删除自身,这里用<code>CopyOnWriteArrayList</code>正合适，能保证所有元素都被遍历到，还能保证删除不会影响遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"> List&lt;User&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span>&#123;<br>     <span class="hljs-keyword">for</span> (User u : list) &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>             u.send(msg);<br>         &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>             list.remove(u);<br>             send(e.getMessage());<br>         &#125;<br>     &#125;<br> &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-comment">//此方法内有可能会将自己从list中删除</span><br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span> &#123;<br>         <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextBoolean()) &#123;<br>             list.remove(<span class="hljs-built_in">this</span>);<br>         &#125;<br>     &#125;<br> &#125;<br><br></code></pre></td></tr></table></figure><p>还有种场景，就是处理<code>Websocket</code>连接时，遍历每个<code>WebsocketSession</code>发送消息，如果发送失败则关闭<code>session</code>,从集合中移除，然后广播关闭信息。就有可能在遍历集合途中修改集合，再遍历集合。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>CopyOnWriteArrayList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring Xml配置枚举</title>
    <link href="/2685439725.html"/>
    <url>/2685439725.html</url>
    
    <content type="html"><![CDATA[<p>​在spring的配置文件中配置bean很简单，但某个bean中字段是枚举类型，如何注入呢。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jacksonHttpMessageConverter&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;objectMapper&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--值为null时不返回--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;serializationInclusion&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">util:constant</span> <span class="hljs-attr">static-field</span>=<span class="hljs-string">&quot;com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>上面的<code>com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL</code>就是枚举类型，可以使用这种方式注入。</p>]]></content>
    
    
    
    <tags>
      
      <tag>spring Xml配置枚举</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>上海领取医保卡社保卡</title>
    <link href="/387928542.html"/>
    <url>/387928542.html</url>
    
    <content type="html"><![CDATA[<p>​       </p><p>​医(社)保卡，就是公司给我们缴纳的五险一金里面的社保，里面有金额，可以在支付宝上实名认证后查询到金额，拿着它去看病能从里面消耗总金额一定比例的钱。</p><p>​如果公司没帮你领取，需要自己去<code>社保中心</code>领取，上海每个区都有社保中心，在地图里搜索最近的即可。</p><p>​到了社保中心，先在排号机排号等叫号，告诉工作人员领取社保卡就行，工作人员可能会核实你的公司名。需要带上身份证现场就能制作出来，卡片是磁卡上面没有芯片的那种，也没有照片不需要拍照，不需要缴费。除了一个卡片外还有一本<code>门急诊就医记录册</code>，以后用使用社保卡就医要带着这本记录册。</p><p>​领取很快，不排队的话一分钟就可以。</p>]]></content>
    
    
    
    <tags>
      
      <tag>上海领取社保卡</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聊一聊ChannelHandler里面方法被调用时机</title>
    <link href="/887461231.html"/>
    <url>/887461231.html</url>
    
    <content type="html"><![CDATA[<p>​         本文聊一聊<code>netty</code>的<code>ChannelHandler</code>里面方法被调用的时机，这里面的方法大部分都是被netty回掉的，而不是我们主动调用。</p><p>​     下面的分析都是基于<code>netty4</code>来分析，<code>netty</code>将<code>ChannelHandler</code>分为的<code>in</code>和<code>out</code>两部分。下面看他们的方法签名。</p><h1 id="方法签名"><a href="#方法签名" class="headerlink" title="方法签名"></a>方法签名</h1><h2 id="ChannelHandler："><a href="#ChannelHandler：" class="headerlink" title="ChannelHandler："></a>ChannelHandler：</h2><p><img src="/img/in/2020-04-24-%E8%81%8A%E4%B8%80%E8%81%8AChannelHandler%E9%87%8C%E9%9D%A2%E6%96%B9%E6%B3%95%E8%A2%AB%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA/image-20200424133432059.png" alt="image-20200424133432059"></p><p>​        主要就是<code>handlerAdded</code> 和 <code>handlerRemoved</code>方法，这两个方法在将<code>handler</code>添加到<code>pipline</code>和从<code>pipline</code>上移除时调用，与数据传输无关，所以放在了这个接口里面。</p><h2 id="ChannelOutboundHandler："><a href="#ChannelOutboundHandler：" class="headerlink" title="ChannelOutboundHandler："></a>ChannelOutboundHandler：</h2><p><img src="/img/in/2020-04-24-%E8%81%8A%E4%B8%80%E8%81%8AChannelHandler%E9%87%8C%E9%9D%A2%E6%96%B9%E6%B3%95%E8%A2%AB%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA/image-20200424133853407.png" alt="image-20200424133853407"></p><h2 id="ChannelInboundHandler："><a href="#ChannelInboundHandler：" class="headerlink" title="ChannelInboundHandler："></a>ChannelInboundHandler：</h2><p><img src="/img/in/2020-04-24-%E8%81%8A%E4%B8%80%E8%81%8AChannelHandler%E9%87%8C%E9%9D%A2%E6%96%B9%E6%B3%95%E8%A2%AB%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA/image-20200424134116481.png" alt="image-20200424134116481"></p><h1 id="调用逐个分析"><a href="#调用逐个分析" class="headerlink" title="调用逐个分析"></a>调用逐个分析</h1><h2 id="handlerAdded"><a href="#handlerAdded" class="headerlink" title="handlerAdded"></a>handlerAdded</h2><p>​查看<code>DefaultChannelPipeline</code>类的<code>addLast()</code>方法。这个方法会先将<code>handler</code>封装成<code>HandlerContext</code>，然后添加到<code>pipline</code>尾部，最后调用<code>callHandlerAdded0</code>方法回掉<code>handler</code>的<code>handlerAdded</code>方法。</p><p>​当发现此handler还没有registered，则将上面的操作创建成任务，等到registered后再执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title function_">addLast</span><span class="hljs-params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> &#123;<br>       <span class="hljs-keyword">final</span> AbstractChannelHandlerContext newCtx;<br>       <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>           checkMultiplicity(handler);<br><br>           newCtx = newContext(group, filterName(name, handler), handler);<br><br>           addLast0(newCtx);<br><br>           <span class="hljs-comment">// If the registered is false it means that the channel was not registered on an eventLoop yet.</span><br>           <span class="hljs-comment">// In this case we add the context to the pipeline and add a task that will call</span><br>           <span class="hljs-comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span><br>           <span class="hljs-keyword">if</span> (!registered) &#123;<br>               newCtx.setAddPending();<br>               callHandlerCallbackLater(newCtx, <span class="hljs-literal">true</span>);<br>               <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>           &#125;<br><br>           <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> newCtx.executor();<br>           <span class="hljs-keyword">if</span> (!executor.inEventLoop()) &#123;<br>               callHandlerAddedInEventLoop(newCtx, executor);<br>               <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>           &#125;<br>       &#125;<br>       callHandlerAdded0(newCtx);<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="handlerRemove"><a href="#handlerRemove" class="headerlink" title="handlerRemove"></a>handlerRemove</h2><p>​查看<code>DefaultChannelPipeline</code>的<code>remove</code>方法，会先从<code>pipline</code>链上找到<code>handler</code>对应的<code>context</code>，然后移除<code>context</code>，最后在方法<code>callHandlerRemoved0()</code>里回掉<code>handlerRemove()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> AbstractChannelHandlerContext <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext ctx)</span> &#123;<br>     <span class="hljs-keyword">assert</span> ctx != head &amp;&amp; ctx != tail;<br><br>     <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>         atomicRemoveFromHandlerList(ctx);<br><br>         <span class="hljs-comment">// If the registered is false it means that the channel was not registered on an eventloop yet.</span><br>         <span class="hljs-comment">// In this case we remove the context from the pipeline and add a task that will call</span><br>         <span class="hljs-comment">// ChannelHandler.handlerRemoved(...) once the channel is registered.</span><br>         <span class="hljs-keyword">if</span> (!registered) &#123;<br>             callHandlerCallbackLater(ctx, <span class="hljs-literal">false</span>);<br>             <span class="hljs-keyword">return</span> ctx;<br>         &#125;<br><br>         <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> ctx.executor();<br>         <span class="hljs-keyword">if</span> (!executor.inEventLoop()) &#123;<br>             executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                 <span class="hljs-meta">@Override</span><br>                 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                     callHandlerRemoved0(ctx);<br>                 &#125;<br>             &#125;);<br>             <span class="hljs-keyword">return</span> ctx;<br>         &#125;<br>     &#125;<br>     callHandlerRemoved0(ctx);<br>     <span class="hljs-keyword">return</span> ctx;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="channelRegistered"><a href="#channelRegistered" class="headerlink" title="channelRegistered"></a>channelRegistered</h2><p>查看<code>AbstractChannel</code>内部类<code>unsafe</code>的下面方法,为了看起来更清晰我将它的注释删除了，此方法会先调用<code>doRegister()</code>方法，这个方法是要求子类实现的，然后在调用<code>pipeline.fireChannelRegistered()</code>来回掉pipline链上的<code>channelRegistered()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register0</span><span class="hljs-params">(ChannelPromise promise)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">firstRegistration</span> <span class="hljs-operator">=</span> neverRegistered;<br>        <span class="hljs-comment">//真实注册子类实现此方法</span><br>        doRegister();<br>        neverRegistered = <span class="hljs-literal">false</span>;<br>        registered = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//没register之前添加到pipline上的handler，在这里真实添加</span><br>        pipeline.invokeHandlerAddedIfNeeded();<br>        safeSetSuccess(promise);<br>        <span class="hljs-comment">//回掉channelRegistered方法</span><br>        pipeline.fireChannelRegistered();<br>        <span class="hljs-keyword">if</span> (isActive()) &#123;<br>            <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>                pipeline.fireChannelActive();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config().isAutoRead()) &#123;<br>                beginRead();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        closeForcibly();<br>        closeFuture.setClosed();<br>        safeSetFailure(promise, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p><p><code>pipeline.fireChannelRegistered()</code>方法会首先调用<code>head</code>的<code>channelRegister()</code>,然后head会传递给下一个<code>inChannelHandler</code>节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title function_">fireChannelRegistered</span><span class="hljs-params">()</span> &#123;<br>    AbstractChannelHandlerContext.invokeChannelRegistered(head);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="channelActive"><a href="#channelActive" class="headerlink" title="channelActive"></a>channelActive</h2><p>​此方法在<code>channel</code>处理连接成功后回掉，如在程序内连接到其他网站，连接成功后回掉此方法。</p><p>因为只有<code>客户端channel</code>才能连接到其他服务器，<code>serverChannel</code>是被动连接的，所以此方法对<code>serverChanel</code>是无效的，但是<code>serverChannel</code>被连接时会生成的与之对应的<code>clientChannel</code>，此时会回调此方法。</p><p>​查看<code>AbstractNioChannel</code>内部类<code>unsafe</code>的下面方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-keyword">final</span> SocketAddress remoteAddress, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (connectPromise != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// Already a connect in process.</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionPendingException</span>();<br>        &#125;<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">wasActive</span> <span class="hljs-operator">=</span> isActive();<br>        <span class="hljs-comment">//进行连接，</span><br>        <span class="hljs-keyword">if</span> (doConnect(remoteAddress, localAddress)) &#123;<br>            fulfillConnectPromise(promise, wasActive);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            connectPromise = promise;<br>            requestedRemoteAddress = remoteAddress;<br><br>            <span class="hljs-comment">// Schedule connect timeout.</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">connectTimeoutMillis</span> <span class="hljs-operator">=</span> config().getConnectTimeoutMillis();<br>            <span class="hljs-keyword">if</span> (connectTimeoutMillis &gt; <span class="hljs-number">0</span>) &#123;<br>                connectTimeoutFuture = eventLoop().schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                        <span class="hljs-type">ChannelPromise</span> <span class="hljs-variable">connectPromise</span> <span class="hljs-operator">=</span> AbstractNioChannel.<span class="hljs-built_in">this</span>.connectPromise;<br>                        <span class="hljs-type">ConnectTimeoutException</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span><br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectTimeoutException</span>(<span class="hljs-string">&quot;connection timed out: &quot;</span> + remoteAddress);<br>                        <span class="hljs-keyword">if</span> (connectPromise != <span class="hljs-literal">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;<br>                            close(voidPromise());<br>                        &#125;<br>                    &#125;<br>                &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);<br>            &#125;<br><br>            promise.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    <span class="hljs-keyword">if</span> (future.isCancelled()) &#123;<br>                        <span class="hljs-keyword">if</span> (connectTimeoutFuture != <span class="hljs-literal">null</span>) &#123;<br>                            connectTimeoutFuture.cancel(<span class="hljs-literal">false</span>);<br>                        &#125;<br>                        connectPromise = <span class="hljs-literal">null</span>;<br>                        close(voidPromise());<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        promise.tryFailure(annotateConnectException(t, remoteAddress));<br>        closeIfClosed();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​此方法会调用子类的<code>doConnect()</code>方法，如果连接成功了<code>doConnect</code>返回true，如果还没连接成功，<code>doConnect</code>会注册<code>OP_CONNECT</code>事件到select里并返回false。</p><p>​如果连接成功了，此方法会调用<code>fulfillConnectPromise()</code>，这里面回掉<code>pipline的channelActive()</code>，如果没连接成功，则添加超时时间的定时任务，超时事件内还没成功就取消连接并报错，并且没连接成功会注册<code>OP_CONNECT</code>事件到select内，当程序发现连接成功时，会处理<code>CONNECT</code>事件处理方法在下面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processSelectedKey</span><span class="hljs-params">(SelectionKey k, AbstractNioChannel ch)</span> &#123;<br>    <span class="hljs-keyword">final</span> AbstractNioChannel.<span class="hljs-type">NioUnsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> ch.unsafe();<br>    <span class="hljs-keyword">if</span> (!k.isValid()) &#123;<br>        <span class="hljs-keyword">final</span> EventLoop eventLoop;<br>        <span class="hljs-keyword">try</span> &#123;<br>            eventLoop = ch.eventLoop();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ignored) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (eventLoop == <span class="hljs-built_in">this</span>) &#123;<br>            unsafe.close(unsafe.voidPromise());<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">readyOps</span> <span class="hljs-operator">=</span> k.readyOps();<br><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//在这里处理OP_CONNECT事件，调用finishConnect方法</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">ops</span> <span class="hljs-operator">=</span> k.interestOps();<br>            ops &amp;= ~SelectionKey.OP_CONNECT;<br>            k.interestOps(ops);<br><br>            unsafe.finishConnect();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="hljs-number">0</span>) &#123;<br><br>            ch.unsafe().forceFlush();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>            unsafe.read();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException ignored) &#123;<br>        unsafe.close(unsafe.voidPromise());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​遇到<code>op_connect</code>事件就是调用<code>unsafe.finishConnect()</code>方法，在这个方法里调用<code>fulfillConnectPromise</code>方法里回掉<code>channelActive</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishConnect</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Note this method is invoked by the event loop only if the connection attempt was</span><br>    <span class="hljs-comment">// neither cancelled nor timed out.</span><br><br>    <span class="hljs-keyword">assert</span> <span class="hljs-title function_">eventLoop</span><span class="hljs-params">()</span>.inEventLoop();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">wasActive</span> <span class="hljs-operator">=</span> isActive();<br>        doFinishConnect();<br>        fulfillConnectPromise(connectPromise, wasActive);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        fulfillConnectPromise(connectPromise, annotateConnectException(t, requestedRemoteAddress));<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Check for null as the connectTimeoutFuture is only created if a connectTimeoutMillis &gt; 0 is used</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/1770</span><br>        <span class="hljs-keyword">if</span> (connectTimeoutFuture != <span class="hljs-literal">null</span>) &#123;<br>            connectTimeoutFuture.cancel(<span class="hljs-literal">false</span>);<br>        &#125;<br>        connectPromise = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p>上面调用了<code>pipline.channelActive</code>里，首先找到的<code>head</code>,它的方法里有一个<code>readIfIsAutoRead()</code>,如果此<code>channel</code>设置的是自动读，他会从<code>pipline</code>的尾部<code>tail</code>开始调用<code>read</code>方法，如果我们没重写<code>read</code>方法，最终会调用到<code>head</code>的<code>read</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>      ctx.fireChannelActive();<br><br>      readIfIsAutoRead();<br>  &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readIfIsAutoRead</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">if</span> (channel.config().isAutoRead()) &#123;<br>          channel.read();<br>      &#125;<br>  &#125;<br><br>     <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ChannelPipeline <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>      tail.read();<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>最终调用到下面代码，注册<code>readInterestOp</code>事件到<code>select</code>内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beginRead</span><span class="hljs-params">()</span> &#123;<br>    assertEventLoop();<br><br>    <span class="hljs-keyword">if</span> (!isActive()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        doBeginRead();<br>    &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Exception e) &#123;<br>        invokeLater(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                pipeline.fireExceptionCaught(e);<br>            &#125;<br>        &#125;);<br>        close(voidPromise());<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.selectionKey;<br>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    readPending = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">interestOps</span> <span class="hljs-operator">=</span> selectionKey.interestOps();<br>    <span class="hljs-keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>        selectionKey.interestOps(interestOps | readInterestOp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​<code>doBeginRead</code>方法使用的<code>readInterestOp</code>并不一定是<code>op_read</code>，别被它的名称迷惑了，对于<code>客户端的channel</code>他是<code>op_read</code>，对于<code>serverChannel</code>他就是<code>op_accept</code>,是通过构造方法传进来的。</p><p>​这样对于服务器在<code>bind</code>成功后就可以<code>accept</code>了，对于<code>client</code>在<code>connect</code>成功后就可以<code>read</code>了。</p><h2 id="channelRead-和-channelReadComplate"><a href="#channelRead-和-channelReadComplate" class="headerlink" title="channelRead 和 channelReadComplate"></a>channelRead 和 channelReadComplate</h2><p>​这两个要在一起将，在客户端模式下，调用read注册<code>op_read</code>事件，下面是当有内容需要读取时的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processSelectedKey</span><span class="hljs-params">(SelectionKey k, AbstractNioChannel ch)</span> &#123;<br>    <span class="hljs-keyword">final</span> AbstractNioChannel.<span class="hljs-type">NioUnsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> ch.unsafe();<br>    <span class="hljs-keyword">if</span> (!k.isValid()) &#123;<br>        <span class="hljs-keyword">final</span> EventLoop eventLoop;<br>        <span class="hljs-keyword">try</span> &#123;<br>            eventLoop = ch.eventLoop();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ignored) &#123;<br>            <span class="hljs-comment">// If the channel implementation throws an exception because there is no event loop, we ignore this</span><br>            <span class="hljs-comment">// because we are only trying to determine if ch is registered to this event loop and thus has authority</span><br>            <span class="hljs-comment">// to close ch.</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop</span><br>        <span class="hljs-comment">// and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is</span><br>        <span class="hljs-comment">// still healthy and should not be closed.</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/5125</span><br>        <span class="hljs-keyword">if</span> (eventLoop == <span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// close the channel if the key is not valid anymore</span><br>            unsafe.close(unsafe.voidPromise());<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">readyOps</span> <span class="hljs-operator">=</span> k.readyOps();<br>        <span class="hljs-comment">// We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise</span><br>        <span class="hljs-comment">// the NIO JDK channel implementation may throw a NotYetConnectedException.</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/924</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">ops</span> <span class="hljs-operator">=</span> k.interestOps();<br>            ops &amp;= ~SelectionKey.OP_CONNECT;<br>            k.interestOps(ops);<br><br>            unsafe.finishConnect();<br>        &#125;<br><br>        <span class="hljs-comment">// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span><br>            ch.unsafe().forceFlush();<br>        &#125;<br><br> <span class="hljs-comment">// 这里可以看出当是OP_READ 或者 OP_ACCEPT时均回掉unsafe.read();</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>            unsafe.read();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException ignored) &#123;<br>        unsafe.close(unsafe.voidPromise());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里可以看出当是<code>OP_READ</code> 或者 <code>OP_ACCEPT</code>时均回掉<code>unsafe.read()</code>，虽然调用的方法名称是<code>read()</code>，但对于客户端来说是<code>read</code>数据，对于服务器来说是<code>accept</code>，处理逻辑是写在<code>unsafe</code>子类里面的，</p><p>下面先看客户端的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> config();<br>           <span class="hljs-keyword">if</span> (shouldBreakReadReady(config)) &#123;<br>               clearReadPending();<br>               <span class="hljs-keyword">return</span>;<br>           &#125;<br>           <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> pipeline();<br>           <span class="hljs-keyword">final</span> <span class="hljs-type">ByteBufAllocator</span> <span class="hljs-variable">allocator</span> <span class="hljs-operator">=</span> config.getAllocator();<br>           <span class="hljs-keyword">final</span> RecvByteBufAllocator.<span class="hljs-type">Handle</span> <span class="hljs-variable">allocHandle</span> <span class="hljs-operator">=</span> recvBufAllocHandle();<br>           allocHandle.reset(config);<br><br>           <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">close</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>           <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-keyword">do</span> &#123;<br>                   byteBuf = allocHandle.allocate(allocator);<br>                   allocHandle.lastBytesRead(doReadBytes(byteBuf));<br>                   <span class="hljs-keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="hljs-number">0</span>) &#123;<br>                       <span class="hljs-comment">// nothing was read. release the buffer.</span><br>                       byteBuf.release();<br>                       byteBuf = <span class="hljs-literal">null</span>;<br>                       close = allocHandle.lastBytesRead() &lt; <span class="hljs-number">0</span>;<br>                       <span class="hljs-keyword">if</span> (close) &#123;<br>                           <span class="hljs-comment">// There is nothing left to read as we received an EOF.</span><br>                           readPending = <span class="hljs-literal">false</span>;<br>                       &#125;<br>                       <span class="hljs-keyword">break</span>;<br>                   &#125;<br><br>                   allocHandle.incMessagesRead(<span class="hljs-number">1</span>);<br>                   readPending = <span class="hljs-literal">false</span>;<br>                   pipeline.fireChannelRead(byteBuf);<br>                   byteBuf = <span class="hljs-literal">null</span>;<br>               &#125; <span class="hljs-keyword">while</span> (allocHandle.continueReading());<br><br>               allocHandle.readComplete();<br>               pipeline.fireChannelReadComplete();<br><br>               <span class="hljs-keyword">if</span> (close) &#123;<br>                   closeOnRead(pipeline);<br>               &#125;<br>           &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>               handleReadException(pipeline, byteBuf, t, close, allocHandle);<br>           &#125; <span class="hljs-keyword">finally</span> &#123;<br>               <span class="hljs-comment">// Check if there is a readPending which was not processed yet.</span><br>               <span class="hljs-comment">// This could be for two reasons:</span><br>               <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span><br>               <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span><br>               <span class="hljs-comment">//</span><br>               <span class="hljs-comment">// See https://github.com/netty/netty/issues/2254</span><br>               <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;<br>                   removeReadOp();<br>               &#125;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>下面是服务端的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">assert</span> <span class="hljs-title function_">eventLoop</span><span class="hljs-params">()</span>.inEventLoop();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> config();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> pipeline();<br>        <span class="hljs-keyword">final</span> RecvByteBufAllocator.<span class="hljs-type">Handle</span> <span class="hljs-variable">allocHandle</span> <span class="hljs-operator">=</span> unsafe().recvBufAllocHandle();<br>        allocHandle.reset(config);<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">closed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">Throwable</span> <span class="hljs-variable">exception</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">localRead</span> <span class="hljs-operator">=</span> doReadMessages(readBuf);<br>                    <span class="hljs-keyword">if</span> (localRead == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (localRead &lt; <span class="hljs-number">0</span>) &#123;<br>                        closed = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br><br>                    allocHandle.incMessagesRead(localRead);<br>                &#125; <span class="hljs-keyword">while</span> (allocHandle.continueReading());<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                exception = t;<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> readBuf.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i ++) &#123;<br>                readPending = <span class="hljs-literal">false</span>;<br>                pipeline.fireChannelRead(readBuf.get(i));<br>            &#125;<br>            readBuf.clear();<br>            allocHandle.readComplete();<br>            pipeline.fireChannelReadComplete();<br><br>            <span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>) &#123;<br>                closed = closeOnReadError(exception);<br><br>                pipeline.fireExceptionCaught(exception);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (closed) &#123;<br>                inputShutdown = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span> (isOpen()) &#123;<br>                    close(voidPromise());<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// Check if there is a readPending which was not processed yet.</span><br>            <span class="hljs-comment">// This could be for two reasons:</span><br>            <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span><br>            <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/2254</span><br>            <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;<br>                removeReadOp();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​从代码能看出对于<code>client</code>的<code>channel</code>多次读取数据调用<code>pipeline.fireChannelRead(byteBuf)</code>,最后调用一次<code>pipeline.fireChannelReadComplete()</code>，</p><p>​对于server模式的channel，也有read方法，但它读取到的不是数据而是子连接，然后调用<code>pipline的fireChannelRead</code>方法处理子连接，具体处理逻辑在<code>ServerBootStrap</code>里面，就是对子连接进行config，然后注册到serverChannel相同的eventLoop里面。</p><h2 id="channelInactive，channelUnregistered，handlerRemoved"><a href="#channelInactive，channelUnregistered，handlerRemoved" class="headerlink" title="channelInactive，channelUnregistered，handlerRemoved"></a>channelInactive，channelUnregistered，handlerRemoved</h2><p>有很多因素会导致<code>channelInactive</code>，当连接断开，报错，主动断开等等，会依次回掉上面三个方法。</p><p>可以查看<code>pipline.close()</code>方法，逻辑不复杂，先关闭<code>java</code>的<code>channel</code>，并且从<code>select</code>中删除注册的<code>channel</code>。</p><h2 id="exceptionCaught"><a href="#exceptionCaught" class="headerlink" title="exceptionCaught"></a>exceptionCaught</h2><p>如果在某个handler内报错了，则会调用当前handler的exceptionCaught方法，默认情况下未重写方法时是继续向下查找。如果在监听器内报错了，则会调用head节点的exceptionCaught。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>​这个方法是socket作为server注册时，绑定到本地端口时使用的，查看<code>AbstractBootstrap</code>的bind方法，会调用pipline的bind方法，这属于出站消息，先调用tail的bind方法，如果没重写此方法，最终调用head的bind方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    assertEventLoop();<br><br>    <span class="hljs-keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// See: https://github.com/netty/netty/issues/576</span><br>    <span class="hljs-keyword">if</span> (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;<br>        localAddress <span class="hljs-keyword">instanceof</span> InetSocketAddress &amp;&amp;<br>        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;<br>        !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;<br>        <span class="hljs-comment">// Warn a user about the fact that a non-root user can&#x27;t receive a</span><br>        <span class="hljs-comment">// broadcast packet on *nix if the socket is bound on non-wildcard address.</span><br>        logger.warn(<br>                <span class="hljs-string">&quot;A non-root user can&#x27;t receive a broadcast packet if the socket &quot;</span> +<br>                <span class="hljs-string">&quot;is not bound to a wildcard address; binding to a non-wildcard &quot;</span> +<br>                <span class="hljs-string">&quot;address (&quot;</span> + localAddress + <span class="hljs-string">&quot;) anyway as requested.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">wasActive</span> <span class="hljs-operator">=</span> isActive();<br>    <span class="hljs-keyword">try</span> &#123;<br>        doBind(localAddress);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        safeSetFailure(promise, t);<br>        closeIfClosed();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;<br>        invokeLater(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                pipeline.fireChannelActive();<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    safeSetSuccess(promise);<br>&#125;<br></code></pre></td></tr></table></figure><p>​最终在<code>dobind</code>方法里，将<code>serverChannelbind</code>到指定端口上。</p><h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><p>​这个方法和bind方法类似，但只对于客户端的channel有效，使用<code>bootstrap</code>启动客户端连接时，最后一步会调用此方法，然后<code>bootstrap</code>就会创建<code>channel</code>，再注册到select里，再调用<code>pipline.connect()</code>方法来处理连接逻辑，如果不重写此方法，最终会在head里调用<code>unsafe.connect()</code>，实现连接。</p><p>​<strong>这里还涉及到dns解析的问题，因为connect之前要解析传入的域名为ip地址，代码在bootstrap的connect里面。</strong></p><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><p>​<code>write</code>也属于出站数据，我们一般会重写此方法来处理出站数据如加密，规范格式，自定义协议等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​以上就是<code>netty4</code>版本里面的<code>channel</code>各个方法的调用过程，了解这些方法在什么时候会被调用对学习<code>netty</code>有很大帮助，在这之前需要先弄懂<code>pipline</code>里面的链式结构，还要了解<code>java</code>原生的<code>nio</code>的用法，才能看懂<code>netty</code>里面的用法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>netty</tag>
      
      <tag>ChannelHandler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>80端口被Microsoft-HTTPAPI2.0</title>
    <link href="/327884795.html"/>
    <url>/327884795.html</url>
    
    <content type="html"><![CDATA[<p>​         在电脑上开反代，启动<code>nginx</code>提示<code>80</code>端口被占用，浏览器访问<code>localhost</code>提示<code>Microsoft-HTTPAPI2.0</code>。</p><p>不但被占用了80端口，而且是开机自启的，原因是以前在电脑上弄<code>iis</code>玩，后来也没在意。升级window系统新版本后，这个变成自动启动了，想办法停止它就行了。</p><p>做一下两步即可</p><ol><li>管理员<code>CMD</code>输入命令 <code>iisreset /stop</code> 停止iis。</li><li>window菜单栏搜索<code>iis</code>关键字，打开<code>iis管理器</code>，将里面设置的网站删除。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>window</tag>
      
      <tag>Microsoft-HTTPAPI2.0</tag>
      
      <tag>80端口被占用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot访问静态文件的原理总结</title>
    <link href="/3949548109.html"/>
    <url>/3949548109.html</url>
    
    <content type="html"><![CDATA[<p>​        上一篇写了使用<a href="https://www.huangchaoyu.com/2020/04/10/SpringBoot%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/">SpringBoot访问静态文件的几种方法</a> ,这篇文章来讲一讲配置Springboot访问静态文件的原理，为何简单配置就能实现静态文件的加载。</p><ul><li>TOC<br>{:toc}</li></ul><h2 id="我们的做法"><a href="#我们的做法" class="headerlink" title="我们的做法"></a>我们的做法</h2><p>​        我们是重写了<code>WebMvcConfigurationSupport</code>的<code>addResourceHandlers</code>方法，在<code>registry</code>内配置映射关系来实现静态文件映射的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebMvcConfigurationSupport</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//访问文件夹写法，注意文件夹路径要以file开头，以 / 结尾</span><br>        registry.addResourceHandler(<span class="hljs-string">&quot;/static/**&quot;</span>, <span class="hljs-string">&quot;/download/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;file:F:/娱乐/&quot;</span>,<span class="hljs-string">&quot;classpath:/static/&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​       </p><p>​        追踪<code>addResourceHandlers</code>的父类调用关系。是一个加了<code>@Bean</code>注解的方法调用了此方法。</p><p>​        此方法会使用我们配置的<code>registry</code>创建一个<code>HandlerMapping</code>处理，如果没配置则不会构造这个<code>HandlerMapping</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> HandlerMapping <span class="hljs-title function_">resourceHandlerMapping</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;mvcUrlPathHelper&quot;)</span> UrlPathHelper urlPathHelper,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;mvcPathMatcher&quot;)</span> PathMatcher pathMatcher,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;mvcContentNegotiationManager&quot;)</span> ContentNegotiationManager contentNegotiationManager,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;mvcConversionService&quot;)</span> FormattingConversionService conversionService,</span><br><span class="hljs-params"><span class="hljs-meta">@Qualifier(&quot;mvcResourceUrlProvider&quot;)</span> ResourceUrlProvider resourceUrlProvider)</span> &#123;<br><br>Assert.state(<span class="hljs-built_in">this</span>.applicationContext != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;No ApplicationContext set&quot;</span>);<br>Assert.state(<span class="hljs-built_in">this</span>.servletContext != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;No ServletContext set&quot;</span>);<br><br>       <span class="hljs-comment">//这个registry作参数</span><br><span class="hljs-type">ResourceHandlerRegistry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceHandlerRegistry</span>(<span class="hljs-built_in">this</span>.applicationContext,<br><span class="hljs-built_in">this</span>.servletContext, contentNegotiationManager, urlPathHelper);<br><span class="hljs-comment">//回掉我们重写的方法</span><br>       addResourceHandlers(registry);<br>       <span class="hljs-comment">//如果我们没重写，直接返回null</span><br><span class="hljs-type">AbstractHandlerMapping</span> <span class="hljs-variable">handlerMapping</span> <span class="hljs-operator">=</span> registry.getHandlerMapping();<br><span class="hljs-keyword">if</span> (handlerMapping == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>       <span class="hljs-comment">//如果重写了，能获取到HandlerMapping返回</span><br>handlerMapping.setPathMatcher(pathMatcher);<br>handlerMapping.setUrlPathHelper(urlPathHelper);<br>handlerMapping.setInterceptors(getInterceptors(conversionService, resourceUrlProvider));<br>handlerMapping.setCorsConfigurations(getCorsConfigurations());<br><span class="hljs-keyword">return</span> handlerMapping;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        构造过程，查看上面代码的<code>registry.getHandlerMapping()</code>调用。</p><p>​        他会根据我们的配置构造<code>SimpleUrlHandlerMapping</code>，这个<code>SimpleUrlHandlerMapping</code>内部保存多个<code>HttpRequestHandler</code>，将每个请求路径映射成一个<code>HttpRequestHandler</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> AbstractHandlerMapping <span class="hljs-title function_">getHandlerMapping</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.registrations.isEmpty()) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">//根据registrations，构造多个HttpRequestHandler存入urlMap里面</span><br>Map&lt;String, HttpRequestHandler&gt; urlMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (ResourceHandlerRegistration registration : <span class="hljs-built_in">this</span>.registrations) &#123;<br><span class="hljs-keyword">for</span> (String pathPattern : registration.getPathPatterns()) &#123;<br><span class="hljs-type">ResourceHttpRequestHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> registration.getRequestHandler();<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.pathHelper != <span class="hljs-literal">null</span>) &#123;<br>handler.setUrlPathHelper(<span class="hljs-built_in">this</span>.pathHelper);<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.contentNegotiationManager != <span class="hljs-literal">null</span>) &#123;<br>handler.setContentNegotiationManager(<span class="hljs-built_in">this</span>.contentNegotiationManager);<br>&#125;<br>handler.setServletContext(<span class="hljs-built_in">this</span>.servletContext);<br>handler.setApplicationContext(<span class="hljs-built_in">this</span>.applicationContext);<br><span class="hljs-keyword">try</span> &#123;<br>handler.afterPropertiesSet();<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInitializationException</span>(<span class="hljs-string">&quot;Failed to init ResourceHttpRequestHandler&quot;</span>, ex);<br>&#125;<br>urlMap.put(pathPattern, handler);<br>&#125;<br>&#125;<br>       <span class="hljs-comment">//根据urlMap里面的配置，构造SimpleUrlHandlerMapping</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleUrlHandlerMapping</span>(urlMap, <span class="hljs-built_in">this</span>.order);<br>&#125;<br></code></pre></td></tr></table></figure><p>​        </p><p>​        上面的配置将断点打到这里，查看<code>urlMap</code>里面的值,他的<code>key</code>是拦截的路径，<code>value</code>是构造的<code>ResourceHttpRequestHandler</code>，这个<code>Handler</code>里面配置的是两个路径分别是<code>/static/**</code>和<code>/download/**</code>。</p><p>​        值都是ResourceHttpRequestHandler实例，里面保存两个路径是<code>file:F:/娱乐/</code>，<code>classpath:/static/</code>。这样浏览器发送的请求如何匹配<code>/static/**</code>就会被下面的<code>handler</code>处理，去配置的两个存储位置查找资源。</p><p><img src="/img/in/2020-04-12-SpringBoot%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20200412144041449.png" alt="image-20200412144041449"></p><h2 id="何时调用HandlerMapping的"><a href="#何时调用HandlerMapping的" class="headerlink" title="何时调用HandlerMapping的"></a>何时调用HandlerMapping的</h2><p>​        将断点打在<code>Dispathervlet</code>的<code>doDispatch</code>方法上，访问 <a href="http://localhost:8080/static/2.jpg%EF%BC%8C%E7%A8%8B%E5%BA%8F%E8%BF%9B%E5%85%A5%60getHandler()%60%E6%96%B9%E6%B3%95%E9%87%8C%E3%80%82">http://localhost:8080/static/2.jpg，程序进入`getHandler()`方法里。</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> HandlerExecutionChain <span class="hljs-title function_">getHandler</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.handlerMappings != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-comment">//遍历handlerMappings列表，找到合适的HandlerMapping</span><br><span class="hljs-keyword">for</span> (HandlerMapping mapping : <span class="hljs-built_in">this</span>.handlerMappings) &#123;<br><span class="hljs-type">HandlerExecutionChain</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> mapping.getHandler(request);<br><span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> handler;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        </p><p>​        此方法内遍历的<code>handlerMapping</code>如下，他会逐个调用他们的<code>getHandler()</code>方法，这样就能找到对应的<code>ResourceHttpRequestHandler</code>处理请求了。</p><p><img src="/img/in/2020-04-12-SpringBoot%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/image-20200412145156338.png" alt="image-20200412145156338"></p><h2 id="ResourceHttpRequestHandler如何处理请求的"><a href="#ResourceHttpRequestHandler如何处理请求的" class="headerlink" title="ResourceHttpRequestHandler如何处理请求的"></a>ResourceHttpRequestHandler如何处理请求的</h2><p>​        查看<code>ResourceHttpRequestHandler</code>的<code>handleRequest</code>方法。它调用了<code>getResource(request)</code>方法获取资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span><br>      <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br><br>   <span class="hljs-comment">// 获取资源</span><br>   <span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> getResource(request);<br>   <span class="hljs-keyword">if</span> (resource == <span class="hljs-literal">null</span>) &#123;<br>      logger.debug(<span class="hljs-string">&quot;Resource not found&quot;</span>);<br>      response.sendError(HttpServletResponse.SC_NOT_FOUND);<br>      <span class="hljs-keyword">return</span>;<br>   &#125;<br>   ..... 省略<br></code></pre></td></tr></table></figure><p><code>getResource</code>方法使用了责任模式，将多个<code>location</code>封装到<code>resolverChain</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> Resource <span class="hljs-title function_">getResource</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> (String) request.getAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE);<br>path = processPath(path);<br><br>Assert.notNull(<span class="hljs-built_in">this</span>.resolverChain, <span class="hljs-string">&quot;ResourceResolverChain not initialized.&quot;</span>);<br>Assert.notNull(<span class="hljs-built_in">this</span>.transformerChain, <span class="hljs-string">&quot;ResourceTransformerChain not initialized.&quot;</span>);<br><span class="hljs-comment">//resolverChain就是责任链模式，将多个locations封装成责任链</span><br><span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.resolverChain.resolveResource(request, path, getLocations());<br><span class="hljs-keyword">if</span> (resource != <span class="hljs-literal">null</span>) &#123;<br>resource = <span class="hljs-built_in">this</span>.transformerChain.transform(request, resource);<br>&#125;<br><span class="hljs-keyword">return</span> resource;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="location的分类"><a href="#location的分类" class="headerlink" title="location的分类"></a>location的分类</h2><p><code>org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry#getHandlerMapping</code>方法内调用了<code>handler.afterPropertiesSet() </code>方法，再调用<code>resolveResourceLocations()</code>方法，此方法将配置的多个路径解析成不同的Location。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> applicationContext.getResource(location);<br></code></pre></td></tr></table></figure><p>请看下面代码，<code>location</code>有四种分别是</p><ul><li><code>ClassPathResource</code>   从classpath获取资源</li><li><code>FileUrlResource</code>       从文件获取资源</li><li><code>UrlResource</code>              从url获取资源</li><li><code>ClassPathContextResource</code>     委托给context获取资源</li></ul><p>​      下面是将字符串解析成不同<code>Location</code>的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Resource <span class="hljs-title function_">getResource</span><span class="hljs-params">(String location)</span> &#123;<br>   Assert.notNull(location, <span class="hljs-string">&quot;Location must not be null&quot;</span>);<br><br>   <span class="hljs-keyword">for</span> (ProtocolResolver protocolResolver : getProtocolResolvers()) &#123;<br>      <span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> protocolResolver.resolve(location, <span class="hljs-built_in">this</span>);<br>      <span class="hljs-keyword">if</span> (resource != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">return</span> resource;<br>      &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">if</span> (location.startsWith(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>      <span class="hljs-keyword">return</span> getResourceByPath(location);<br>   &#125;<br>   <span class="hljs-comment">//以classpath开头的，创建ClassPathResource</span><br>   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());<br>   &#125;<br>   <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">//符合URL规范的返回FileUrlResource或者UrlResource</span><br>         <span class="hljs-comment">// Try to parse the location as a URL...</span><br>         <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(location);<br>         <span class="hljs-keyword">return</span> (ResourceUtils.isFileURL(url) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileUrlResource</span>(url) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlResource</span>(url));<br>      &#125;<br>      <span class="hljs-keyword">catch</span> (MalformedURLException ex) &#123;<br>         <span class="hljs-comment">// 否则返回 ClassPathContextResource</span><br>         <span class="hljs-keyword">return</span> getResourceByPath(location);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Springboot</code>将我们配置的映射:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">registry.addResourceHandler(<span class="hljs-string">&quot;/static/**&quot;</span>, <span class="hljs-string">&quot;/download/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;file:F:/娱乐/&quot;</span>,<span class="hljs-string">&quot;classpath:/static/&quot;</span>);<br></code></pre></td></tr></table></figure><p>​        将<code>addResourceLocations</code>根据前缀解析成上面四种<code>Location</code>对象，在加上配置的路径封装成<code>ResourceHttpRequestHandler</code>用于处理请求，多个<code>ResourceHttpRequestHandler</code>封装成<code>SimpleUrlHandlerMapping</code>对象。</p><p>​        <code>DispatchServlet</code>内能查找到<code>SimpleUrlHandlerMapping</code>内的<code>ResourceHttpRequestHandler</code>处理请求。</p><p><code>ResourceHttpRequestHandler</code>将内部的<code>Location</code>组成责任链，按顺序查找资源。</p><p>​       以上就是<code>SpringBoot</code>访问静态文件的原理。</p>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>java</tag>
      
      <tag>defaultServlet</tag>
      
      <tag>springboot 静态文件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux伪随机数程序卡住</title>
    <link href="/3931547153.html"/>
    <url>/3931547153.html</url>
    
    <content type="html"><![CDATA[<p>​         在<code>linux</code>下程序卡住，但没有报错，调试发现等待几十秒会有响应。请考虑下是否用到了随机数。</p><p>在启动命令上加上 下面命令，看能否解决问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-Djava.security.egd=file:/dev/urandom<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>java</tag>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot访问静态文件的几种方法</title>
    <link href="/3775026240.html"/>
    <url>/3775026240.html</url>
    
    <content type="html"><![CDATA[<ul><li>TOC<br>{:toc}<br>​        我以前写过一个使用<code>DefaultServlet</code>实现下载的博客<a href="https://www.huangchaoyu.com/2019/10/15/springboot-%E6%B7%BB%E5%8A%A0defaultServlet%E5%AE%9E%E7%8E%B0%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/">springboot 添加defaultServlet实现更好的文件下载功能</a> ,这篇文章是对这类问题的多种解法讲解。</li></ul><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>​         将图片存储在<code>f:\\test</code>文件夹或其子文件夹下，实现访问<code>http://localhost/static/1.jpg</code>网页上展示图片，访问<code>http://localhost/download/1.jpg</code>浏览器下载图片。</p><h1 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h1><p>​        请参考这篇文章的实现， <a href="https://www.huangchaoyu.com/2019/10/15/springboot-%E6%B7%BB%E5%8A%A0defaultServlet%E5%AE%9E%E7%8E%B0%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/">springboot 添加defaultServlet实现更好的文件下载功能</a>，原理是配置一个<code>DefaultServlet</code>来处理所有静态资源请求。</p><p>​       </p><h1 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h1><p>​    原理使用<code>Controller</code>拦截掉静态资源的请求，转发到<code>DefaultServlet</code>。</p><p>​    配置<code>Controller如下</code>，使用<code>RequestMapping</code>分开配置，处理下载的<code>/download/**</code> 和处理展示的 <code>/static/**</code> 分开。</p><p>​    他们俩的唯一区别是，<code>/download/**</code> 手动设置了响应头，在此设置的<code>content-type</code>,后面就不会被设置了，否则会根据资源类型自适应<code>content-type</code>。</p><p>​    调用<code>ServletContext</code>的<code>Dispatcher</code>做转发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServletContextAware</span> &#123;<br><br><span class="hljs-comment">//拦截资源，设置响应头application/octet-stream，浏览器表现为下载</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/download/**&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">download</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        resp.setContentType(<span class="hljs-string">&quot;application/octet-stream&quot;</span>);<br>        <span class="hljs-type">RequestDispatcher</span> <span class="hljs-variable">rd</span> <span class="hljs-operator">=</span> req.getServletContext().getNamedDispatcher(<span class="hljs-string">&quot;default&quot;</span>);<br>        rd.forward(req, resp);<br>    &#125;<br><br><span class="hljs-comment">//拦截static/**，不覆盖响应头，根据类型自适应响应头</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/static/**&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticSource</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">RequestDispatcher</span> <span class="hljs-variable">rd</span> <span class="hljs-operator">=</span> req.getServletContext().getNamedDispatcher(<span class="hljs-string">&quot;default&quot;</span>);<br>        rd.forward(req, resp);<br>    &#125;<br><br>    <span class="hljs-comment">//继承ServletContextAware，此方法内配置</span><br>    <span class="hljs-comment">//文件根目录，需要删除的虚拟路径</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setServletContext</span><span class="hljs-params">(ServletContext servletContext)</span> &#123;<br>        <span class="hljs-type">WebResourceRoot</span> <span class="hljs-variable">attribute</span> <span class="hljs-operator">=</span> (WebResourceRoot) servletContext.getAttribute(Globals.RESOURCES_ATTR);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">basePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;F:\\test&quot;</span>;<br><br>        <br>        <span class="hljs-comment">//假设请求连接是 http://localhost/static/abc/123.jpg</span><br>        <span class="hljs-comment">//则实际查找路径是 F:\\test/abc/123.jpg</span><br>        <span class="hljs-comment">//相当于拿path 减去 下面的第二个参数，再拼接在basePath后面</span><br>        attribute.addPreResources(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DirResourceSet</span>(attribute, <span class="hljs-string">&quot;/static&quot;</span>, basePath, <span class="hljs-string">&quot;/&quot;</span>));<br>        attribute.addPreResources(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DirResourceSet</span>(attribute, <span class="hljs-string">&quot;/download&quot;</span>, basePath, <span class="hljs-string">&quot;/&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        上面的做法是在<code>Controller</code>里面拦截请求，再请求转发到<code>DefaultServlet</code>上，这样就不用配置<code>DefaultServlet</code>的<code>ServletMapper</code>了，使用<code>SpringMvc</code>来管理路径问题。</p><p>​        这种方法默认<code>defaultServlet</code>被配置（<code>Tomcat</code>环境下是会被配置的）。</p><h1 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h1><p>​        本方法使用<code>Spring</code>的实现，即使底层用的不是<code>Tomcat</code>，<code>Spring</code>也能将这种差异屏蔽。</p><p>​        <code>SpringBoot</code>默认会按顺序扫描以下目录的静态资源文件，这是<code>SpringBoot</code>默认配置的，默认拦截路径是<code>/**</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-string">&quot;classpath:/META-INF/resources/&quot;</span>,<br><span class="hljs-string">&quot;classpath:/resources/&quot;</span>,<br><span class="hljs-string">&quot;classpath:/static/&quot;</span>,<br><span class="hljs-string">&quot;classpath:/public/&quot;</span>,<br><span class="hljs-string">&quot;/&quot;</span><br></code></pre></td></tr></table></figure><p>​        写一个类继承<code>WebMvcConfigurationSupport</code>，实现<code>addResourceHandlers</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebMvcConfigurationSupport</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//文件写法</span><br>        registry.addResourceHandler(<span class="hljs-string">&quot;/static/**&quot;</span>, <span class="hljs-string">&quot;/download/**&quot;</span>)<br>                .addResourceLocations(<span class="hljs-string">&quot;file:F:/test/&quot;</span>);<br>        <span class="hljs-comment">//classpath 写法</span><br>        registry.addResourceHandler(<span class="hljs-string">&quot;/classpath/**&quot;</span>)<br>                .addResourceLocations(<span class="hljs-string">&quot;classpath:/static/&quot;</span>, <span class="hljs-string">&quot;classpath:/META-INF/resources/&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​     </p><p>​        <strong>要注意的点：</strong></p><ul><li><p>资源在外部文件夹下的路径写法要以<code>file:</code>开头，以<code>/</code>结尾，如<code>file:D:/test/</code></p></li><li><p>访问<code>classpath</code>的资源，路径要以<code>classpath:/</code>开头，以<code>/</code>结尾,如<code>classpath:/static/</code></p></li><li><p>访问<code>第三方jar</code>内部的静态文件，配置是<code>classpath:/META-INF/resources/</code></p></li><li><p>像下面这样配置两个相同的路径，则后面覆盖前面的。</p><ul><li><pre><code class="language-java">registry.addResourceHandler(&quot;/classpath/**&quot;).addResourceLocations(&quot;file:D:/test&quot;)                                                                 registry.addResourceHandler(&quot;/classpath/**&quot;).addResourceLocations(&quot;file:E:/zz&quot;)<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-title">- **切记不要配置成`classpath:</span>/`，这会导致`resources`文件夹暴露出来，导致配置文件泄露**<br><br><br><br>​        但是这种方法并不能实现文件下载，能识别出`content-type`的如图片会自动打开在浏览器上，不能识别的资源才会调用浏览器下载。<br><br><br><br># 关于自动配置<br><br>- 自动配置<br><br>  ​       一旦继承了`WebMvcConfigurationSupport`类，即使不重写`addResourceHandlers`类，自动配置的<span class="hljs-number">5</span>个路径就失效了。所以就不能访问静态文件了。<br><br>​       <br><br>- `swagger-ui`的静态资源<br><br>  ​     在使用`swagger-ui`时，它的原理是将`swagger-ui.html`页面打包到`springfox.swagger-ui`里面了。<br><br>  要想访问这个页面需要配置下面的路径来处理。<br><br>  ```java<br>  registry.addResourceHandler(<span class="hljs-string">&quot;/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;classpath:/META-INF/resources/&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>方法3搭配方法2</p><p>举个例子:</p><p>​        1. 将<code>/static</code>路径进行映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">registry.addResourceHandler(<span class="hljs-string">&quot;/static/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;classpath:/static/&quot;</span>);<br></code></pre></td></tr></table></figure><p>​      2. 将参数中的文件名重新<code>forward</code>，这样也能实现根据参数提供静态文件名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;file&quot;)</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(HttpServletRequest res, HttpServletResponse resp, String fileName)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>     res.getServletContext().getRequestDispatcher(<span class="hljs-string">&quot;/static/&quot;</span>+fileName).forward(res, resp);<br> &#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>java</tag>
      
      <tag>defaultServlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java rc4加密</title>
    <link href="/3883934631.html"/>
    <url>/3883934631.html</url>
    
    <content type="html"><![CDATA[<ul><li>TOC<br>{:toc}</li></ul><h2 id="本文主旨"><a href="#本文主旨" class="headerlink" title="本文主旨"></a>本文主旨</h2><p>​<code>Rc4</code>是一种对称加密方式，且属于流加密，本文讲解如何使用<code>Java</code>做<code>Rc4</code>的加密解密操作，并且讲解<code>Shadowsocks</code>是如何使用<code>Rc4</code>加密和<code>Rc4md5</code>加密的。</p><h2 id="Rc4加密解密例子"><a href="#Rc4加密解密例子" class="headerlink" title="Rc4加密解密例子"></a><code>Rc4</code>加密解密例子</h2><p><code>Rc4</code>需要一个密钥来加密。</p><p>下面这段代码演示了，如何使用<code>Java</code>自带的<code>Cipher</code>做<code>Rc4</code>加密解密。密钥使用的是随机生成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试java自带的rc4加密解密</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRc4Origin</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException &#123;<br>    <span class="hljs-comment">//随机生成20位密码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> randomString(<span class="hljs-number">20</span>);<br>    <span class="hljs-comment">//需要加密的字符串</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> randomString(<span class="hljs-number">50</span>);<br>    <span class="hljs-comment">//用于加密的</span><br>    <span class="hljs-type">Cipher</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> Cipher.getInstance(<span class="hljs-string">&quot;RC4&quot;</span>);<br>    <span class="hljs-comment">//初始化成加密模式</span><br>    encoder.init(Cipher.ENCRYPT_MODE, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(password.getBytes(), <span class="hljs-string">&quot;RC4&quot;</span>));<br><br>    <span class="hljs-comment">//用于解密的</span><br>    <span class="hljs-type">Cipher</span> <span class="hljs-variable">decoder</span> <span class="hljs-operator">=</span> Cipher.getInstance(<span class="hljs-string">&quot;RC4&quot;</span>);<br>    <span class="hljs-comment">//初始化成解密模式</span><br>    decoder.init(Cipher.DECRYPT_MODE, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(password.getBytes(), <span class="hljs-string">&quot;RC4&quot;</span>));<br><br>    <span class="hljs-comment">//密文</span><br>    <span class="hljs-type">byte</span>[] update = encoder.update(content.getBytes());<br>    <span class="hljs-comment">//解密后</span><br>    <span class="hljs-type">byte</span>[] update1 = decoder.update(update);<br><br>    <span class="hljs-comment">//加密在解密后和原文一致</span><br>    Assert.assertEquals(content, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(update1, StandardCharsets.UTF_8));<br><br>    <span class="hljs-comment">//因为是流加密，只要不关闭，encoder decoder对象可以一直使用</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">content2</span> <span class="hljs-operator">=</span> randomString(<span class="hljs-number">50</span>);<br>    <span class="hljs-comment">//密文</span><br>    <span class="hljs-type">byte</span>[] en = encoder.update(content2.getBytes());<br>    <span class="hljs-comment">//解密后</span><br>    <span class="hljs-type">byte</span>[] de = decoder.update(en);<br>    <span class="hljs-comment">//加密在解密后和原文一致</span><br>    Assert.assertEquals(content2, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(de, StandardCharsets.UTF_8));<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">randomString</span><span class="hljs-params">(<span class="hljs-type">int</span> length)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(length);<br>    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-string">&#x27;z&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>) + <span class="hljs-string">&#x27;a&#x27;</span>;<br>        sb.append((<span class="hljs-type">char</span>) rand);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Shadowsocks-使用的Rc4"><a href="#Shadowsocks-使用的Rc4" class="headerlink" title="Shadowsocks 使用的Rc4"></a><code>Shadowsocks</code> 使用的<code>Rc4</code></h2><p>​上面示例可以看出，<code>Rc4</code>是流式加密，且初始化<code>Cipher</code>时只需要传递密钥即可。<code>Shadowsocks</code>里面的<code>Rc4</code>算法和上面是一样的，使用上面的代码就能解析<code>Shadowsocks</code>发出的<code>Rc4</code>算法加密的数据。</p><p>​但在新版本里面已经移除了<code>Rc4</code>算法，因为用户经常为了方便使用弱密码，导致<code>Rc4</code>强度不足。</p><h2 id="Shadowsocks改进Rc4为Rc4Md5算法"><a href="#Shadowsocks改进Rc4为Rc4Md5算法" class="headerlink" title="Shadowsocks改进Rc4为Rc4Md5算法"></a><code>Shadowsocks</code>改进<code>Rc4</code>为<code>Rc4Md5</code>算法</h2><p>​之所以抛弃<code>Rc4</code>并不是<code>Rc4</code>本身加密强度不够，而是因为用户使用弱密码，所以只要增加密码位数就能得到安全的加密。</p><h3 id="加强密钥"><a href="#加强密钥" class="headerlink" title="加强密钥"></a>加强密钥</h3><p>​既然用户会提供弱密码，那<code>Shadowsocks</code>就想办法将密钥加强，它的做法是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">realPassWord = md5（password）<br></code></pre></td></tr></table></figure><p>​因为<code>md5</code>算法得到的<code>128bit</code>摘要数据，用作密钥要比用户自己输入的要强一些。</p><h3 id="避免特征"><a href="#避免特征" class="headerlink" title="避免特征"></a>避免特征</h3><p>​上面解决了弱密码的问题，但又有另一个问题出现了，因为密码是固定的，得到的<code>md5</code>也是固定的，也就是说每次连接使用的都是相同的密钥，这样时间长了可能被发现特征。于是有了下面的办法让每个连接使用的密码都不一样。</p><p>​解决办法是每个连接在数据流前先发送<code>16B</code>的随机值称为<code>IV值</code>，与上面得到的密钥进行混合，这样每个连接流使用的密钥就不同了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] md5IvKey(<span class="hljs-type">byte</span>[] originPassword, <span class="hljs-type">byte</span>[] iv) <span class="hljs-keyword">throws</span> NoSuchAlgorithmException &#123;<br>    <span class="hljs-type">MessageDigest</span> <span class="hljs-variable">md5</span> <span class="hljs-operator">=</span> MessageDigest.getInstance(<span class="hljs-string">&quot;md5&quot;</span>);<br>    <span class="hljs-comment">//对原始密钥取md5</span><br>    <span class="hljs-type">byte</span>[] md5Password = md5.digest(originPassword);<br>    md5.reset();<br>    <span class="hljs-comment">//重新加密密文 和 iv值得到真实密钥</span><br>    md5.update(md5Password);<br>    md5.update(iv);<br>    <span class="hljs-keyword">return</span> md5.digest();<br>&#125;<br></code></pre></td></tr></table></figure><p>​上面代码抽象就是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">realPassWord = md5(md5(password),iv);<br></code></pre></td></tr></table></figure><p>​由上是<code>Shadowsocks</code>内部的<code>Rc4md5</code>的工作原理。他是使用的<code>Rc4</code>做加密解密手段，并通过<code>md5</code>算法混合用户输入的密码+IV，每次使用的密钥都不相同，降低流量特征。</p><p>​</p><h2 id="在我们程序中借鉴此方案"><a href="#在我们程序中借鉴此方案" class="headerlink" title="在我们程序中借鉴此方案"></a>在我们程序中借鉴此方案</h2><p>​在我写的内网穿透软件中<a href="https://github.com/switchYello/rpm">rmp</a>,客户端和服务端通信需要实现加密传输，并且服务端和客户端配置相同的<code>Token</code>来验证。就可以参考上面的方式来加密数据。</p><p>​写一个<code>Rc4Md5Handler</code> 继承<code>ByteToMessageCodec</code> 来将输出数据加密，输入数据解密。&#96;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.fys.cmd.handler;<br><br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBufUtil;<br><span class="hljs-keyword">import</span> io.netty.buffer.Unpooled;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.ByteToMessageCodec;<br><br><span class="hljs-keyword">import</span> javax.crypto.Cipher;<br><span class="hljs-keyword">import</span> javax.crypto.spec.SecretKeySpec;<br><span class="hljs-keyword">import</span> java.security.SecureRandom;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> com.fys.cmd.util.CodeUtil.md5;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.nio.charset.StandardCharsets.UTF_8;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * hcy 2020/4/3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rc4Md5Handler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ByteToMessageCodec</span>&lt;ByteBuf&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SecureRandom</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureRandom</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">firstDecode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">firstEncode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">private</span> Cipher decoderCipher;<br>    <span class="hljs-keyword">private</span> Cipher encoderCipher;<br><br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Rc4Md5Handler</span><span class="hljs-params">(String password)</span> &#123;<br>        <span class="hljs-built_in">this</span>.password = password;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 第一次写数据时，生成随机IV 构建cipher</span><br><span class="hljs-comment">     * 使用cipher加密数据</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (firstEncode) &#123;<br>            <span class="hljs-type">byte</span>[] iv = randomIv();<br>            encoderCipher = Cipher.getInstance(<span class="hljs-string">&quot;RC4&quot;</span>);<br>            encoderCipher.init(Cipher.ENCRYPT_MODE, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(md5(md5(password.getBytes(UTF_8)), iv), <span class="hljs-string">&quot;RC4&quot;</span>));<br>            firstEncode = <span class="hljs-literal">false</span>;<br>            out.writeBytes(iv);<br>        &#125;<br>        out.writeBytes(encoderCipher.update(readByte(msg, msg.readableBytes())));<br>    &#125;<br><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 初次读时，前16位作为iv使用，构建cipher，以后再使用则不需要构建</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (firstDecode) &#123;<br>            <span class="hljs-type">byte</span>[] iv = readByte(in, <span class="hljs-number">16</span>);<br>            decoderCipher = Cipher.getInstance(<span class="hljs-string">&quot;RC4&quot;</span>);<br>            <span class="hljs-type">byte</span>[] realPassWord = md5(md5(password.getBytes(UTF_8)), iv);<br>            decoderCipher.init(Cipher.DECRYPT_MODE, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(realPassWord, <span class="hljs-string">&quot;RC4&quot;</span>));<br>            firstDecode = <span class="hljs-literal">false</span>;<br>        &#125;<br>        out.add(Unpooled.wrappedBuffer(decoderCipher.update(readByte(in, in.readableBytes()))));<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] readByte(ByteBuf in, <span class="hljs-type">int</span> length) &#123;<br>        <span class="hljs-type">byte</span>[] bytes = ByteBufUtil.getBytes(in, in.readerIndex(), length);<br>        in.skipBytes(bytes.length);<br>        <span class="hljs-keyword">return</span> bytes;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] randomIv() &#123;<br>        <span class="hljs-keyword">return</span> random.generateSeed(<span class="hljs-number">16</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>​将删改你的<code>Handler</code>添加到<code>server</code> 和 <code>client</code>的<code>handlerChain</code>第一位。</p><p>​上面这个<code>Handler</code>完全符合<code>Shadowsocks</code>的<code>Rc4Md5</code>加密方式，即使用户使用弱密码也能得到满足条件的加密强度。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>​</p><p>​无法识别数据流是否正确，即错误的数据流也能解密出错误的数据，但不能在第一时间发现数据是错误的。</p><p>这个问题会在<code>Shadowsocks</code>后缀为<code>GCM</code>的算法中解决。</p><p>​但是这个<code>Rc4</code>算法简单，在很多设备上都能拥有较快的处理速度。</p><h2 id="更新2020-04-13"><a href="#更新2020-04-13" class="headerlink" title="更新2020-04-13"></a>更新2020-04-13</h2><p>​        上面写的<code>handler</code>有一点没考虑清除。真实使用场景下，接收到的io数据一般是存储在直接内存里的，上面读取到数组再解密的方式需要从直接内存拷贝到堆内存，这样会影响性能的。</p><p>​        更多情况下应该使用下面这个方法方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(ByteBuffer var1, ByteBuffer var2)</span> <span class="hljs-keyword">throws</span> ShortBufferException &#123;<br></code></pre></td></tr></table></figure><p>​        直接操作<code>Bytebuf</code>，提高性能减少GC。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>netty</tag>
      
      <tag>rc4</tag>
      
      <tag>Shadowsocks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成Swagger实战</title>
    <link href="/4078226302.html"/>
    <url>/4078226302.html</url>
    
    <content type="html"><![CDATA[<ul><li>TOC<br>{:toc}</li></ul><h2 id="为什么要使用Swagger"><a href="#为什么要使用Swagger" class="headerlink" title="为什么要使用Swagger"></a>为什么要使用Swagger</h2><p>​作为后端，写完接口有时会忘记维护<code>Api</code>文档，时间长了接口文档和代码就相差甚远，导致文档难以维护且失去意义。使用<code>Swagger</code>，可以在写接口时顺便维护文档，从而接口变文档也变。并且文档页面还可以在线测试，且比手动写<code>Markdown</code>更美观。</p><p>​这篇文章将讲解如何在<code>SpringBoot</code>项目里面使用<code>Swagger</code>。</p><h2 id="1-创建Springboot项目"><a href="#1-创建Springboot项目" class="headerlink" title="1.创建Springboot项目"></a>1.创建<code>Springboot</code>项目</h2><h3 id="创建空的SpringBoot项目"><a href="#创建空的SpringBoot项目" class="headerlink" title="创建空的SpringBoot项目"></a>创建空的<code>SpringBoot</code>项目</h3><p>​使用<code>idea</code>初始化<code>SpringBoot</code>项目，因为是web项目，别忘了勾选<code>Spring Web</code>依赖。</p><p><img src="/img/in/2020-04-03-springboot%E9%9B%86%E6%88%90swagger%E5%AE%9E%E6%88%98/image-20200403132147933.png" alt="image-20200403132147933"></p><h3 id="添加controller"><a href="#添加controller" class="headerlink" title="添加controller"></a>添加<code>controller</code></h3><p>​创建一个如下增删改查的<code>Controller</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br><br>    <span class="hljs-meta">@PostMapping(&quot;create&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">create</span><span class="hljs-params">(String name, Integer age)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(&quot;delete&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(&quot;update&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name, Integer age)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;get_all&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;赵六&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试接口"><a href="#测试接口" class="headerlink" title="测试接口"></a>测试接口</h3><p>​在浏览器里顺利打开接口</p><p><img src="/img/in/2020-04-03-springboot%E9%9B%86%E6%88%90swagger%E5%AE%9E%E6%88%98/image-20200403132815065.png" alt="image-20200403132815065"></p><h2 id="2-添加Swagger"><a href="#2-添加Swagger" class="headerlink" title="2.添加Swagger"></a>2.添加<code>Swagger</code></h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="编写Swagger配置"><a href="#编写Swagger配置" class="headerlink" title="编写Swagger配置"></a>编写<code>Swagger</code>配置</h3><p>​<code>Springfox</code>需要编写一个<code>Docket</code>的<code>Bean</code>，在这个类里面做配置，下面是新建一个配置类，让<code>SpringBoot</code>扫描到这个<code>Bean</code>并注入到容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">api</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .select()<br>                .apis(RequestHandlerSelectors.any())<br>                .paths(PathSelectors.any())<br>                .build();<br><br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p><code>@EnableSwagger2</code> 就是启动<code>Swagger</code>功能。</p><h3 id="访问验证"><a href="#访问验证" class="headerlink" title="访问验证"></a>访问验证</h3><p>​浏览器访问<code>http://localhost:8080/v2/api-docs</code>,可以看到输出的一系列 <code>Json</code>，可读性太差，但是<code>Swagger</code>提供了一个可视化界面，方便我们阅读。</p><h2 id="3-添加Swagger-Ui"><a href="#3-添加Swagger-Ui" class="headerlink" title="3.添加Swagger-Ui"></a>3.添加<code>Swagger-Ui</code></h2><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>​访问<code>http://localhost:8080/swagger-ui.html</code>我们写的四个接口都在这里</p><p><img src="/img/in/2020-04-03-springboot%E9%9B%86%E6%88%90swagger%E5%AE%9E%E6%88%98/image-20200403134554617.png" alt="image-20200403134554617"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="配置文档标题和版本"><a href="#配置文档标题和版本" class="headerlink" title="配置文档标题和版本"></a>配置文档标题和版本</h4><p>​配置<code>Swagger</code>需要提供一个<code>ApiInfo</code>类描述文档标题，版本，用户名，邮箱等信息,像下面这样添加到<code>Docket</code>里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">api</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Docket</span>(DocumentationType.SWAGGER_2)<br>                .select()<br>                .apis(RequestHandlerSelectors.any())<br>                .paths(PathSelectors.any())<br>                .build().apiInfo(apiInfo());<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ApiInfo <span class="hljs-title function_">apiInfo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiInfo</span>(<span class="hljs-string">&quot;测试开发文档&quot;</span>, <span class="hljs-string">&quot;开发文档描述&quot;</span>, <span class="hljs-string">&quot;0.01&quot;</span>,<br>                <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>,<br>                <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, Collections.emptyList());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>​界面变成了这样，文档名、版本、描述都变了。</p><p><img src="/img/in/2020-04-03-springboot%E9%9B%86%E6%88%90swagger%E5%AE%9E%E6%88%98/image-20200403134110601.png" alt="image-20200403134110601"></p><h4 id="配置Controller描述"><a href="#配置Controller描述" class="headerlink" title="配置Controller描述"></a>配置Controller描述</h4><p>​类上添加注解<code>@Api</code>，并填写<code>tags</code>可以配置<code>controller</code>描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;test&quot;)</span><br><span class="hljs-meta">@Api(tags = &quot;测试相关接口&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br></code></pre></td></tr></table></figure><h4 id="配置接口名"><a href="#配置接口名" class="headerlink" title="配置接口名"></a>配置接口名</h4><p>​给方法添加注解，可以配置接口名称，添加<code> @ApiOperation</code>注解在接口方法上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(&quot;获取所有数据&quot;)</span><br><span class="hljs-meta">@GetMapping(&quot;get_all&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;赵六&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="配置参数名"><a href="#配置参数名" class="headerlink" title="配置参数名"></a>配置参数名</h4><p>​使用注解<code>@ApiImplicitParams</code>可以配置多个参数，使用注解<code>@ApiImplicitParam</code>可以配置一个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(&quot;根据id更新&quot;)</span><br><span class="hljs-meta">@ApiImplicitParams(&#123;</span><br><span class="hljs-meta">        @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户id&quot;, required = true),</span><br><span class="hljs-meta">        @ApiImplicitParam(name = &quot;name&quot;, value = &quot;用户名&quot;),</span><br><span class="hljs-meta">        @ApiImplicitParam(name = &quot;age&quot;, value = &quot;用户年龄&quot;)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">@PostMapping(&quot;update&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name, Integer age)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​<code>required</code>表示是否必填，默认是<code>false</code>。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>​页面变成了这样，<code>controller</code>变成了<code>@Api</code>标记的名称，每个接口名变成了<code>@ApiOperation</code>指定的名称，</p><p>参数描述变成了<code>@ApiImplicitParam</code>指定的<code>value</code>。</p><p><img src="/img/in/2020-04-03-springboot%E9%9B%86%E6%88%90swagger%E5%AE%9E%E6%88%98/image-20200403135331799.png" alt="image-20200403135331799"></p><h3 id="更多配置"><a href="#更多配置" class="headerlink" title="更多配置"></a>更多配置</h3><h4 id="ApiParam-注解"><a href="#ApiParam-注解" class="headerlink" title="@ApiParam 注解"></a><code>@ApiParam</code> 注解</h4><p>​除了使用<code>@ApiImplicitParam</code>外还可以使用<code>@ApiParam</code>标记参数。这样可以省去<code>name</code>属性，但是可能会让方法参数列表看起来混乱。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(&quot;根据id删除&quot;)</span><br><span class="hljs-meta">@PostMapping(&quot;delete&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-meta">@ApiParam(value = &quot;要删除的用户id&quot;, required = true)</span> <span class="hljs-type">int</span> id)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​当然这两种方式可以混合使用，只要不重复标记到同一个参数上就行。</p><h2 id="4-在线测试接口"><a href="#4-在线测试接口" class="headerlink" title="4.在线测试接口"></a>4.在线测试接口</h2><p>​找到一个接口，点击Try it out。</p><p><img src="/img/in/2020-04-03-springboot%E9%9B%86%E6%88%90swagger%E5%AE%9E%E6%88%98/image-20200403140401482.png" alt="image-20200403140401482"></p><p>​页面就会变成可编辑形式，点击Execute，就可以按照配置的参数发送请求了，并且下面会显示执行结果。</p><p><img src="/img/in/2020-04-03-springboot%E9%9B%86%E6%88%90swagger%E5%AE%9E%E6%88%98/image-20200403140446596.png" alt="image-20200403140446596"></p><h2 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5.注意事项"></a>5.注意事项</h2><h3 id="文件上传写法"><a href="#文件上传写法" class="headerlink" title="文件上传写法"></a>文件上传写法</h3><p>​有是后端需要处理上传文件，则请使用<code>@ApiParam</code>注解，不要用<code>@ApiImplicitParam</code>,这样在页面上测试时就能直接鼠标选择要上传的文件了。</p><p>​这两个注解作用于<code>MultipartFile</code>类型上的区别，读者可以亲自尝试对比下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@RequestMapping(&quot;upload&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;上传文件&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uploadFile</span><span class="hljs-params">(<span class="hljs-meta">@ApiParam(&quot;需要上传的文件&quot;)</span> MultipartFile file)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-配置资源路径"><a href="#6-配置资源路径" class="headerlink" title="6.配置资源路径"></a>6.配置资源路径</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> &#123;<br>    registry.addResourceHandler(<span class="hljs-string">&quot;/swagger-ui/**&quot;</span>).addResourceLocations(<span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/springfox-swagger-ui/&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="需要指定请求方式"><a href="#需要指定请求方式" class="headerlink" title="需要指定请求方式"></a>需要指定请求方式</h3><p>​像下面这两种指定请求Method方式都可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;upload&quot;)</span><br><span class="hljs-meta">@RequestMapping(value = &quot;upload&quot;,method = RequestMethod.GET)</span><br></code></pre></td></tr></table></figure><p>​如果不指定请求方式，<code>Swagger</code>将尝试使用所有请求方式去调用接口，文档页面看起来会很乱的。</p><p>下面<code>upload</code>接口就没指定请求方式，<code>Swagger</code>显示是这样的</p><p><img src="/img/in/2020-04-03-springboot%E9%9B%86%E6%88%90swagger%E5%AE%9E%E6%88%98/image-20200403140957368.png" alt="image-20200403140957368"></p><h2 id="7-结束语"><a href="#7-结束语" class="headerlink" title="7.结束语"></a>7.结束语</h2><p>​本文就介绍到这里，基本能满足我们的需求，我们在修改接口时，顺便修改下注解就可以。同时前端在使用接口文档时，也可以在页面上直接测试接口。</p>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>java</tag>
      
      <tag>swagger</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty利用IdleStateHandler实现pingPong</title>
    <link href="/2868684685.html"/>
    <url>/2868684685.html</url>
    
    <content type="html"><![CDATA[<p><code>IdleStateHandler</code>这个类能实现三种工作模式 <code>长时间未读</code> <code>长时间未写</code> <code>长时间未读写</code>，三种模式可以同时工作</p><p>看一下它的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">IdleStateHandler</span><span class="hljs-params">(</span><br><span class="hljs-params">         <span class="hljs-type">int</span> readerIdleTimeSeconds,</span><br><span class="hljs-params">         <span class="hljs-type">int</span> writerIdleTimeSeconds,</span><br><span class="hljs-params">         <span class="hljs-type">int</span> allIdleTimeSeconds)</span> &#123;<br><br>     <span class="hljs-built_in">this</span>(readerIdleTimeSeconds, writerIdleTimeSeconds, allIdleTimeSeconds,<br>          TimeUnit.SECONDS);<br> &#125;<br></code></pre></td></tr></table></figure><p>分别传递读超时，写超时，读写超时 的时间，当某种模式超时时会回掉下面这个方法，将事件传递过来。我们判断这个方法里的事件来判断是什么超时了。如果参数传0则表示不检测这一项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelIdle</span><span class="hljs-params">(ChannelHandlerContext ctx, IdleStateEvent evt)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       ctx.fireUserEventTriggered(evt);<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="改造成PingPongHandler"><a href="#改造成PingPongHandler" class="headerlink" title="改造成PingPongHandler"></a>改造成PingPongHandler</h3><p><code>PingPongHandler</code> 写超时时会发送<code>Ping</code>，如果一定时间没接收到<code>Pong</code>，则主动断开连接。</p><p>接收到的<code>Pong</code>除了刷新最后读时间外没有其他用处，在<code>PingPongHandler</code>后面添加一个<code>SimpleChannelInboundHandler</code>来忽略所有的Pong</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PingPongHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IdleStateHandler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(PingPongHandler.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">writeTimeOut</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">readTimeout</span> <span class="hljs-operator">=</span> writeTimeOut * <span class="hljs-number">4</span> + <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PingPongHandler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(readTimeout, writeTimeOut, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * PingPongHandler这个类，利用了IdleStateHandler定时发送ping</span><br><span class="hljs-comment">     * 但是收到的Pong如果不处理会被继续向下传播，这里添加一个SimpleChannelInboundHandler&lt;Pong&gt;在此handler后面，来丢弃所有的Pong，并且能刷新最后读取时间。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-built_in">super</span>.handlerAdded(ctx);<br>        ctx.pipeline().addAfter(ctx.name(), <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;Pong&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, Pong msg)</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;收到Pong&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 长时间没写（写超时），则主动发送ping</span><br><span class="hljs-comment">     * 长时间没读（读超时），则断开连接</span><br><span class="hljs-comment">     * */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelIdle</span><span class="hljs-params">(ChannelHandlerContext ctx, IdleStateEvent evt)</span> &#123;<br>        <span class="hljs-keyword">if</span> (evt.state() == IdleState.WRITER_IDLE) &#123;<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Ping</span>()).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;读超时断开连接：&#123;&#125;&quot;</span>, evt);<br>            ctx.flush().close();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux设置crontab定时任务</title>
    <link href="/866610002.html"/>
    <url>/866610002.html</url>
    
    <content type="html"><![CDATA[<p>本文演示如何使用<code>linux</code>的<code>crontab</code>功能定时执行脚本。</p><h2 id="cron表达式"><a href="#cron表达式" class="headerlink" title="cron表达式"></a>cron表达式</h2><p><code>linux</code>使用的是五段的<code>cron</code>表达式，分别是：</p><p>分钟，小时，天，月，星期</p><blockquote><p> 可选值</p></blockquote><p>分钟         0 - 59</p><p>小时         0 - 23</p><p>天 1 - 31</p><p>月     1 - 12</p><p>星期 1-6 0 表示周日</p><h2 id="输入-crontab-help-查看"><a href="#输入-crontab-help-查看" class="headerlink" title="输入 crontab --help 查看"></a>输入 <code>crontab --help</code> 查看</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">usage:crontab [-u user] file<br>crontab [ -u user ] [ -i ] &#123; -e | -l | -r &#125;<br>(default operation is replace, per 1003.2)<br>-e(edit user&#x27;s crontab)<br>-l(list user&#x27;s crontab)<br>-r(delete user&#x27;s crontab)<br>-i(prompt before deleting user&#x27;s crontab)<br></code></pre></td></tr></table></figure><p>可见这个命令比较简单，分别是编辑<code>crontab</code>，列出<code>crontab</code>，删除<code>crontab</code>。</p><h2 id="编辑一个测试任务"><a href="#编辑一个测试任务" class="headerlink" title="编辑一个测试任务"></a>编辑一个测试任务</h2><p>初次使用时是不存在<code>crontab</code>文件的，输入命令<code>crontab -e</code>系统让选择一个编辑器打开任务表文件，在里面输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">* * * * * echo cron exec success &gt;&gt; /home/hcy/cron.log<br></code></pre></td></tr></table></figure><p>这表示每分钟执行一次命令,将输出添加到<code>/home/hcy/cron.log</code>文件内,查看此文件内每分钟输出日志，表明我们的定时任务执行成功。</p><h2 id="打开系统默认log输出"><a href="#打开系统默认log输出" class="headerlink" title="打开系统默认log输出"></a>打开系统默认log输出</h2><p><code>ubuntu</code>默认是关闭系统<code>cron  log</code>输出的，找打<code>/etc/rsyslog.d/50-default.conf</code>找到其中的<code>#cron.* /var/log/cron.log</code> 将前面的<code>#</code>移除，然后重启 <code>service rsyslog restart</code>。</p><p>日志文件就在</p><p>Ubuntu：<code>/var/log/cron.log </code></p><p>CentOS：<code>/var/log/cron</code></p><p>在里面能看到每分钟执行的命令的日志，查看日志需要root用户才能查看。</p><h2 id="定时执行脚本"><a href="#定时执行脚本" class="headerlink" title="定时执行脚本"></a>定时执行脚本</h2><p>假设有脚本在<code>/home/hcy/autoRun.sh</code>,我们想每半小时执行一次</p><p><code>crontab -e</code> 编辑定时任务表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">0,30 * * * * sh/home/hcy/autoRun.sh &gt;&gt; /home/hcy/autoRun.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure><p>这表明每0分和30分执行一次脚本，将输出到<code>autoRun.log</code>内。</p><h2 id="其他方式执行定时任务"><a href="#其他方式执行定时任务" class="headerlink" title="其他方式执行定时任务"></a>其他方式执行定时任务</h2><p>执行 <code>ls /etc/cron.*.ly</code></p><p>可以看到etc下有一个<code>cron.*ly</code>的文件夹，如果想让脚本每小时执行一次，将它放在<code>cron.hourly</code>文件夹内即可。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>定时任务的输出默认情况下会存储在用户邮件目录下，所以一般要么将输出重定向到指定的文件里，或者重定向到<code>/dev/null</code>里。</p></li><li><p>如果服务器关机了，<code>crontab</code>时间错过了，则定时任务此次就不会执行了。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven打包成minijar</title>
    <link href="/3106064082.html"/>
    <url>/3106064082.html</url>
    
    <content type="html"><![CDATA[<p>本文演示使用<code>maven</code>的<code>maven-shade-plugin</code>插件实现打包成<code>minijar</code>功能，并解决缺少依赖问题。</p><p><code>maven</code>打包成可执行<code>jar</code>包时需要将依赖的<code>jar</code>包也一同打包到<code>jar</code>包内，最终可能导致得到的可执行<code>jar</code>体积太大，</p><p>但是第三方<code>jar</code>的部分<code>class</code>可能是从未使用到的，即使移除也不会影响程序运行，这样可以大大减少打包的体积。</p><p>插件<code>maven-shade-plugin</code>为我们提供了这样的功能，他会自动分析<code>jar</code>包内的依赖，将不需要的<code>class</code>移除。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-shade-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">minimizeJar</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">minimizeJar</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>shade<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面配置插件，并挂钩到<code>package</code>步骤中，执行<code>shade</code>。配置<code>minimizeJar</code>为<code>true</code>即可。</p><h2 id="部分依赖问题"><a href="#部分依赖问题" class="headerlink" title="部分依赖问题"></a>部分依赖问题</h2><p>上面很简单能实现<code>minijar</code>，但是插件在分析依赖时不能分析到反射获取的类，这会导致程序运行时反射获取类失败，所以需要手动处理这样的类。</p><p>下面我们在使用<code>logback</code>时，因为配置是写在配置文件里的，所以部分类会被插件丢弃掉导致<code>class Not Find</code>。</p><p>可以配置<code>filter</code>节点手动包含类，规则是。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifact</span>&gt;</span>artifactId:artifactId<span class="hljs-tag">&lt;/<span class="hljs-name">artifact</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br></code></pre></td></tr></table></figure><p>示例，包含<code>logback-core</code>的所有类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-shade-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">minimizeJar</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">minimizeJar</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filters</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifact</span>&gt;</span>ch.qos.logback:logback-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifact</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">filters</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>shade<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​要注意的一点是，如果配置了<code>filter</code>，该<code>artifact</code>就不会自动处理依赖了，插件只包含<code>include</code>内手动指定的类，没指定的全部不会包含。我这里使用了<code>**</code> 表示全部包含进来。</p>]]></content>
    
    
    
    <tags>
      
      <tag>maven</tag>
      
      <tag>maven打包miniJar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven多环境打包</title>
    <link href="/602459694.html"/>
    <url>/602459694.html</url>
    
    <content type="html"><![CDATA[<p>本文演示使用<code>maven</code>自带的<code>profile</code>功能实现多环境的打包，配合<code>jenkins</code>一键使用不同的配置文件发布到不同的环境中。</p><h2 id="1-创建SpringBoot测试项目"><a href="#1-创建SpringBoot测试项目" class="headerlink" title="1. 创建SpringBoot测试项目"></a>1. 创建SpringBoot测试项目</h2><p><img src="/img/in/2020-03-20-maven%E5%A4%9A%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/image-20200321181656077.png" alt="image-20200321181656077"></p><h2 id="2-创建多环境配置文件"><a href="#2-创建多环境配置文件" class="headerlink" title="2. 创建多环境配置文件"></a>2. 创建多环境配置文件</h2><p>创建三个环境使用不同的环境变量</p><p>即测试环境使用 <code>application-test.properties</code>，</p><p>开发环境使用<code>application-dev.properties</code>，</p><p>正式环境使用 <code>application-prod.properties</code>。</p><p>然后原来的<code>application.properties</code>内写</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.profiles.active</span>=<span class="hljs-string">@springboot.profileName@</span><br></code></pre></td></tr></table></figure><p><code>springboot.profileName</code>也可以换成其他字符串，只需要和下面配置的&#96;pom文件中国相同即可。</p><h2 id="3-配置多环境maven"><a href="#3-配置多环境maven" class="headerlink" title="3. 配置多环境maven"></a>3. 配置多环境maven</h2><p><code>pom</code>内配置如下,配置多个<code>profile</code>，<code>properties</code>中配置不同的<code>springboot.profileName</code>值。</p><p>并设置<code>dev</code>为默认环境。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">springboot.profileName</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">springboot.profileName</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">springboot.profileName</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">springboot.profileName</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">springboot.profileName</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">springboot.profileName</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-配置打包资源过滤"><a href="#4-配置打包资源过滤" class="headerlink" title="4. 配置打包资源过滤"></a>4. 配置打包资源过滤</h2><p>将下面配置放入<code>build</code>节点下, <code>filtering</code>的作用是过滤配置文件中的文本，将 <code>@xx@</code>标记的配置替换为对应的maven环境变量。不加<code>filtering</code>的话<code>application.properties</code>内的<code>@springboot.profileName@</code>不会被替换为对应的<code>test</code>,<code>dev</code>,<code>prod</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--先排除掉所有的application*.properties--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>application*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--再将对应配置的properties包含在内--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application-$&#123;springboot.profileName&#125;.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-尝试打包"><a href="#5-尝试打包" class="headerlink" title="5.尝试打包"></a>5.尝试打包</h2><p>输入下面命令,得到只包含<code>dev</code>配置的<code>jar</code>包，说明<code>dev</code>环境是默认的环境。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mvn clean package<br></code></pre></td></tr></table></figure><p><img src="/img/in/2020-03-20-maven%E5%A4%9A%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/image-20200321185639217.png" alt="image-20200321185639217"></p><p><code>application.properties</code>内的<code>@springboot.profileName@</code>已被替换成<code>dev</code></p><p><img src="/img/in/2020-03-20-maven%E5%A4%9A%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/image-20200321185718920.png" alt="image-20200321185718920"></p><p>输入下面命令，查看打包的jar包，被替换成test环境对应的配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mvn clean package -P=test<br></code></pre></td></tr></table></figure><p><img src="/img/in/2020-03-20-maven%E5%A4%9A%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/image-20200321190004462.png" alt="image-20200321190004462"></p><h2 id="6-整合jenkins"><a href="#6-整合jenkins" class="headerlink" title="6. 整合jenkins"></a>6. 整合jenkins</h2><p>上面已经能做到不同<code>mvn</code>打包命令得到含有不同环境配置的<code>jar</code>包功能。只需配置下<code>jenkins</code>即可。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">不同环境的打包命令<br>mvn clean <span class="hljs-keyword">package</span> <span class="hljs-title">-P=test</span><br>mvn clean <span class="hljs-keyword">package</span> <span class="hljs-title">-P=prod</span><br>mvn clean <span class="hljs-keyword">package</span><br></code></pre></td></tr></table></figure><p>只需在<code>jenkins</code>配置的 <code>Build -&gt; Goals and options</code> 里面输入对应的打包命令就能以不同的打包参数打包。</p><p><img src="/img/in/2020-03-20-maven%E5%A4%9A%E7%8E%AF%E5%A2%83%E6%89%93%E5%8C%85/image-20200321190339867.png" alt="image-20200321190339867"></p><p>如打包<code>test</code>环境命令为 (比上面的少了 <code>mvn</code> )</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">clean <span class="hljs-keyword">package</span> <span class="hljs-title">-P=test</span><br></code></pre></td></tr></table></figure><h2 id="7-完整pom配置"><a href="#7-完整pom配置" class="headerlink" title="7. 完整pom配置"></a>7. 完整pom配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mavenpackagedemo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--配置dev为默认环境--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">springboot.profileName</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">springboot.profileName</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">springboot.profileName</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">springboot.profileName</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">springboot.profileName</span>&gt;</span>prod<span class="hljs-tag">&lt;/<span class="hljs-name">springboot.profileName</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--先排除掉所有的application*.properties--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>application*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--再将对应配置的properties包含在内--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application-$&#123;springboot.profileName&#125;.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-comment">&lt;!--允许过滤资源--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux ls没有彩色显示了</title>
    <link href="/98126778.html"/>
    <url>/98126778.html</url>
    
    <content type="html"><![CDATA[<p> 给<code>ls --color -l</code> 起个别名叫 <code>ls</code>，这样输入<code>ls</code>就能出彩色了。</p><p>同理，创建个sh文件放在 <code>/etc/profile.d</code>文件夹下,连接自动运行<code>shell</code>,自动设置一下别名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>alias egrep=&#x27;egrep --color=auto&#x27;<br>alias fgrep=&#x27;fgrep --color=auto&#x27;<br>alias grep=&#x27;grep --color=auto&#x27;<br>alias l=&#x27;ls -CF&#x27;<br>alias la=&#x27;ls -A&#x27;<br>alias ll=&#x27;ls -alF&#x27;<br>alias ls=&#x27;ls --color=auto&#x27;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty将channel设为自动读取</title>
    <link href="/3083647988.html"/>
    <url>/3083647988.html</url>
    
    <content type="html"><![CDATA[<p>​</p><p>​是这样的一个小技巧，这是我在写ss时学到的，有时候要实现私有协议需要将netty设为非自动读取，等前面工作处理好了在转变成自动读取。</p><p>​要实现channel数据的转发工作，第二个channel未创建完成时是不能读取第一个channel内数据的，所以我们经常将第一个channel设为不自动读取。</p><p>先前我看netty例子里有这样的写法，转换数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">out.writeAndFlush(msg).addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> &#123;<br>        <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>            ctx.read();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.close();<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>他的意思就是将msg写入out里面，然后添加监听器，写完后再次从输入流中读取。</p><p>后来我又想到另一个效率高的写法,就是这样，将不自动读的输入流重新设为自动读，这样就不用加监听器了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">in.channel().config().setAutoRead(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给服务器开启bbr</title>
    <link href="/2527058159.html"/>
    <url>/2527058159.html</url>
    
    <content type="html"><![CDATA[<p>​首先要求服务器内核版本 &gt; 4.9,通过命令<code>uname -a</code>查看内核版本。如果内核版本小，请升级内核吧，不同发行版本升级方式不太一样，自行搜索。</p><h2 id="一，开启bbr"><a href="#一，开启bbr" class="headerlink" title="一，开启bbr"></a>一，开启bbr</h2><p>在这里前提是内核版本 &gt; 4.9, bbr是自带的，我们只要开启即可。</p><p>修改系统变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf<br>echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf<br></code></pre></td></tr></table></figure><p>如果权限不够使用下面命令代替：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo bash -c &#x27;echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf&#x27;<br>sudo bash -c &#x27;echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf&#x27;<br></code></pre></td></tr></table></figure><p>保存生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sysctl -p<br></code></pre></td></tr></table></figure><p>执行下面两个命令验证开启结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sysctl net.ipv4.tcp_available_congestion_control<br><br><br>lsmod | grep bbr<br><br></code></pre></td></tr></table></figure><p>​应该会返回带有ssr字符的结果，则表示开启成功。</p><h2 id="二-，关闭bbr"><a href="#二-，关闭bbr" class="headerlink" title="二 ，关闭bbr"></a>二 ，关闭bbr</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sed -i <span class="hljs-string">&#x27;/net\.core\.default_qdisc=fq/d&#x27;</span> /etc/sysctl.conf</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sed -i <span class="hljs-string">&#x27;/net\.ipv4\.tcp_congestion_control=bbr/d&#x27;</span> /etc/sysctl.conf</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sysctl -p</span><br></code></pre></td></tr></table></figure><p>关闭后需要重启服务器才行，使用上面的命令验证关闭结果。</p><h2 id="三-，效果"><a href="#三-，效果" class="headerlink" title="三 ，效果"></a>三 ，效果</h2><p>因为我在我的国内5M服务器上试的，本来速度能跑满，开启后感觉变化不大。</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>bbr</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器安装jekyll，搭建自己的博客</title>
    <link href="/185232587.html"/>
    <url>/185232587.html</url>
    
    <content type="html"><![CDATA[<p>​本来图方便使用<code>gitpage</code>做静态博客，但国内访问速度太慢，并且因为自己也有服务器，打算移动到自己服务器上，然后定时从<code>github</code>上同步代码，自己写博客仍然直接<code>push</code>到<code>github</code>，使用方式不变。</p><p>​并且这样也可以在<code>DNS</code>上将国内解析到服务器，国外解析到<code>gitpage</code>，这样一方面节省流量，一方面国内国外速度都能得到保障。下面讲具体步骤。</p><h2 id="1-安装ruby"><a href="#1-安装ruby" class="headerlink" title="1 安装ruby"></a>1 安装ruby</h2><ul><li>更新apt索引</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt -get update<br></code></pre></td></tr></table></figure><ul><li>安装ruby-full</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt-get install ruby-full<br></code></pre></td></tr></table></figure><h2 id="2-安装jekyll"><a href="#2-安装jekyll" class="headerlink" title="2 安装jekyll"></a>2 安装jekyll</h2><p><a href="http://jekyllcn.com/docs/installation/">官网安装教程在这里</a></p><ul><li>不看官方教程，其实就是一个命令即可安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gem install jekyll<br></code></pre></td></tr></table></figure><h2 id="3-安装-jekyll-paginate"><a href="#3-安装-jekyll-paginate" class="headerlink" title="3 安装 jekyll-paginate"></a>3 安装 jekyll-paginate</h2><ul><li>这是<code>jekyll</code>的插件，没他可能编译会报错</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gem install jekyll-paginate<br></code></pre></td></tr></table></figure><h2 id="4-尝试编译代码"><a href="#4-尝试编译代码" class="headerlink" title="4 尝试编译代码"></a>4 尝试编译代码</h2><p>从本地将代码用ftp上传到服务器上，使用如下命令,查看能否编译成功，是否报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jekyll build<br></code></pre></td></tr></table></figure><h2 id="5-从github拉取代码"><a href="#5-从github拉取代码" class="headerlink" title="5 从github拉取代码"></a>5 从github拉取代码</h2><p>使用https连接而不是，因为我们只pull 不 push。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/switchYello/switchYello.github.io.git<br></code></pre></td></tr></table></figure><h2 id="6-创建自动化脚本"><a href="#6-创建自动化脚本" class="headerlink" title="6 创建自动化脚本"></a>6 创建自动化脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">gitpage 下载到的目录</span><br>gitLocalPath=/home/hcy/switchYellow.github.io<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">nginx 存储静态资源的目录</span><br>nginxHtmlPath=/home/hcy/nginx/html<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">拉去代码</span><br>git -C $gitLocalPath pull origin master<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译</span><br>`jekyll build --source $gitLocalPath --destination $gitLocalPath/_site/ --trace `<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝到nginx静态文件下</span><br>cp -R  $gitLocalPath/_site/* $nginxHtmlPath/<br><br><br></code></pre></td></tr></table></figure><h2 id="7-安装nginx"><a href="#7-安装nginx" class="headerlink" title="7 安装nginx"></a>7 安装nginx</h2><p><a href="http://blog.dwzs.fun/2019/06/02/ubuntu-18-%E5%AE%89%E8%A3%85nginx/">可以参考这个安装教程</a></p><p>将放置编译好的页面文件夹配置到nginx下即可，我的是放在<code>/home/hcy/nginx/html</code>下的。</p><h2 id="8-创建定时任务"><a href="#8-创建定时任务" class="headerlink" title="8.创建定时任务"></a>8.创建定时任务</h2><p>每半小时执行一次拉去编译即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">crontab -e<br><br>0,30 * * * * /home/hcy/autoPullBlog.sh &gt;/dev/null 2&gt;&amp;1<br></code></pre></td></tr></table></figure><h2 id="9-使用docker"><a href="#9-使用docker" class="headerlink" title="9 使用docker"></a>9 使用docker</h2><p>如果不想安装<code>ruby</code>和<code>jekyll</code>可以直接安装<code>docker</code>,拉取<code>jekyll/jekyll</code>镜像，脚本改成。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">gitpage 下载到的目录</span><br>gitLocalPath=/home/hcy/switchYellow.github.io<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">nginx 存储静态资源的目录</span><br>nginxHtmlPath=/home/hcy/nginx/html<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">拉去代码</span><br>git -C $gitLocalPath pull origin master<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译</span><br>docker run --rm --volume=&quot;$gitLocalPath:/srv/jekyll&quot; jekyll/jekyll jekyll build<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝到nginx静态文件下</span><br>cp -R  $gitLocalPath/_site/* $nginxHtmlPath/<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>jekyll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>h2数据库初探</title>
    <link href="/1072269388.html"/>
    <url>/1072269388.html</url>
    
    <content type="html"><![CDATA[<p>首先是这个h2数据库的官网<a href="http://www.h2database.com/">http://www.h2database.com</a></p><p>当前最新的maven：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.h2database<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>h2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.200<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="1-两种运行模式"><a href="#1-两种运行模式" class="headerlink" title="1.两种运行模式"></a>1.两种运行模式</h2><p>纯内存模式，类比于java的<code>HashMap</code></p><p>嵌入模式，类比于Redis（开启实时保存到本地）</p><h2 id="2-先启动起来再说"><a href="#2-先启动起来再说" class="headerlink" title="2. 先启动起来再说"></a>2. 先启动起来再说</h2><p>首先引入maven</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.h2database<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>h2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.200<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在测试类里面写一个main方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException, ClassNotFoundException &#123;<br>    Class.forName(<span class="hljs-string">&quot;org.h2.Driver&quot;</span>);<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:h2:mem:h2db&quot;</span>, <span class="hljs-string">&quot;sa&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面使用内存模式启动H2，数据库名为<code>h2db</code>,对这个数据库做的操作重启程序后都会被删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException, ClassNotFoundException &#123;<br>    Class.forName(<span class="hljs-string">&quot;org.h2.Driver&quot;</span>);<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:h2:~/test&quot;</span>, <span class="hljs-string">&quot;sa&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>简单修改了了连接url，h2就从纯内存模式转变成了嵌入模式，他会在<code>~/</code>目录下创建一个<code>test.db</code>的文件，对数据库的所有操作都会反应到此文件上，且重启也不会丢失数据。</p><h2 id="3-网页服务模式"><a href="#3-网页服务模式" class="headerlink" title="3. 网页服务模式"></a>3. 网页服务模式</h2><p>上面创建了一个数据库，但数据库是空的，且没办法直观的看到数据，这是可以使用它内置的网页管理工具，我们在网页上就能连上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException, ClassNotFoundException &#123;<br><br>      Class.forName(<span class="hljs-string">&quot;org.h2.Driver&quot;</span>);<br>      <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:h2:~/test&quot;</span>, <span class="hljs-string">&quot;sa&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">//创建一个网页管理服务，并启动</span><br>      Server.createWebServer().start();<br>  &#125;<br></code></pre></td></tr></table></figure><p>开启了一个网页管理服务，因为上面执行获取<code>Connection</code>时已经创建的<code>test.db</code>,所以第1，2行代码不执行也可以的。有了网页服务，我们打开浏览器输入<code>http://localhost:8082</code>,进入</p><p><img src="/img/in/2020-02-26-h2%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E6%8E%A2/image-20200226215023374.png" alt="image-20200226215023374"></p><p>网页内容如上，我们正确填写了<code> jdbc url</code>，<code>用户名</code>，<code>密码</code>，这些就是创建数据库时一致的，就能进入管理后台。</p><p><img src="/img/in/2020-02-26-h2%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E6%8E%A2/image-20200226215137165.png" alt="image-20200226215137165"></p><p>这也很好理解，第一次我们使用<code>DriverManager</code>获取连接时，<code>h2</code>为我们在指定位置生成了一个<code>test.db</code>文件，这个文件就是我们的数据库，且使用给定的用户名密码加密了。第二次我们启动了一个<code>WebServer</code>，通过网页我们可以告诉<code>WebServer</code>去哪里查找数据库，使用的用户名密码是什么，这样我们第二次启动的程序就能再把<code>test.db</code>加载到内存里，读写它。</p><h2 id="4-tcp服务模式"><a href="#4-tcp服务模式" class="headerlink" title="4. tcp服务模式"></a>4. tcp服务模式</h2><p>如果我们想要程序A开启一个嵌入数据库，程序B通过<code>jdbc</code>连接上来读取数据，那该怎么办呢？</p><p>我们可以在程序A中开启一个TcpServer，提供一个服务出去供其他程序访问，比如我们在A程序中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    Server.createTcpServer().start();<br>&#125;<br></code></pre></td></tr></table></figure><p>程序B里面这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;org.h2.Driver&quot;</span>);<br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:h2:tcp:localhost:9092/~/test&quot;</span>, <span class="hljs-string">&quot;sa&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><p>注意<code>url</code>变了，这样我们就能在程序B里面获取A开启的9092端口的监听，程序B里面做的数据库操作或通过Tcp传送到A上，最终反映到数据库上，A就成了一个B的代理。</p><h2 id="5-PG服务模式"><a href="#5-PG服务模式" class="headerlink" title="5.PG服务模式"></a>5.PG服务模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    Server.createPgServer().start()<br>&#125;<br></code></pre></td></tr></table></figure><p>支持PostgreSQL客户端，我没试。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>h2还为我们提供了简单的连接池，使用方式如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JdbcConnectionPool</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> JdbcConnectionPool.create(<span class="hljs-string">&quot;jdbc:h2:~/test&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> cp.getConnection();<br>conn.close();<br>cp.dispose();<br></code></pre></td></tr></table></figure><p> 连接字符串参数</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">DB_CLOSE_DELAY：要求最后一个正在连接的连接断开后，不要关闭数据库<br>MODE=MySQL：兼容模式，H2兼容多种数据库，该值可以为：DB2、Derby、HSQLDB、MSSQLServer、MySQL、Oracle、PostgreSQL<br>AUTO_RECONNECT=<span class="hljs-literal">TRUE</span>：连接丢失后自动重新连接<br>AUTO_SERVER=<span class="hljs-literal">TRUE</span>：启动自动混合模式，允许开启多个连接，该参数不支持在内存中运行模式<br>TRACE_LEVEL_SYSTEM_OUT、TRACE_LEVEL_FILE：输出跟踪日志到控制台或文件， 取值<span class="hljs-number">0</span>为OFF，<span class="hljs-number">1</span>为ERROR（默认值），<span class="hljs-number">2</span>为INFO，<span class="hljs-number">3</span>为DEBUG<br>SET TRACE_MAX_FILE_SIZE mb：设置跟踪日志文件的大小，默认为<span class="hljs-number">16</span>M<br></code></pre></td></tr></table></figure><p>连接参数是这样用的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">jdbc:h2:mem:DBName;DB_CLOSE_DELAY=-<span class="hljs-number">1</span>;MODE=MySQL<br><br>jdbc:h2:file:~/.h2/DBName;AUTO_SERVER=TRUE<br></code></pre></td></tr></table></figure><p>文档里，这一段也要看看哦</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">To access <span class="hljs-keyword">an</span> <span class="hljs-keyword">in</span>-memory database <span class="hljs-built_in">from</span> another <span class="hljs-built_in">process</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">from</span> another computer, you need <span class="hljs-built_in">to</span> <span class="hljs-built_in">start</span> <span class="hljs-keyword">a</span> TCP server <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> same <span class="hljs-built_in">process</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">in</span>-memory database was created. The other processes <span class="hljs-keyword">then</span> need <span class="hljs-built_in">to</span> access <span class="hljs-keyword">the</span> database over TCP/IP <span class="hljs-keyword">or</span> SSL/TLS, <span class="hljs-keyword">using</span> <span class="hljs-keyword">a</span> database <span class="hljs-built_in">URL</span> such <span class="hljs-keyword">as</span>: jdbc:h2:tcp://localhost/mem:db1. <br><br><br>By default, closing <span class="hljs-keyword">the</span> <span class="hljs-keyword">last</span> connection <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> database closes <span class="hljs-keyword">the</span> database. For <span class="hljs-keyword">an</span> <span class="hljs-keyword">in</span>-memory database, this means <span class="hljs-keyword">the</span> content is lost. To keep <span class="hljs-keyword">the</span> database <span class="hljs-built_in">open</span>, <span class="hljs-built_in">add</span> ;DB_CLOSE_DELAY=<span class="hljs-number">-1</span> <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> database <span class="hljs-built_in">URL</span>. To keep <span class="hljs-keyword">the</span> content <span class="hljs-keyword">of</span> <span class="hljs-keyword">an</span> <span class="hljs-keyword">in</span>-memory database <span class="hljs-keyword">as</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">the</span> virtual machine is alive, use jdbc:h2:mem:test;DB_CLOSE_DELAY=<span class="hljs-number">-1.</span> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>h2</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty监听本地端口引发的问题</title>
    <link href="/2543870335.html"/>
    <url>/2543870335.html</url>
    
    <content type="html"><![CDATA[<p>​昨天用<code>netty</code>写了一个内网穿透工具，服务器用的时阿里云，本地测试没问题后打算放服务器上测试一下，结果就是不能访问。</p><p>​首先阿里云防火墙端口也打开了，首先怀疑阿里云防火墙配置不能立刻生效，结果等了十几分钟还是不行，然后又换了一台端口本来已经打开了的服务器，结果还是不行。</p><p>​真是奇怪？能确定第二台服务器的端口是打开了的，也能确定程序在本地跑是正常的？？？？？？？？？</p><p>​最后竟然是因为<code>netty</code>绑定本地端口使用的是bind(“127.0.0.1”,9000),如果将<code>127.0.0.1</code>换成<code>0.0.0.0</code>就没问题了。</p><p>​但是我暂时仍无法理解使用<code>127.0.0.1</code>为什么会不行。下次有时间要查一下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>netty</tag>
      
      <tag>遇到的问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty遇到的一个bug</title>
    <link href="/3460644164.html"/>
    <url>/3460644164.html</url>
    
    <content type="html"><![CDATA[<p>​启动netty报如下异常，工具异常提示能确定重复使用Handler导致的，但我检查了代码不知道是哪里重复使用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">io.netty.channel.ChannelPipelineException: com.hcy.FrpsHandler is not a <span class="hljs-meta">@Sharable</span> handler, so can<span class="hljs-string">&#x27;t be added or removed multiple times.</span><br><span class="hljs-string">at io.netty.channel.DefaultChannelPipeline.checkMultiplicity(DefaultChannelPipeline.java:600)</span><br><span class="hljs-string">at io.netty.channel.DefaultChannelPipeline.addLast(DefaultChannelPipeline.java:202)</span><br><span class="hljs-string">at io.netty.channel.DefaultChannelPipeline.addLast(DefaultChannelPipeline.java:381)</span><br><span class="hljs-string">at io.netty.channel.DefaultChannelPipeline.addLast(DefaultChannelPipeline.java:370)</span><br><span class="hljs-string">at io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor.channelRead(ServerBootstrap.java:203)</span><br><span class="hljs-string">at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)</span><br><span class="hljs-string">at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)</span><br><span class="hljs-string">at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:355)</span><br><span class="hljs-string">at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)</span><br><span class="hljs-string">at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:377)</span><br><span class="hljs-string">at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363)</span><br><span class="hljs-string">at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)</span><br><span class="hljs-string">at io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe.read(AbstractNioMessageChannel.java:93)</span><br><span class="hljs-string">at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)</span><br><span class="hljs-string">at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)</span><br><span class="hljs-string">at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)</span><br><span class="hljs-string">at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)</span><br><span class="hljs-string">at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)</span><br><span class="hljs-string">at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="hljs-string">at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class="hljs-string">at java.lang.Thread.run(Thread.java:748)</span><br></code></pre></td></tr></table></figure><p>此bug引发的原因是因为，我在创建<code>ServerBootstrap</code>时，传入<code>childHandler</code>时，因为比较简单所以直接new出来的<code>Handler</code>，没有使用<code>ChannelInitializer</code>。</p><p>而直接new的<code>Handler</code>会存储在<code>ServerBootstrap</code>中，每个连接都使用相同的<code>Handler</code>，而我的<code>Handler</code>是不允许共享的才导致的错误。</p><p>改成使用<code>ChannelInitializer</code>，每次都重新<code>new Handler</code> 即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>netty</tag>
      
      <tag>遇到的问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot Maven打包</title>
    <link href="/3399176269.html"/>
    <url>/3399176269.html</url>
    
    <content type="html"><![CDATA[<p>今天使用<code>maven</code>命令打包<code>springboot</code>项目成可执行<code>jar</code>，总是无法成功。表现为打包的jar包只有项目本身的<code>Class</code>，不包含依赖。</p><p>但是把项目文件复制到其他目录就能正常使用。后来发现原因是这这样。</p><p>项目是一个多Module项目，父pom中这样写的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                       <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                           <span class="hljs-tag">&lt;<span class="hljs-name">skip</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">skip</span>&gt;</span><br>                       <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                       <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                           <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                               <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                                   <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>repackage<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                               <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                           <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                       <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>                   <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我做的子Module是这样写的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>repackage<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样问题就产生了，子项目是继承父pom的，这样子项目没有写版本号，但是我没注意看到父pom有一个</p><p><code>&lt;skip&gt;true&lt;/skip&gt;</code>，这个选项的意思是忽略<code>execution</code>，这样插件就不会执行。</p><p>被坑了，弄了好久才注意到父pom这个选项。</p><p>打包命令,顺便跳过测试</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">mvn clean <span class="hljs-keyword">package</span> -Dmaven.test.skip=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>maven</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot配置MappingJackson2HttpMessageConverter最佳实践</title>
    <link href="/643050368.html"/>
    <url>/643050368.html</url>
    
    <content type="html"><![CDATA[<p>​</p><p>上篇讲了，<code>SpringMvc是如何将返回值转成Json的</code>，</p><p>默认情况下<code>Springboot是如何配置HandlerAdapter</code>的，如何根据配置文件影响到<code>ObjectMapper</code>的创建的。</p><p>下面讲一讲如何做才是最佳实践，如何做能满足需求。</p><h2 id="1-最大限度使用Springboot的自动配置"><a href="#1-最大限度使用Springboot的自动配置" class="headerlink" title="1. 最大限度使用Springboot的自动配置"></a>1. 最大限度使用<code>Springboot</code>的自动配置</h2><p>如果我们想最大限度使用<code>Springboot</code>，且想修改接口返回<code>Json</code>格式等，那么我们可以在配置文件中配置常用的配置。</p><p>我们在配置文件里打出<code>spring.jackson</code>，<code>ide</code>会给我们提示，我们发现常用的配置都有，比如配置输出时间格式的</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">spring</span>.jackson.<span class="hljs-keyword">date</span>-<span class="hljs-keyword">format</span>=yyyy-MM-dd HH:mm:ss<br></code></pre></td></tr></table></figure><p>也可以打开看看下面这个类,里面也有对应的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.boot.autoconfigure.jackson.JacksonProperties<br></code></pre></td></tr></table></figure><h2 id="2-使用自己创建的ObjectMapper"><a href="#2-使用自己创建的ObjectMapper" class="headerlink" title="2.使用自己创建的ObjectMapper"></a>2.使用自己创建的<code>ObjectMapper</code></h2><p>创建一个<code>ObjectMapper</code>的<code>Bean</code>，但要标记为<code>@Primary</code>才能覆盖自动配置的。这样的话配置文件里的配置不会生效，我们自己创建的就可以随心所欲的配置了。</p><p>并且推荐使用下面的第二种方式创建，点开源码能看到它里面添加了额外的配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Primary</span><br><span class="hljs-keyword">public</span> ObjectMapper <span class="hljs-title function_">objectMapper</span> <span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>    objectMapper.setDateFormat(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>));<br>    <span class="hljs-keyword">return</span> objectMapper;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Primary</span><br><span class="hljs-keyword">public</span> ObjectMapper <span class="hljs-title function_">objectMapper</span> <span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> Jackson2ObjectMapperBuilder<br>            .json()<br>            .dateFormat(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>))<br>            .build();<br>&#125;<br></code></pre></td></tr></table></figure><p>因为<code>org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration</code>里的自动配置，加入了<code>@ConditionalOnMissingBean</code>注解，所以系统就不会自动配置了。</p><h2 id="3-使用自己创建的MappingJackson2HttpMessageConverter"><a href="#3-使用自己创建的MappingJackson2HttpMessageConverter" class="headerlink" title="3. 使用自己创建的MappingJackson2HttpMessageConverter"></a>3. 使用自己创建的<code>MappingJackson2HttpMessageConverter</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MappingJackson2HttpMessageConverter <span class="hljs-title function_">objectMapper</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>    objectMapper.setDateFormat(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MappingJackson2HttpMessageConverter</span>(objectMapper);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为<code>org.springframework.boot.autoconfigure.http.JacksonHttpMessageConvertersConfiguration</code>类中对<code>MappingJackson2HttpMessageConverter</code>的自动配置添加了条件判断，所以自动配置就不会执行了。</p><p>判断如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConditionalOnMissingBean(value = MappingJackson2HttpMessageConverter.class,</span><br></code></pre></td></tr></table></figure><h2 id="4-如果继承WebMvcConfigurationSupport"><a href="#4-如果继承WebMvcConfigurationSupport" class="headerlink" title="4.如果继承WebMvcConfigurationSupport"></a>4.如果继承<code>WebMvcConfigurationSupport</code></h2><p>这个类里面又很多<code>MVC</code>相关的配置，我个人比较习惯继承这个类，但是继承这个类后，上面三种方法无论是改配置文件，自定义<code>ObjectMapper</code>，还是自己定义<code>MappingJackson2HttpMessageConverter</code>均失效了。</p><p>大家可以试一下，那么是什么原因导致失效的呢？，如何解决这个问题？</p><h4 id="1-是什么原因导致失效的呢？"><a href="#1-是什么原因导致失效的呢？" class="headerlink" title="1.是什么原因导致失效的呢？"></a>1.是什么原因导致失效的呢？</h4><p>我们可以看一下<code>WebMvcAutoConfiguration</code>的源码，发现这个类上有<code>@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</code>的注解，</p><p>也就是说找不到<code>WebMvcConfigurationSupport</code>才进行自动配置，而我们继承了<code>WebMvcConfigurationSupport</code>，并添加@Configuration，则<code>MapperAdaper</code>不会被自动配置，所以自动创建的</p><p><code>MappingJackson2HttpMessageConverter</code>和<code>ObjectMapper</code>都虽然创建了但也不会起作用了。</p><h4 id="2-如何解决这个问题？"><a href="#2-如何解决这个问题？" class="headerlink" title="2. 如何解决这个问题？"></a>2. 如何解决这个问题？</h4><p>既然我习惯继承<code>WebMvcConfigurationSupport</code>，如果想定制<code>ObjectMapper</code>该怎么办呢，查看<code>WebMvcConfigurationSupport</code>源码,发现他有这样一个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> RequestMappingHandlerAdapter <span class="hljs-title function_">requestMappingHandlerAdapter</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">RequestMappingHandlerAdapter</span> <span class="hljs-variable">adapter</span> <span class="hljs-operator">=</span> createRequestMappingHandlerAdapter();<br>adapter.setContentNegotiationManager(mvcContentNegotiationManager());<br><span class="hljs-comment">//这里注入了MessageConverter，请进入getMessageConverters()方法</span><br>adapter.setMessageConverters(getMessageConverters());<br>adapter.setWebBindingInitializer(getConfigurableWebBindingInitializer());<br>adapter.setCustomArgumentResolvers(getArgumentResolvers());<br>adapter.setCustomReturnValueHandlers(getReturnValueHandlers());<br><br><span class="hljs-keyword">if</span> (jackson2Present) &#123;<br>adapter.setRequestBodyAdvice(Collections.singletonList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonViewRequestBodyAdvice</span>()));<br>adapter.setResponseBodyAdvice(Collections.singletonList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonViewResponseBodyAdvice</span>()));<br>&#125;<br><br><span class="hljs-type">AsyncSupportConfigurer</span> <span class="hljs-variable">configurer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncSupportConfigurer</span>();<br>configureAsyncSupport(configurer);<br><span class="hljs-keyword">if</span> (configurer.getTaskExecutor() != <span class="hljs-literal">null</span>) &#123;<br>adapter.setTaskExecutor(configurer.getTaskExecutor());<br>&#125;<br><span class="hljs-keyword">if</span> (configurer.getTimeout() != <span class="hljs-literal">null</span>) &#123;<br>adapter.setAsyncRequestTimeout(configurer.getTimeout());<br>&#125;<br>adapter.setCallableInterceptors(configurer.getCallableInterceptors());<br>adapter.setDeferredResultInterceptors(configurer.getDeferredResultInterceptors());<br><br><span class="hljs-keyword">return</span> adapter;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面源码能看到，没有在<code>WebMvcAutoConfiguration</code>里面配置的<code>RequestMappingHandlerAdapter</code>在这里配置了，但这里并没有使用Spring容器里面的<code>ObjectMapper</code>和<code>MappingJackson2HttpMessageConverter</code>，而是新创建的，所以系统自动配置的和我们自己注入到<code>Spring容器</code>的才会失效，因为根本就没有被使用。</p><p>我们看一下是如何添加MessageConverter的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> List&lt;HttpMessageConverter&lt;?&gt;&gt; getMessageConverters() &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.messageConverters == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.messageConverters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">//这个方法是空实现</span><br>configureMessageConverters(<span class="hljs-built_in">this</span>.messageConverters);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.messageConverters.isEmpty()) &#123;<br><span class="hljs-comment">//添加默认的messageConverters</span><br>addDefaultHttpMessageConverters(<span class="hljs-built_in">this</span>.messageConverters);<br>&#125;<br><span class="hljs-comment">//继续处理</span><br>extendMessageConverters(<span class="hljs-built_in">this</span>.messageConverters);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.messageConverters;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码能看出，首先是通过<code>configureMessageConverters(this.messageConverters)</code>方法配置，但该方法是空实现，然后添加默认的<code>MessageConverter</code>,然后<code>extendMessageConverters(this.messageConverters)</code></p><p>所以我们可以在继承类中重写<code>extendMessageConverters</code>方法，在这个类中对默认的<code>MessageConverter</code>进行修改或添加删除等操作，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">extendMessageConverters</span><span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;<br>    <span class="hljs-comment">//将StringHttpMessageConverter设成UTF8格式</span><br>    converters.stream()<br>            .filter(c -&gt; c <span class="hljs-keyword">instanceof</span> StringHttpMessageConverter)<br>            .map(c -&gt; (StringHttpMessageConverter) c)<br>            .forEach(c -&gt; c.setDefaultCharset(StandardCharsets.UTF_8));<br><br>    <span class="hljs-comment">//将MappingJackson2HttpMessageConverter设为自己的ObjectMapper</span><br>    <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>    mapper.setDateFormat(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>));<br>    converters.stream()<br>            .filter(c -&gt; c <span class="hljs-keyword">instanceof</span> MappingJackson2HttpMessageConverter)<br>            .map(c -&gt; (MappingJackson2HttpMessageConverter) c)<br>            .forEach(c -&gt; c.setObjectMapper(mapper));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>如果你不打算继承<code>WebMvcConfigurationSupport</code>，那么自动配置生效，你可以通过配置文件配置<code>Jackson</code>或通过提供自己的类配置<code>Jackson</code>，但注意如果覆盖<code>ObjectMappe</code>r要加<code>@Primary</code>注解才行。</p><p>如果你不小心或打算继承<code>WebMvcConfigurationSupport</code>，那上面的自动配置依然会执行，但不会被使用，这就导致上面的配置不灵了，可以实现<code>extendMessageConverters</code>方法，在里面我们可以任意处理<code>MessageConverter</code>。</p><h2 id="6-回答下上篇文章的问题"><a href="#6-回答下上篇文章的问题" class="headerlink" title="6.回答下上篇文章的问题"></a>6.回答下上篇文章的问题</h2><ol><li>配置文件里配置列<code>Jackson</code>但不生效？</li></ol><p>可能是覆盖了<code>WebMvcConfigurationSupport</code>，或重写了<code>ObjectMapper</code>或重写了<code>MappingJackson2HttpMessageConverter</code>，这样导致配置文件里的不生效了。</p><ol start="2"><li>自己手动创建<code>ObjectMapper</code>来代替<code>Springboot</code>帮我们创建的，但不生效？</li></ol><p>你肯定是继承了<code>WebMvcConfigurationSupport</code>。</p><ol start="3"><li>如何做才是最佳实践？</li></ol><p>上面已经列举了四种方式，要注意他们的优先级，且继承<code>WebMvcConfigurationSupport</code>会导致前三种方式创建的对象不被使用，也就是失效了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>jackson</tag>
      
      <tag>HttpMessageConverter</tag>
      
      <tag>json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot如何自动配置MappingJackson2HttpMessageConverter</title>
    <link href="/3222672442.html"/>
    <url>/3222672442.html</url>
    
    <content type="html"><![CDATA[<p>​</p><p><code>springboot</code>开箱即用，写一个<code>Controller</code>，再配合<code>RestController</code>，无需其他配置，就能直接返回<code>Json</code>到前台，那他是怎么做到的呢?，如何定制它?，因为只靠默认是不能满足我们的需求的，花了点时间看下源码，进行如下总结。</p><h2 id="springmvc如何将返回值转成json的"><a href="#springmvc如何将返回值转成json的" class="headerlink" title="springmvc如何将返回值转成json的"></a>springmvc如何将返回值转成json的</h2><p>我们知道，当请求到达<code>DispatchServlet</code>时，该<code>servlet</code>会查找到对应的<code>HandlerMapper</code>，然后查找与之适配的<code>HandlerAdapter</code>。使用<code>HandlerAdapter.handler(request,response)</code>来处理请求。</p><p>下面看<code>HandlerAdapter</code>里的<code>invokeHandlerMethod</code>方法是如何处理请求的</p><blockquote><p>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandler#invokeHandlerMethod</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java">    <br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title function_">invokeHandlerMethod</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>    <span class="hljs-type">ServletWebRequest</span> <span class="hljs-variable">webRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletWebRequest</span>(request, response);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">WebDataBinderFactory</span> <span class="hljs-variable">binderFactory</span> <span class="hljs-operator">=</span> getDataBinderFactory(handlerMethod);<br>        <span class="hljs-type">ModelFactory</span> <span class="hljs-variable">modelFactory</span> <span class="hljs-operator">=</span> getModelFactory(handlerMethod, binderFactory);<br><br>        <span class="hljs-type">ServletInvocableHandlerMethod</span> <span class="hljs-variable">invocableMethod</span> <span class="hljs-operator">=</span> createInvocableHandlerMethod(handlerMethod);<br>        <span class="hljs-comment">//设置用来解析参数的argumentResolvers到invocableMethod</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.argumentResolvers != <span class="hljs-literal">null</span>) &#123;<br>            invocableMethod.setHandlerMethodArgumentResolvers(<span class="hljs-built_in">this</span>.argumentResolvers);<br>        &#125;<br>        <span class="hljs-comment">//设置用来处理返回值的returnValueHandlers到invocableMethod</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.returnValueHandlers != <span class="hljs-literal">null</span>) &#123;<br>            invocableMethod.setHandlerMethodReturnValueHandlers(<span class="hljs-built_in">this</span>.returnValueHandlers);<br>        &#125;<br>        invocableMethod.setDataBinderFactory(binderFactory);<br>        invocableMethod.setParameterNameDiscoverer(<span class="hljs-built_in">this</span>.parameterNameDiscoverer);<br><br>        <span class="hljs-type">ModelAndViewContainer</span> <span class="hljs-variable">mavContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndViewContainer</span>();<br>        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));<br>        modelFactory.initModel(webRequest, mavContainer, invocableMethod);<br>        mavContainer.setIgnoreDefaultModelOnRedirect(<span class="hljs-built_in">this</span>.ignoreDefaultModelOnRedirect);<br><br>        <span class="hljs-type">AsyncWebRequest</span> <span class="hljs-variable">asyncWebRequest</span> <span class="hljs-operator">=</span> WebAsyncUtils.createAsyncWebRequest(request, response);<br>        asyncWebRequest.setTimeout(<span class="hljs-built_in">this</span>.asyncRequestTimeout);<br><br>        <span class="hljs-type">WebAsyncManager</span> <span class="hljs-variable">asyncManager</span> <span class="hljs-operator">=</span> WebAsyncUtils.getAsyncManager(request);<br>        asyncManager.setTaskExecutor(<span class="hljs-built_in">this</span>.taskExecutor);<br>        asyncManager.setAsyncWebRequest(asyncWebRequest);<br>        asyncManager.registerCallableInterceptors(<span class="hljs-built_in">this</span>.callableInterceptors);<br>        asyncManager.registerDeferredResultInterceptors(<span class="hljs-built_in">this</span>.deferredResultInterceptors);<br><br>        <span class="hljs-keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> asyncManager.getConcurrentResult();<br>            mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="hljs-number">0</span>];<br>            asyncManager.clearConcurrentResult();<br>            LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">formatted</span> <span class="hljs-operator">=</span> LogFormatUtils.formatValue(result, !traceOn);<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Resume with async result [&quot;</span> + formatted + <span class="hljs-string">&quot;]&quot;</span>;<br>            &#125;);<br>            invocableMethod = invocableMethod.wrapConcurrentResult(result);<br>        &#125;<br>        <span class="hljs-comment">//真实调用</span><br>        invocableMethod.invokeAndHandle(webRequest, mavContainer);<br>        <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        webRequest.requestCompleted();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面看<code>invocableMethod</code>真实调用时的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeAndHandle</span><span class="hljs-params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span><br><span class="hljs-params">Object... providedArgs)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">//调用我们写的controller，获取返回值</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> invokeForRequest(webRequest, mavContainer, providedArgs);<br>setResponseStatus(webRequest);<br><br><span class="hljs-keyword">if</span> (returnValue == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="hljs-literal">null</span> || mavContainer.isRequestHandled()) &#123;<br>disableContentCachingIfNecessary(webRequest);<br>mavContainer.setRequestHandled(<span class="hljs-literal">true</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;<br>mavContainer.setRequestHandled(<span class="hljs-literal">true</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>mavContainer.setRequestHandled(<span class="hljs-literal">false</span>);<br>Assert.state(<span class="hljs-built_in">this</span>.returnValueHandlers != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;No return value handlers&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//使用returnValueHandlers处理返回值</span><br><span class="hljs-built_in">this</span>.returnValueHandlers.handleReturnValue(<br>returnValue, getReturnValueType(returnValue), mavContainer, webRequest);<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception ex) &#123;<br><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>logger.trace(formatErrorForReturnValue(returnValue), ex);<br>&#125;<br><span class="hljs-keyword">throw</span> ex;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面可以看到，<code>HandlerAdapter</code>会调用我们字节写的<code>controller</code>方法，<code>controller</code>返回结果使用<code>returnValueHandlers</code>来处理的。</p><p>下面我看带着疑问，什么是<code>returnValueHandlers</code>？他是什么时候被创建的？他是如何处理返回值的？</p><p>查看<code>handlerAdapet</code>的源码发现有个这个方法，用于初始化多个<code>returnValueHandlers</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此方法会当属性设置完毕后被spring回掉</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// Do this first, it may add ResponseBody advice beans</span><br>initControllerAdviceCache();<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.argumentResolvers == <span class="hljs-literal">null</span>) &#123;<br>List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();<br><span class="hljs-built_in">this</span>.argumentResolvers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerMethodArgumentResolverComposite</span>().addResolvers(resolvers);<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.initBinderArgumentResolvers == <span class="hljs-literal">null</span>) &#123;<br>List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();<br><span class="hljs-built_in">this</span>.initBinderArgumentResolvers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerMethodArgumentResolverComposite</span>().addResolvers(resolvers);<br>&#125;<br><span class="hljs-comment">//这个方法初始化ReturnValueHandlers</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.returnValueHandlers == <span class="hljs-literal">null</span>) &#123;<br>List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();<br><span class="hljs-built_in">this</span>.returnValueHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerMethodReturnValueHandlerComposite</span>().addHandlers(handlers);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//可以看到此方法初始化了多个HandlerMethodReturnValueHandler</span><br><span class="hljs-keyword">private</span> List&lt;HandlerMethodReturnValueHandler&gt; <span class="hljs-title function_">getDefaultReturnValueHandlers</span><span class="hljs-params">()</span> &#123;<br>List&lt;HandlerMethodReturnValueHandler&gt; handlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">// Single-purpose return value types</span><br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndViewMethodReturnValueHandler</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelMethodProcessor</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewMethodReturnValueHandler</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseBodyEmitterReturnValueHandler</span>(getMessageConverters(),<br><span class="hljs-built_in">this</span>.reactiveAdapterRegistry, <span class="hljs-built_in">this</span>.taskExecutor, <span class="hljs-built_in">this</span>.contentNegotiationManager));<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamingResponseBodyReturnValueHandler</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpEntityMethodProcessor</span>(getMessageConverters(),<br><span class="hljs-built_in">this</span>.contentNegotiationManager, <span class="hljs-built_in">this</span>.requestResponseBodyAdvice));<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHeadersReturnValueHandler</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CallableMethodReturnValueHandler</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DeferredResultMethodReturnValueHandler</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncTaskMethodReturnValueHandler</span>(<span class="hljs-built_in">this</span>.beanFactory));<br><br><span class="hljs-comment">// Annotation-based return value types</span><br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAttributeMethodProcessor</span>(<span class="hljs-literal">false</span>));<br><br><span class="hljs-comment">//转json真正使用的handlers，参数传入了adapter内的所有MessageConverters</span><br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestResponseBodyMethodProcessor</span>(getMessageConverters(),<br><span class="hljs-built_in">this</span>.contentNegotiationManager, <span class="hljs-built_in">this</span>.requestResponseBodyAdvice));<br><br><span class="hljs-comment">// Multi-purpose return value types</span><br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewNameMethodReturnValueHandler</span>());<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MapMethodProcessor</span>());<br><br><span class="hljs-comment">// Custom return value types</span><br><span class="hljs-keyword">if</span> (getCustomReturnValueHandlers() != <span class="hljs-literal">null</span>) &#123;<br>handlers.addAll(getCustomReturnValueHandlers());<br>&#125;<br><br><span class="hljs-comment">// Catch-all</span><br><span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(getModelAndViewResolvers())) &#123;<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndViewResolverMethodReturnValueHandler</span>(getModelAndViewResolvers()));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAttributeMethodProcessor</span>(<span class="hljs-literal">true</span>));<br>&#125;<br><br><span class="hljs-keyword">return</span> handlers;<br>&#125;<br></code></pre></td></tr></table></figure><p>看上面的源码，回答下上面的疑问</p><p>什么是<code>returnValueHandlers</code>?</p><p>他是用于处理<code>controller</code>的返回值的处理器，它都多个实现类存在于<code>MapperAdapter</code>里，不同的<code>returnValueHandlers</code>能处理不同类型的返回值，责任链模式调用。</p><p>他是什么时候被创建的？</p><p>他在<code>afterPropertiesSet</code>方法里被初始化，这个方法是<code>InitializingBean</code>接口的方法，从名字可以看出这个方法在类属性设置完成后被<code>Spring</code>回掉，所以在这里创建了多个<code>returnValueHandlers</code>存在在list里，我们要注意的是，其中有一个<code>RequestResponseBodyMethodProcessor</code>，创建它时将<code>HandlerAdapter</code>里面的所有<code>MessageConverter</code>都传进去了。</p><p>他是如何处理返回值的？</p><p>他是使用构造参数传入的<code>MessageConverter</code>处理的，其中有一个<code>MessageConverter</code>就是<code>MappingJackson2HttpMessageConverter</code>，这个类很熟悉，就是他将返回值转成<code>Json</code>的。</p><h2 id="看看MappingJackson2HttpMessageConverter什么时候设置进HandlerAdapter里面的"><a href="#看看MappingJackson2HttpMessageConverter什么时候设置进HandlerAdapter里面的" class="headerlink" title="看看MappingJackson2HttpMessageConverter什么时候设置进HandlerAdapter里面的"></a>看看MappingJackson2HttpMessageConverter什么时候设置进HandlerAdapter里面的</h2><p>既然知道返回值是何时被转成<code>Json</code>的，又有了新疑问，那就是<code>HandlerAdapter</code>里面的<code>MessageConverter</code>是什么时候被设置的？，以及<code>MappingJackson2HttpMessageConverter</code>是什么时候被设置的？</p><p>我们找到了<code>WebMvcAutoConfiguration</code>这个类，这里我们看到了自动初始化<code>RequestMappingHandlerAdapter</code>的方法，进入方法内部查看，我们找到了设置<code>HttpMessageConverter</code>的过程。</p><blockquote><p>创建RequestMappingHandlerAdapter的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> RequestMappingHandlerAdapter <span class="hljs-title function_">requestMappingHandlerAdapter</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">RequestMappingHandlerAdapter</span> <span class="hljs-variable">adapter</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.requestMappingHandlerAdapter();<br>adapter.setIgnoreDefaultModelOnRedirect(<br><span class="hljs-built_in">this</span>.mvcProperties == <span class="hljs-literal">null</span> || <span class="hljs-built_in">this</span>.mvcProperties.isIgnoreDefaultModelOnRedirect());<br><span class="hljs-keyword">return</span> adapter;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>查看<code>super.requestMappingHandlerAdapter()</code>，我们找到下面的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> RequestMappingHandlerAdapter <span class="hljs-title function_">requestMappingHandlerAdapter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RequestMappingHandlerAdapter</span> <span class="hljs-variable">adapter</span> <span class="hljs-operator">=</span> createRequestMappingHandlerAdapter();<br>    adapter.setContentNegotiationManager(mvcContentNegotiationManager());<br>    <span class="hljs-comment">//创建后，设置了MessageConverters</span><br>    adapter.setMessageConverters(getMessageConverters());<br>    adapter.setWebBindingInitializer(getConfigurableWebBindingInitializer());<br>    adapter.setCustomArgumentResolvers(getArgumentResolvers());<br>    adapter.setCustomReturnValueHandlers(getReturnValueHandlers());<br>       .<br>        .<br>        .<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> List&lt;HttpMessageConverter&lt;?&gt;&gt; getMessageConverters() &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.messageConverters == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-built_in">this</span>.messageConverters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-comment">//配置MessageConverters的方法</span><br>configureMessageConverters(<span class="hljs-built_in">this</span>.messageConverters);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.messageConverters.isEmpty()) &#123;<br>addDefaultHttpMessageConverters(<span class="hljs-built_in">this</span>.messageConverters);<br>&#125;<br>extendMessageConverters(<span class="hljs-built_in">this</span>.messageConverters);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.messageConverters;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>configureMessageConverters(this.messageConverters)</code>方法被父类重写了</p><blockquote><p>org.springframework.web.servlet.config.annotation.DelegatingWebMvcConfiguration#configureMessageConverters</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureMessageConverters</span><span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;<br><span class="hljs-built_in">this</span>.configurers.configureMessageConverters(converters);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面方法中啥是<code>configurers</code>？，什么时候被创建的？</p><p>我们发现<code>configurers</code>是通过创建<code>DelegatingWebMvcConfiguration</code>时，通过构造方法注入的<code>List&lt;WebMvcConfigurer&gt; configurers</code>创建的。</p><p>我们在<code>WebMvcAutoConfiguration</code>里面发现<code>WebMvcAutoConfigurationAdapter</code>类继承了<code>WebMvcConfigurer</code>，且会被自动注入到Spring内的，所以删改你创建<code>DelegatingWebMvcConfiguration</code>时使用的<code>WebMvcConfigurer</code>就是此类，此类的<code>configureMessageConverters</code>方法会对<code>HttpMessageConverter</code>进行配置。看一下它的源码。</p><blockquote><p>WebMvcAutoConfiguration#WebMvcAutoConfigurationAdapter类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">WebMvcAutoConfigurationAdapter</span><span class="hljs-params">(ResourceProperties resourceProperties, WebMvcProperties mvcProperties,</span><br><span class="hljs-params">ListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider,</span><br><span class="hljs-params">ObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider)</span> &#123;<br><span class="hljs-built_in">this</span>.resourceProperties = resourceProperties;<br><span class="hljs-built_in">this</span>.mvcProperties = mvcProperties;<br><span class="hljs-built_in">this</span>.beanFactory = beanFactory;<br><span class="hljs-built_in">this</span>.messageConvertersProvider = messageConvertersProvider;<br><span class="hljs-built_in">this</span>.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable();<br>&#125;<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureMessageConverters</span><span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;<br><span class="hljs-built_in">this</span>.messageConvertersProvider.ifAvailable((customConverters) -&gt; converters.addAll(customConverters.getConverters()));<br>&#125;<br></code></pre></td></tr></table></figure><p><code>configureMessageConverters</code>方法通过<code>messageConvertersProvider</code>来设置<code>MessageConverter</code>到list中，<code>messageConvertersProvider</code>是通过构造方法注入进来的，我们要找找<code>messageConvertersProvider</code>是什么时候注入Spring的？</p><p>顺着泛型信息，我们找到了<code>HttpMessageConvertersAutoConfiguration</code>，他也是自动配置的类，它提供了<code>HttpMessageConverters</code>这个Bean。</p><blockquote><p>org.springframework.boot.autoconfigure.http.HttpMessageConverters</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;HttpMessageConverter&lt;?&gt;&gt; converters;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HttpMessageConvertersAutoConfiguration</span><span class="hljs-params">(ObjectProvider&lt;HttpMessageConverter&lt;?&gt;&gt; convertersProvider)</span> &#123;<br><span class="hljs-built_in">this</span>.converters = convertersProvider.orderedStream().collect(Collectors.toList());<br>&#125;<br>        <br>    <span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> HttpMessageConverters <span class="hljs-title function_">messageConverters</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpMessageConverters</span>(<span class="hljs-built_in">this</span>.converters);<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>HttpMessageConverters</code>的构造方法里面是这样处理的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HttpMessageConverters</span><span class="hljs-params">(<span class="hljs-type">boolean</span> addDefaultConverters, Collection&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;<br>       <span class="hljs-comment">//注意这里的getDefaultConverters()方法</span><br>List&lt;HttpMessageConverter&lt;?&gt;&gt; combined = getCombinedConverters(converters,                                                                       addDefaultConverters ? getDefaultConverters() : Collections.emptyList());<br>combined = postProcessConverters(combined);<br><span class="hljs-built_in">this</span>.converters = Collections.unmodifiableList(combined);<br>&#125;<br></code></pre></td></tr></table></figure><p>从<code>HttpMessageConvertersAutoConfiguration</code>类里面可以看出，他本身会在构造方法里通过<code>getDefaultConverters()</code>方法创建默认的<code>MessageConverter</code>,其次他还会通过<code>HttpMessageConvertersAutoConfiguration</code>的构造方法注入外界的<code>HttpMessageConverter</code>，合并在一起。</p><p>下面看看构造方法里的<code>ObjectProvider&lt;HttpMessageConverter&lt;?&gt;&gt; convertersProvider</code>里面从哪里来的？</p><p>我们发现两个地方创建了<code>MessageConverter</code>。</p><blockquote><p>一个是org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration.StringHttpMessageConverterConfiguration里面创建的<code>StringHttpMessageConverter</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(StringHttpMessageConverter.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(HttpProperties.class)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringHttpMessageConverterConfiguration</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HttpProperties.Encoding properties;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">StringHttpMessageConverterConfiguration</span><span class="hljs-params">(HttpProperties httpProperties)</span> &#123;<br><span class="hljs-built_in">this</span>.properties = httpProperties.getEncoding();<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> StringHttpMessageConverter <span class="hljs-title function_">stringHttpMessageConverter</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">StringHttpMessageConverter</span> <span class="hljs-variable">converter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringHttpMessageConverter</span>(<span class="hljs-built_in">this</span>.properties.getCharset());<br>converter.setWriteAcceptCharset(<span class="hljs-literal">false</span>);<br><span class="hljs-keyword">return</span> converter;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>另一个是org.springframework.boot.autoconfigure.http.JacksonHttpMessageConvertersConfiguration.MappingJackson2HttpMessageConverterConfiguration创建的<code>MappingJackson2HttpMessageConverter</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean(value = MappingJackson2HttpMessageConverter.class,</span><br><span class="hljs-meta">ignoredType = &#123; &quot;org.springframework.hateoas.mvc.TypeConstrainedMappingJackson2HttpMessageConverter&quot;,</span><br><span class="hljs-meta">&quot;org.springframework.data.rest.webmvc.alps.AlpsJsonHttpMessageConverter&quot; &#125;)</span><br><span class="hljs-keyword">public</span>  <span class="hljs-title function_">mappingJackson2HttpMessageConverter</span><span class="hljs-params">(ObjectMapper objectMapper)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MappingJackson2HttpMessageConverter</span>(objectMapper);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这就解释了为什么<code>HandlerAdapter</code>里面会有<code>MappingJackson2HttpMessageConverter</code>了。</p><p>原来是创建<code>HandlerAdapter</code>时的<code>getHandlerMessages</code>方法做了这些工作。</p><h2 id="定制MappingJackson2HttpMessageConverter"><a href="#定制MappingJackson2HttpMessageConverter" class="headerlink" title="定制MappingJackson2HttpMessageConverter"></a>定制MappingJackson2HttpMessageConverter</h2><p>上面解释了<code>HandlerAdapter</code>里面的<code>HandlerMessage</code>是怎么来的。</p><p>但又有一个疑问，问什么我们在<code>Springboot</code>的配置文件里能配置<code>JacksonMessageConverter</code>工作的？</p><p>我们知道<code>MappingJackson2HttpMessageConverter</code>处理的核心功能是由<code>ObjectMapper</code>提供的，所有配置都在<code>ObjectMapper</code>里，所以创建<code>MappingJackson2HttpMessageConverter</code>时传入的<code>ObjectMapper</code>是经过<code>Springboot</code>创建并根据配置文件配置过的。</p><p>疑问是<code>ObjectMapper</code>是什么时候创建的？如何被配置的？</p><p>我又找到了这个类<code>JacksonAutoConfiguration</code>,也是一个自动配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(Jackson2ObjectMapperBuilder.class)</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JacksonObjectMapperConfiguration</span> &#123;<br><br>      <span class="hljs-comment">//通过Jackson2ObjectMapperBuilder创建ObjectMapper</span><br>       <span class="hljs-meta">@Bean</span><br>       <span class="hljs-meta">@Primary</span><br>       <span class="hljs-meta">@ConditionalOnMissingBean</span><br>       <span class="hljs-keyword">public</span> ObjectMapper <span class="hljs-title function_">jacksonObjectMapper</span><span class="hljs-params">(Jackson2ObjectMapperBuilder builder)</span> &#123;<br><span class="hljs-keyword">return</span> builder.createXmlMapper(<span class="hljs-literal">false</span>).build();<br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">//通过Jackson2ObjectMapperBuilderCustomizer创建Jackson2ObjectMapperBuilder</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> Jackson2ObjectMapperBuilder <span class="hljs-title function_">jacksonObjectMapperBuilder</span><span class="hljs-params">(</span><br><span class="hljs-params">List&lt;Jackson2ObjectMapperBuilderCustomizer&gt; customizers)</span> &#123;<br><span class="hljs-type">Jackson2ObjectMapperBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2ObjectMapperBuilder</span>();<br>builder.applicationContext(<span class="hljs-built_in">this</span>.applicationContext);<br>customize(builder, customizers);<br><span class="hljs-keyword">return</span> builder;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">创建StandardJackson2ObjectMapperBuilderCustomizer的过程，使用了JacksonProperties</span><br><span class="hljs-comment">而JacksonProperties就对应了Springboot的配置文件里面的“spring.jackson”开始的配置</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> StandardJackson2ObjectMapperBuilderCustomizer <span class="hljs-title function_">standardJacksonObjectMapperBuilderCustomizer</span><span class="hljs-params">(</span><br><span class="hljs-params">ApplicationContext applicationContext, JacksonProperties jacksonProperties)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardJackson2ObjectMapperBuilderCustomizer</span>(applicationContext, jacksonProperties);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面<code>ObjectMapper</code>的创建过程也就能看出为什么<code>application.yml</code>里的配置能影响到<code>ObjectMapper</code>的行为了。</p><h2 id="反向总结一下"><a href="#反向总结一下" class="headerlink" title="反向总结一下"></a>反向总结一下</h2><p><code>application.yml</code>中的<code>jackson</code>配置，</p><p>导致<code>JacksonProperties</code>里面的属性变化，</p><p>导致<code>JacksonAutoConfiguration</code>里面的<code>StandardJackson2ObjectMapperBuilderCustomizer</code>变化，</p><p>导致<code>JacksonAutoConfiguration</code>里面的<code>Jackson2ObjectMapperBuilder</code>变化，</p><p>导致创建的<code>JacksonAutoConfiguration</code>里面的<code>ObjectMapper</code>属性变化，然后<code>ObjectMapper</code>被注入<code>Spring</code></p><p>然后<code>JacksonHttpMessageConvertersConfiguration</code>里面创建<code>MappingJackson2HttpMessageConverter</code> 时从Spring获取<code>ObjectMapper</code>。</p><p><code>HttpMessageConvertersAutoConfiguration</code>里面创建<code>HttpMessageConverters</code>时从<code>Spring</code>获取<code>Jakson2HttmMessageConverter</code> 。</p><p><code>WebMvcAutoConfiguration</code>创建<code>RequestMappingHandlerMapperAdapter</code> 时从容器获取了<code>HttpMessageConverters</code>，然后设置到<code>RequestResponseBodyMethodProcessor</code>里面。</p><p>然后<code>RequestResponseBodyMethodProcessor</code>使用<code>Jakson2HttmMessageConverter</code> 处理<code>Controller</code>的返回值，也就实现了根据配置文件来定制返回J<code>Json</code>的行为了。</p><h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2><p>但大家一定也遇到入：</p><p>​配置文件里配置列<code>Jackson</code>但不生效？</p><p>​自己手动创建<code>ObjectMapper</code>来代替<code>Springboot</code>帮我们创建的，但不生效？</p><p>​如何做才是最佳实践？</p><p>下篇讲讲上面三个问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>jackson</tag>
      
      <tag>HttpMessageConverter</tag>
      
      <tag>json</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓手机usb共享网络导致window10底部卡住</title>
    <link href="/2275841253.html"/>
    <url>/2275841253.html</url>
    
    <content type="html"><![CDATA[<p>​家里网络不好，手机开热点不稳定，所以使用手机的usb共享网络供电脑上网，但在window10下会导致底部状态栏卡死的现象，使用下面的方法能够解决问题。</p><p><img src="/img/in/2020-02-13-%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BAusb%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C%E5%AF%BC%E8%87%B4window10%E5%BA%95%E9%83%A8%E5%8D%A1%E4%BD%8F/image-20200213230329377.png" alt="image-20200213230329377"></p>]]></content>
    
    
    
    <tags>
      
      <tag>usb共享网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次跨域问题</title>
    <link href="/736025888.html"/>
    <url>/736025888.html</url>
    
    <content type="html"><![CDATA[<p><code>springboot</code>项目，后台已经配置好允许跨域，但前台仍是报跨域问题无法通过，追踪源码+debug发现原因，这里记录一下。</p><p>案发场景：</p><ol><li>springboot项目。</li><li>已重写<code>WebMvcConfigurationSupport</code>的<code>addCorsMappings(CorsRegistry registry)</code> 方法，并添加了允许跨域的逻辑。</li><li>跨域的原因是在http协议下发送https请求，引起的跨域。</li></ol><p>找到原因：</p><p>查看日志，发现<code>springboot</code>的 <code>DefaultCorsProcessor</code> 这个类对此请求的判断为同源的，没有做处理，就直接放行了。</p><p>明明浏览器发出请求是https，而页面是http为什么框架会判断成同源的呢？？？</p><p>据此联想到出，是因为页面是<code>http</code>的，发送<code>https</code>的请求，浏览器判断是跨域的所以添加了<code>origin</code>头表明请求页面的源地址。</p><p>然而请求到达<code>nginx</code>后，<code>nginx</code>验证<code>https</code>证书等处理后，使用<code>http</code>协议再次将请求发送给<code>tomcat</code>，后台收到的请求实际上是<code>nginx</code>使用<code>http</code>协议发送的请求。</p><p>然后框架处理跨域时发现请求中的<code>origin</code>和<code>host</code>同是http请求不存在跨域问题，也就不做跨域处理。结果返回到浏览器后，浏览器发现没有跨域的响应头，屏蔽掉了结果，导致浏览器报跨域错误。</p>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次Jackson引发的血案</title>
    <link href="/2519329010.html"/>
    <url>/2519329010.html</url>
    
    <content type="html"><![CDATA[<h1 id="记一次Jackson引发的血案"><a href="#记一次Jackson引发的血案" class="headerlink" title="记一次Jackson引发的血案"></a>记一次Jackson引发的血案</h1><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>昨天修改项目，想用<code>Jackson</code>逐渐替换项目中使用的<code>Fastjson</code>，项目较旧，已经配置了<code>FastJsonHttpMessageConverter</code>用于<code>springmvc</code>的返回值序列化，这是前提。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>既然是用了Jackson解析json，有几个接口返回值里里有<code>JsonNode</code>类型，这是<code>jackson</code>的类，<code>FastJson</code>无法序列化，所以配置文件里添加了<code>MappingJackson2HttpMessageConverter</code>替代<code>FastJsonHttpMessageConverter</code>。</p><p>替换过后能序列化<code>JsonNode</code>了，但ios设备闪退…</p><p>到公司检查逻辑，默认情况下的<code>MappingJackson2HttpMessageConverter</code>会将值为null的数据序列化成null，而<code>FastJson</code>的会删除null值。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">//fastJson的返回值，b被删除了</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br><span class="hljs-comment">//Jackson的返回值</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;a&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-attr">&quot;b&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">null</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>看上面的对比，若b为<code>null</code>的情况下，均在默认情况下，<code>FastJson</code>会删除该键值对，<code>Jackson</code>会序列化成<code>&quot;b&quot;:null</code>。</p><p>估计是<code>iso</code>用的反序列化工具不支持值为null的情况导致的闪退。安卓的不会有问题。</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>在配置文件里定制<code>MappingJackson2HttpMessageConverter</code>,让其忽略值为null的数据，解决问题。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jacksonHttpMessageConverter&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;objectMapper&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--值为null时不返回--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;serializationInclusion&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">util:constant</span> <span class="hljs-attr">static-field</span>=<span class="hljs-string">&quot;com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--返回时间格式--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dateFormat&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;java.text.SimpleDateFormat&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>代码可以这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);<br><br></code></pre></td></tr></table></figure><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p><code>JsonNode</code>里面的<code>NullNode</code>因为不属于null，所以仍然会序列化成null，简单点的办法就是序列化之前遍历移出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeNullNode</span><span class="hljs-params">(JsonNode nodes)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nodes.isArray()) &#123;<br>        Iterator&lt;JsonNode&gt; iterator = nodes.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-type">JsonNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> iterator.next();<br>            <span class="hljs-keyword">if</span> (next.isNull()) &#123;<br>                iterator.remove();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                removeNullNode(next);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodes.isObject()) &#123;<br>        <span class="hljs-type">ObjectNode</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> (ObjectNode) nodes;<br>        Iterator&lt;Map.Entry&lt;String, JsonNode&gt;&gt; fields = os.fields();<br>        <span class="hljs-keyword">while</span> (fields.hasNext()) &#123;<br>            Map.Entry&lt;String, JsonNode&gt; next = fields.next();<br>            <span class="hljs-keyword">if</span> (next.getValue().isNull()) &#123;<br>                fields.remove();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                removeNullNode(next.getValue());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><p>2020-05-08更新：</p><p>​有一个小坑，如果发现返回值对象中的字段为null能屏蔽，返回map内value为null不能屏蔽，请考虑下升级<code>jackson</code>版本，高版本能解决这个问题。</p><p>​我用的<code>2.10.1</code>可以屏蔽map中的null值。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>jackson</tag>
      
      <tag>springmvc返回值过滤null</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jekyll制作sitemap</title>
    <link href="/2839707912.html"/>
    <url>/2839707912.html</url>
    
    <content type="html"><![CDATA[<h1 id="jekyll制作sitemap"><a href="#jekyll制作sitemap" class="headerlink" title="jekyll制作sitemap"></a>jekyll制作sitemap</h1><p>jekyll提供制作sitemap的插件，如果不通过插件制作的话可以写一个<code>sitemap.xml</code>模板，模板内遍历文章列表，生成sitemap。</p><p>以下是我的模板，根据参考文章中改的。</p><p>将下面代码复制到项目根目录，命名为<code>sitemap.xml</code>，这样生成的sitemap就会在站点根目录下即可。</p><p>需要<code>_config.yml</code>文件内有一个<code>sitemapUrl</code>变量来作为sitemap的url，拼接在文章相对地址前面。</p><p>上面一部分循环所有文章，下面一部分循环所有除文章外的page，我把带xml的排出了，因为有一个rss订阅相关的<code>feed.xml</code>不希望显示在站点地图里。</p><p><img src="/img/in/2019-12-19-jekyll%E5%88%B6%E4%BD%9Csitemap/image-20191219120135944.png" alt="image-20191219120135944"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://support.google.com/webmasters/answer/183668?hl=zh-Hans">谷歌给的站点地图指南，站点地图各项的意义</a></p><p><a href="http://davidensinger.com/2013/11/building-a-better-sitemap-xml-with-jekyll/">某人写的生成站点地图模板，我是根据这个改的</a></p><p><a href="http://blog.sina.com.cn/s/blog_6a3c6f810100zq72.html">sitemap.xml的写法</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>gitpage</tag>
      
      <tag>jekyll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Feign多种类型的POST</title>
    <link href="/3460669771.html"/>
    <url>/3460669771.html</url>
    
    <content type="html"><![CDATA[<h1 id="Feign多种类型的POST"><a href="#Feign多种类型的POST" class="headerlink" title="Feign多种类型的POST"></a>Feign多种类型的POST</h1><ul><li>TOC<br>{:toc}</li></ul><h2 id="三种携带请求体的方式"><a href="#三种携带请求体的方式" class="headerlink" title="三种携带请求体的方式"></a>三种携带请求体的方式</h2><p>前文<a href="/2019/12/17/openFeign-%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD/">Feign高级功能</a>说了，Feign有三种方式实现请求体，分别是</p><ul><li>使用<code>@Body</code>注解</li><li>使用一个不加注解的参数</li><li>使用若干个添加<code>@Param</code>但未在<code>@ReqeustLine、@Heads...</code>等地方使用的参数</li></ul><h2 id="POST的三种常见ContentType"><a href="#POST的三种常见ContentType" class="headerlink" title="POST的三种常见ContentType"></a>POST的三种常见ContentType</h2><p>而http的post有三种类型，分别是：</p><ul><li>application&#x2F;json</li><li>x-<a href="http://www.form-urlencoded/">www.form-urlencoded</a></li><li>form-data</li></ul><p>下面按照这三种<code>ContentType</code>分别讨论一下。</p><h2 id="1-发送application-json格式的请求体"><a href="#1-发送application-json格式的请求体" class="headerlink" title="1.发送application/json格式的请求体"></a>1.发送<code>application/json</code>格式的请求体</h2><p>发送此类post请求，需要添加头部<code>@Heads(&quot;Content-Type:application/json&quot;)</code></p><h3 id="使用-Body发送"><a href="#使用-Body发送" class="headerlink" title="使用@Body发送"></a>使用<code>@Body</code>发送</h3><blockquote><p> 注意使用<code>@Body</code>的方式构建请求体，别忘了注解中的值左右两遍的大括号需要转义。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestJson</span> &#123;<br><br>     <span class="hljs-meta">@RequestLine(value = &quot;POST /test&quot;)</span><br>     <span class="hljs-meta">@Body(&quot;%7B\&quot;user_name\&quot;:\&quot;&#123;userName&#125;\&quot;%7D&quot;)</span><br>     <span class="hljs-meta">@Headers(&quot;Content-Type:application/json&quot;)</span><br>     Response <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;userName&quot;)</span> String userName)</span>;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="使用不加注解的参数"><a href="#使用不加注解的参数" class="headerlink" title="使用不加注解的参数"></a>使用不加注解的参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestJson2</span> &#123;<br>    <span class="hljs-meta">@RequestLine(value = &quot;POST /test&quot;)</span><br>    <span class="hljs-meta">@Headers(&quot;Content-Type:application/json&quot;)</span><br>    Response <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(TestParam body)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TestJson2</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Feign.builder()<br>        .encoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JacksonEncoder</span>())<br>        .target(TestJson2.class, <span class="hljs-string">&quot;http://localhost:8081&quot;</span>);<br><br>target.getItemCoupon(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestParam</span>(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>));<br></code></pre></td></tr></table></figure><blockquote><p>接口中有一个没有注解的参数<code>TestParam</code>，build时需要配置<code>JacksonEncoder</code>来处理它，将<code>TestParam</code>序列化成JSON字符串作为请求体。</p></blockquote><h3 id="使用没有使用的-Param-参数"><a href="#使用没有使用的-Param-参数" class="headerlink" title="使用没有使用的@Param 参数"></a>使用没有使用的<code>@Param</code> 参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestJson3</span> &#123;<br>    <span class="hljs-meta">@RequestLine(value = &quot;POST /test&quot;)</span><br>    <span class="hljs-meta">@Headers(&quot;Content-Type:application/json&quot;)</span><br>    Response <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;userName&quot;)</span> String userName, <span class="hljs-meta">@Param(&quot;password&quot;)</span> String passWord)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TestJson2</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Feign.builder()<br>               .encoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JacksonEncoder</span>())<br>               .target(TestJson2.class, <span class="hljs-string">&quot;http://localhost:8081&quot;</span>);<br><br>       target.getItemCoupon(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;password&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>请看接口中有两个参数，但没有被使用，那么这两个参数就会组成一个<code>Map</code>,然后被配置的<code>JacksonEncoder</code>转成json字符串作为请求体。</p></blockquote><h3 id="结果报文"><a href="#结果报文" class="headerlink" title="结果报文"></a>结果报文</h3><p><img src="/img/in/2019-12-18-openFeign-%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84POST/image-20191218180418698.png" alt="image-20191218180418698"></p><h2 id="2-发送x-www-form-urlencoded格式的post请求"><a href="#2-发送x-www-form-urlencoded格式的post请求" class="headerlink" title="2.发送x-www-form-urlencoded格式的post请求"></a>2.发送<code>x-www-form-urlencoded</code>格式的post请求</h2><h3 id="使用-Body发送-1"><a href="#使用-Body发送-1" class="headerlink" title="使用@Body发送"></a>使用<code>@Body</code>发送</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestWwwFormUrlencoded</span> &#123;<br>    <span class="hljs-meta">@RequestLine(value = &quot;POST /test&quot;)</span><br>    <span class="hljs-meta">@Headers(&quot;Content-Type:application/x-www-form-urlencoded&quot;)</span><br>    <span class="hljs-meta">@Body(&quot;name=&#123;name&#125;&amp;age=&#123;age&#125;&quot;)</span><br>    Response <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String name, <span class="hljs-meta">@Param(&quot;age&quot;)</span> Integer age)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TestWwwFormUrlencoded</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Feign.builder()<br>        .target(TestWwwFormUrlencoded.class, <span class="hljs-string">&quot;http://localhost:8081&quot;</span>);<br><span class="hljs-type">Response</span> <span class="hljs-variable">xiao</span> <span class="hljs-operator">=</span> target.getItemCoupon(UriUtils.encode(<span class="hljs-string">&quot;小明&quot;</span>), <span class="hljs-number">18</span>);<br><br></code></pre></td></tr></table></figure><blockquote><p>这样的用法要注意两点，1.需要自己手工处理url编码,2.需要自己拼接参数，且数量有限。</p><p>虽然能写任意字符串拼接到body中，但是很麻烦不推荐这种用法。</p></blockquote><h3 id="使用不加注解的参数-1"><a href="#使用不加注解的参数-1" class="headerlink" title="使用不加注解的参数"></a>使用不加注解的参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestWwwFormUrlencoded2</span> &#123;<br>    <span class="hljs-meta">@RequestLine(value = &quot;POST /test&quot;)</span><br>    <span class="hljs-meta">@Headers(&quot;Content-Type:application/x-www-form-urlencoded&quot;)</span><br>    Response <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(String param)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果这样的话，传参需要自己拼接参数，还要自己url转码，很麻烦不推荐。</p></blockquote><p>使用map来接收参数，并配合自定义encoder处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestWwwFormUrlencoded3</span> &#123;<br>    <span class="hljs-meta">@RequestLine(value = &quot;POST /test&quot;)</span><br>    <span class="hljs-meta">@Headers(&quot;Content-Type:application/x-www-form-urlencoded&quot;)</span><br>    Response <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(Map&lt;String, Object&gt; params)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WwwEncode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Encoder</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(Object object, Type bodyType, RequestTemplate template)</span> <span class="hljs-keyword">throws</span> EncodeException &#123;<br>        Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) object;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        map.forEach((k, v) -&gt; &#123;<br>            list.add(UriUtils.encode(k) + <span class="hljs-string">&quot;=&quot;</span> + UriUtils.encode(String.valueOf(v)));<br>        &#125;);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> String.join(<span class="hljs-string">&quot;&amp;&quot;</span>, list);<br>        template.body(Request.Body.encoded(body.getBytes(), StandardCharsets.UTF_8));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这样比第一种方法方便点，但掉用时传递的参数是map，在不确定参数数目是很好用，但不利于识别，也不推荐。</p></blockquote><h3 id="使用没有使用的-Param-参数-1"><a href="#使用没有使用的-Param-参数-1" class="headerlink" title="使用没有使用的@Param 参数"></a>使用没有使用的<code>@Param</code> 参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestWwwFormUrlencoded4</span> &#123;<br>    <span class="hljs-meta">@RequestLine(value = &quot;POST /test&quot;)</span><br>    <span class="hljs-meta">@Headers(&quot;Content-Type:application/x-www-form-urlencoded&quot;)</span><br>    Response <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String userName, <span class="hljs-meta">@Param(&quot;age&quot;)</span> String passWord)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WwwEncode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Encoder</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(Object object, Type bodyType, RequestTemplate template)</span> <span class="hljs-keyword">throws</span> EncodeException &#123;<br>        Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) object;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        map.forEach((k, v) -&gt; &#123;<br>            list.add(UriUtils.encode(k) + <span class="hljs-string">&quot;=&quot;</span> + UriUtils.encode(String.valueOf(v)));<br>        &#125;);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> String.join(<span class="hljs-string">&quot;&amp;&quot;</span>, list);<br>        template.body(Request.Body.encoded(body.getBytes(), StandardCharsets.UTF_8));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Feign会把参数放到一个map里，传入<code>encoder</code>中。</p><p>同样需要encoder，，这种方法在确定参数数量的情况下比较好用，并且有参数名的提示，比上面那种方法用着舒服点，但要求固定的参数数量，多数情况下都是这样的。</p><p>并且可以同时使用<code>@QueryMap</code>注解，将多余的注解拼在url上，虽然不太好，但也是可以的。</p></blockquote><h3 id="结果报文-1"><a href="#结果报文-1" class="headerlink" title="结果报文"></a>结果报文</h3><p><img src="/img/in/2019-12-18-openFeign-%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84POST/image-20191218180217041.png" alt="image-20191218180217041"></p><h2 id="3-发送form-data格式的请求"><a href="#3-发送form-data格式的请求" class="headerlink" title="3. 发送form-data格式的请求"></a>3. 发送<code>form-data</code>格式的请求</h2><blockquote><p>这种格式主要用于上传文件，但Feign上传文件还是挺麻烦的，这里不讲上传文件的方法。如果服务端必须要求是<code>form-data</code>格式的请求，Feign也能实现，下面讲讲feign使用<code>form-data</code>发送post请求。</p></blockquote><h3 id="form-data介绍"><a href="#form-data介绍" class="headerlink" title="form-data介绍"></a>form-data介绍</h3><blockquote><p>因为上面讲到的<code>x-www-form-urlencoded</code>形式的请求需要把字符进行url编码，这样体积一下就大了很多，而且不能用法发文件，所以<code>form-data</code>格式就被发明出来了。它使用一个约定好的符号进行分隔参数。报文如下</p></blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/test</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>localhost:8081<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>localhost:8081<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>266<br><br><span class="language-haskell"><span class="hljs-comment">------WebKitFormBoundary7MA4YWxkTrZu0gW</span></span><br><span class="language-haskell"><span class="hljs-type">Content</span>-<span class="hljs-type">Disposition</span>: form-<span class="hljs-class"><span class="hljs-keyword">data</span>; name=&quot;name&quot;</span></span><br><span class="language-haskell"></span><br><span class="language-haskell"><span class="hljs-title">abc</span></span><br><span class="language-haskell"><span class="hljs-comment">------WebKitFormBoundary7MA4YWxkTrZu0gW</span></span><br><span class="language-haskell"><span class="hljs-type">Content</span>-<span class="hljs-type">Disposition</span>: form-<span class="hljs-class"><span class="hljs-keyword">data</span>; name=&quot;age&quot;</span></span><br><span class="language-haskell"></span><br><span class="language-haskell"><span class="hljs-number">18</span></span><br><span class="language-haskell"><span class="hljs-comment">------WebKitFormBoundary7MA4YWxkTrZu0gW--</span></span><br></code></pre></td></tr></table></figure><blockquote><p>上面的报文可以看出请求体部分是由boundary开始，由参数值结束。</p><p><img src="/img/in/2019-12-18-openFeign-%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84POST/image-20191218181740787.png" alt="image-20191218181740787"></p><p>boundary在请求头中约定好，且用于参数分隔的boundary要比请求头中定义的多了两个<code>--</code>。</p><p>最后收尾的boundary的尾部再多了两个<code>–-</code></p><p>所以真正的请求体格式是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">设 bound = <span class="hljs-number">111</span><br><br>--<span class="hljs-number">111</span><br>Content-Disposition: form-data; name=<span class="hljs-string">&quot;name&quot;</span><br><br>abc<br>--<span class="hljs-number">111</span><br>Content-Disposition: form-data; name=<span class="hljs-string">&quot;age&quot;</span><br><br><span class="hljs-number">18</span><br>--<span class="hljs-number">111</span>--<span class="hljs-comment">//boundary比head中定义的多两个`--`，收尾的又在尾部多两个`--`</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="使用-Body发送-2"><a href="#使用-Body发送-2" class="headerlink" title="使用@Body发送"></a>使用<code>@Body</code>发送</h3><ul><li>处理不了，在Body注解中拼接请求体太麻烦了，所以不采用这种方式。</li></ul><h3 id="使用不加注解的参数-2"><a href="#使用不加注解的参数-2" class="headerlink" title="使用不加注解的参数"></a>使用不加注解的参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestFormData</span> &#123;<br>    <span class="hljs-meta">@RequestLine(value = &quot;POST /test&quot;)</span><br>    Response <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义自定义encoder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FormDataencodedPost</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Encoder</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(Object object, Type bodyType, RequestTemplate template)</span> <span class="hljs-keyword">throws</span> EncodeException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">boundary</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;--------------&quot;</span> + System.currentTimeMillis();<br>        Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) object;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        map.forEach((k, v) -&gt; &#123;<br>            sb.append(<span class="hljs-string">&quot;--&quot;</span>).append(boundary).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>            sb.append(<span class="hljs-string">&quot;Content-Disposition: form-data; name=\&quot;&quot;</span>).append(k).append(<span class="hljs-string">&quot;\&quot;&quot;</span>).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>            sb.append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>            sb.append(v).append(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>        &#125;);<br>        sb.append(<span class="hljs-string">&quot;--&quot;</span>).append(boundary).append(<span class="hljs-string">&quot;--\r\n&quot;</span>);<br>        template.body(Request.Body.encoded(sb.toString().getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8));<br><br>        template.removeHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>);<br>        template.header(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;multipart/form-data; boundary=&quot;</span> + boundary);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TestFormData</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Feign.builder()<br>        .encoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FormDataencodedPost</span>())<br>        .target(TestFormData.class, <span class="hljs-string">&quot;http://localhost:8081&quot;</span>);<br><br>HashMap&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>params.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;老王&quot;</span>);<br>params.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-number">12</span>);<br><br>target.getItemCoupon(params);<br></code></pre></td></tr></table></figure><blockquote><ul><li>参数是map，所以此处<code>encoder</code>中拿到的参数就是map，然后遍历map，将参数和值拼接成上面讲的<code>form-data</code>所需的形式。</li><li>boundary使用的是<code>-----</code>+<code>时间戳</code>的形式，也可以用其他随机生成的方式，for循环里面拼接boundary时，在每个boundary前面添加两个<code>-</code>，然后注意<code>\r\n</code>别遗漏了。</li><li>参数循环拼接完成后在最后面在添加一个收尾的boundary，此boundary的前后各添加两个<code>-</code>。</li><li>还要注意的一点时，先清空<code>Content-Type</code>再添加<code>Content-Type</code>，讲boundary设进去。</li></ul></blockquote><h3 id="使用没有使用的-Param-参数-2"><a href="#使用没有使用的-Param-参数-2" class="headerlink" title="使用没有使用的@Param 参数"></a>使用没有使用的<code>@Param</code> 参数</h3><p>​使用这个其实也是讲参数封装成map进行<code>encoder</code>和上面是一样的这里就不写了。</p><h3 id="结果报文-2"><a href="#结果报文-2" class="headerlink" title="结果报文"></a>结果报文</h3><blockquote><p><img src="/img/in/2019-12-18-openFeign-%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84POST/image-20191218183647159.png" alt="image-20191218183647159"></p></blockquote><p><code>form-data</code>的拼接方式比较复杂，如果发送完后台接收不到数据，请仔细核对报文格式是否正确。可以打开<code>WireShark</code>抓包，再用其他工具进行正常的post，仔细比对两者报文的差异。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是使用Feign发送三种类型的POST请求的方法，业务上需要的场景一般就都能满足了，案例中用到的<code>encoder</code>写的比较简单，真实使用时请注意参数校验，处理好异常情况，或写更通用的<code>encoder</code>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>openfeign</tag>
      
      <tag>Http客户端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Feign高级功能</title>
    <link href="/1305379791.html"/>
    <url>/1305379791.html</url>
    
    <content type="html"><![CDATA[<h1 id="Feign高级功能"><a href="#Feign高级功能" class="headerlink" title="Feign高级功能"></a>Feign高级功能</h1><ul><li>TOC<br>{:toc}</li></ul><h2 id="动态修改请求地址"><a href="#动态修改请求地址" class="headerlink" title="动态修改请求地址"></a>动态修改请求地址</h2><p>像这样，创建接口时放置一个类型为<code>java.net.URI</code>的参数，这样真正发送请求时就会以此uri为准。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">dyPath</span> &#123;<br>    <span class="hljs-meta">@RequestLine(&quot;GET /get/item&quot;)</span><br>    String <span class="hljs-title function_">getItem</span><span class="hljs-params">(URI uri)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态请求配置Options"><a href="#动态请求配置Options" class="headerlink" title="动态请求配置Options"></a>动态请求配置Options</h2><p>放置一个类型为<code>Options</code>的参数在接口中，这样发送请求时就会使用此类作为配置，否则会使用默认的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">dyPath</span> &#123;<br>    <span class="hljs-meta">@RequestLine(&quot;GET /get/item&quot;)</span><br>    String <span class="hljs-title function_">getItem</span><span class="hljs-params">(Request.Options options)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>源码在这里:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//feign.SynchronousMethodHandler#191  </span><br>Options <span class="hljs-title function_">findOptions</span><span class="hljs-params">(Object[] argv)</span> &#123;<br>    <span class="hljs-keyword">if</span> (argv == <span class="hljs-literal">null</span> || argv.length == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.options;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Stream.of(argv)<br>        .filter(Options.class::isInstance)<br>        .map(Options.class::cast)<br>        .findFirst()<br>        .orElse(<span class="hljs-built_in">this</span>.options);<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="QueryMap注解"><a href="#QueryMap注解" class="headerlink" title="@QueryMap注解"></a>@QueryMap注解</h2><ul><li><p>这个注解如果注在Map上，此Map的键只能是String类型的如<code>Map&lt;String,Object&gt;</code>，其他类型会报错。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//源码在这里: feign.Contract.BaseContract#checkMapKeys</span><br>    <span class="hljs-keyword">if</span> (keyClass != <span class="hljs-literal">null</span>) &#123;<br>        checkState(String.class.equals(keyClass),<br>                   <span class="hljs-string">&quot;%s key must be a String: %s&quot;</span>, name, keyClass.getSimpleName());<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>如果在<code>@RequestLine</code>的链接中放置了参数， <code>@QueryMap</code>中有同名参数是一个空集合，则会把前面的参数删掉，所以想要删除某参数，也可以直接设置一个空集合参数，同理添加heads也有这样的删除策略。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fq</span> &#123;<br>        <span class="hljs-meta">@RequestLine(value = &quot;GET /cms/materials/create?username=&#123;username&#125;&quot;)</span><br>        String <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(<span class="hljs-meta">@Param(value = &quot;username&quot;)</span> String username</span><br><span class="hljs-params">                        , <span class="hljs-meta">@QueryMap</span> Map&lt;String, Object&gt; params)</span>;<br>    &#125;<br><br><span class="hljs-comment">//调用过程</span><br>     HashMap&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>     params.put(<span class="hljs-string">&quot;username&quot;</span>, Collections.emptyList());<br>     <span class="hljs-type">String</span> <span class="hljs-variable">itemCoupon</span> <span class="hljs-operator">=</span> target.getItemCoupon(<span class="hljs-string">&quot;小明&quot;</span>, params);<br><br><span class="hljs-comment">//参数Map里面有一‘username’和链接上的参数同名了，且是一个空集合，即使链接上的`username`有值，也会导致username参数被删除</span><br><br><span class="hljs-comment">//实际访问地址 GET http://localhost/create HTTP/1.1</span><br><br></code></pre></td></tr></table></figure></li><li><p><code>@QueryMap</code>解析出来的参数只会拼接在url后面，不会当成请求体,无论请求类型是什么。</p><blockquote><p> 有时候post请求不希望参数拼在链接后面，就不能用这个了。</p></blockquote></li></ul><h2 id="Param注解注意事项"><a href="#Param注解注意事项" class="headerlink" title="@Param注解注意事项"></a>@Param注解注意事项</h2><p>注解标记的参数，如果没有在任何地方被使用，则会被放入<code>MethodMetadata</code>的<code>formParams</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">super</span>.registerParameterAnnotation(Param.class, (paramAnnotation, data, paramIndex) -&gt; &#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> paramAnnotation.value();<br>  checkState(emptyToNull(name) != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Param annotation was empty on param %s.&quot;</span>,<br>      paramIndex);<br>  nameParam(data, name, paramIndex);<br>  Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Param</span>.Expander&gt; expander = paramAnnotation.expander();<br>  <span class="hljs-keyword">if</span> (expander != Param.ToStringExpander.class) &#123;<br>    data.indexToExpanderClass().put(paramIndex, expander);<br>  &#125;<br>  data.indexToEncoded().put(paramIndex, paramAnnotation.encoded());<br>  <span class="hljs-comment">//这里检测，没有任何地方使用它，则放入formParams中</span><br>  <span class="hljs-keyword">if</span> (!data.template().hasRequestVariable(name)) &#123;<br>    data.formParams().add(name);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>如下面写法的两个参数<code>name</code>和<code>age</code> 就是未使用因为<code>RequestLine</code>和<code>Headers</code>没有用它:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestJson</span> &#123;<br>    <span class="hljs-meta">@RequestLine(value = &quot;POST /test&quot;)</span><br>    <span class="hljs-meta">@Headers(&quot;Content-Type:application/json&quot;)</span><br>    Response <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String name,<span class="hljs-meta">@Param(&quot;age&quot;)</span> Integer age)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在发送请求时，会将他们组成一个map然后传入encoder中进行编码，编码后的结果作为请求的<code>body</code>使用，而默认的encoder不能处理map类型的，会报错.</p><p><code>feign.codec.EncodeException: class java.util.LinkedHashMap is not a type supported by this encoder</code></p><p>添加一个<code>JacksonEncoder</code>后可以将他们序列化成JSON字符串作为请求<code>body</code>,即使是GET请求也会变成请求body，所以如果这不是你想要的结果，就不要添加了参数却不使用它。</p><p>如果不想将他们转成JSON，可以自己写encoder来处理 。</p><h2 id="没有加任何注解的参数"><a href="#没有加任何注解的参数" class="headerlink" title="没有加任何注解的参数"></a>没有加任何注解的参数</h2><p>默认情况下允许存在<code>一个</code>没有注解的参数（注意URI不包括在内），将它的参数索引设置成<code>MeteDate</code>的<code>bodyIndex</code>，发送请求前，会把这个参数的值取出来，然后调用<code>encoder</code>进行编码，编码的结果当成请求<code>body</code>使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// feign.Contract.BaseContract#parseAndValidateMetadata()</span><br><br><span class="hljs-comment">//参数类型为接口的class类，需要解析的method</span><br><span class="hljs-keyword">protected</span> MethodMetadata <span class="hljs-title function_">parseAndValidateMetadata</span><span class="hljs-params">(Class&lt;?&gt; targetType, Method method)</span> &#123;<br>      <span class="hljs-type">MethodMetadata</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodMetadata</span>();<br>      data.targetType(targetType);<br>      data.method(method);<br>      data.returnType(Types.resolve(targetType, targetType, method.getGenericReturnType()));<br>      data.configKey(Feign.configKey(targetType, method));<br><br>      <span class="hljs-keyword">if</span> (targetType.getInterfaces().length == <span class="hljs-number">1</span>) &#123;<br>        processAnnotationOnClass(data, targetType.getInterfaces()[<span class="hljs-number">0</span>]);<br>      &#125;<br>    <span class="hljs-comment">//解析类上的注解</span><br>      processAnnotationOnClass(data, targetType);<br><span class="hljs-comment">//循环解析方法上的所有注解</span><br>      <span class="hljs-keyword">for</span> (Annotation methodAnnotation : method.getAnnotations()) &#123;<br>        processAnnotationOnMethod(data, methodAnnotation, method);<br>      &#125;<br>    <br>      <span class="hljs-keyword">if</span> (data.isIgnored()) &#123;<br>        <span class="hljs-keyword">return</span> data;<br>      &#125;<br>     <span class="hljs-comment">//获取方法参数类型</span><br>      Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();<br>     <span class="hljs-comment">//获取方法泛型类型</span><br>      Type[] genericParameterTypes = method.getGenericParameterTypes();<br> <span class="hljs-comment">//获取方法的参数注解，是二维数组，因为每个参数可以有多个注解，没有注解则为空数组</span><br>      Annotation[][] parameterAnnotations = method.getParameterAnnotations();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> parameterAnnotations.length;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isHttpAnnotation</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//解析参数的注解</span><br>        <span class="hljs-keyword">if</span> (parameterAnnotations[i] != <span class="hljs-literal">null</span>) &#123;<br>          isHttpAnnotation = processAnnotationsOnParameter(data, parameterAnnotations[i], i);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (isHttpAnnotation) &#123;<br>          data.ignoreParamater(i);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (parameterTypes[i] == URI.class) &#123;<br>          data.urlIndex(i);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isHttpAnnotation &amp;&amp; parameterTypes[i] != Request.Options.class<br>            <span class="hljs-comment">//如果第i位参数没有被引用过，就将它设为bodyIndex</span><br>            <span class="hljs-comment">//这里只有没注解的参数才能验证成功</span><br>              &amp;&amp; !data.isAlreadyProcessed(i)) &#123;<br>            <span class="hljs-comment">//在设置bodyIndex前保证formParams是空的，也就是没有无引用的@Param标记的参数</span><br>          checkState(data.formParams().isEmpty(),<br>              <span class="hljs-string">&quot;Body parameters cannot be used with form parameters.&quot;</span>);<br>          checkState(data.bodyIndex() == <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;Method has too many Body parameters: %s&quot;</span>, method);<br>          data.bodyIndex(i);<br>          data.bodyType(Types.resolve(targetType, targetType, genericParameterTypes[i]));<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (data.headerMapIndex() != <span class="hljs-literal">null</span>) &#123;<br>        checkMapString(<span class="hljs-string">&quot;HeaderMap&quot;</span>, parameterTypes[data.headerMapIndex()],<br>            genericParameterTypes[data.headerMapIndex()]);<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (data.queryMapIndex() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (Map.class.isAssignableFrom(parameterTypes[data.queryMapIndex()])) &#123;<br>          checkMapKeys(<span class="hljs-string">&quot;QueryMap&quot;</span>, genericParameterTypes[data.queryMapIndex()]);<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> data;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>默认的<code>encoder</code>只能处理String和byte[]类型的参数，其他参数需要自定义<code>encoder</code>来处理。</p><p>如下面两种情况，存在没注解的参数，会把他们转成请求体使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestJson</span> &#123;<br>    <span class="hljs-meta">@RequestLine(value = &quot;POST /test&quot;)</span><br>    Response <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TestJson</span> &#123;<br>    <span class="hljs-meta">@RequestLine(value = &quot;POST /test&quot;)</span><br>    Response <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(Map&lt;String,Object&gt; name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的一点是，这种方式构建请求<code>body</code>和上面<a href="#param%E6%B3%A8%E8%A7%A3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">@Param注解注意事项</a>里面未使用的<code>@Param</code>标记构建请求<code>body</code>的方式一起存在的话，有两种可能。</p><p>如果<code>@Param</code>的参数在无注解参数的前面，则按照上面代码49行会抛出<code>Body parameters cannot be used with form parameters</code>,提示body参数不能和表单参数一起用。</p><p>如果无注解参数放在<code>@Param</code>参数前面，无注解方式会被忽略，发送请求体由<code>@Param</code>的参数决定。</p></blockquote><h2 id="三种设置请求体的优先级"><a href="#三种设置请求体的优先级" class="headerlink" title="三种设置请求体的优先级"></a>三种设置请求体的优先级</h2><p>一共三种设置请求体的方式，分别是：</p><ul><li>1.使用<code>@Body</code>注解</li><li>2.使用没有任何注解的参数 （这样的参数只能存在一个）</li><li>3.使用没有被使用的<code>@Param</code>标记的参数 （这个可以有多个参数）</li></ul><p>他们之间的关系很复杂不能简单的用优先级来排序了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">super</span>.registerMethodAnnotation(Body.class, (ann, data) -&gt; &#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> ann.value();<br>  <span class="hljs-keyword">if</span> (body.indexOf(<span class="hljs-string">&#x27;&#123;&#x27;</span>) == -<span class="hljs-number">1</span>) &#123;<br>    data.template().body(body);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    data.template().bodyTemplate(body);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>可以看到，如果有body注解，如果body注解的值是固定的，则将值设置为body，如果是可变的设置为bodyTemplate</p></blockquote><blockquote><p>根据上面<a href="#Param%E6%B3%A8%E8%A7%A3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">Param注解注意事项</a>源码看出，如果<code>@Param</code>标记的参数没被使用，则放入<code>data.formParams()</code>中</p></blockquote><blockquote><p>在根据上面讲的<a href="#%E6%B2%A1%E6%9C%89%E5%8A%A0%E4%BB%BB%E4%BD%95%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8F%82%E6%95%B0">没有加任何注解的参数</a>, 则会将他设置为<code>data.bodyIndex(i)</code></p></blockquote><p>且bodyIndex只能设置一个，设置bodyIndex时会断言formParams为空，所以后两个同时使用的话，要保证后者放在参数的前面，先解析才不会报错。</p><p>调用时是这样的:<code>feign.ReflectiveFeign.ParseHandlersByName#apply</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果formarams中有值，bodyTemplate没值，则是哟个formarams构建请求体</span><br><span class="hljs-keyword">if</span> (!md.formParams().isEmpty() &amp;&amp; md.template().bodyTemplate() == <span class="hljs-literal">null</span>) &#123;<br>          buildTemplate =<br>              <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuildFormEncodedTemplateFromArgs</span>(md, encoder, queryMapEncoder, target);<br><span class="hljs-comment">//否则尝试是哟个bodyIndex构建请求体    </span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (md.bodyIndex() != <span class="hljs-literal">null</span>) &#123;<br>          buildTemplate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuildEncodedTemplateFromArgs</span>(md, encoder, queryMapEncoder, target);<br><span class="hljs-comment">//否则使用默认bodyTemplate构建请求体</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          buildTemplate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BuildTemplateByResolvingArgs</span>(md, queryMapEncoder, target);<br>        &#125;<br></code></pre></td></tr></table></figure><blockquote><p>所以他们的优先级是 </p><p>formParams &gt; bodyIndex</p><p>bodyIndex优先级 &gt; bodyTemplate</p><p>bodyTemplate &gt; formParams</p></blockquote><p>简直是个三角形的关系。</p><p>但我觉得将无注解参数放在<code>@Param</code>参数前就不报错，应该数据bug。</p>]]></content>
    
    
    
    <tags>
      
      <tag>openfeign</tag>
      
      <tag>Http客户端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Feign用法教程</title>
    <link href="/3012547788.html"/>
    <url>/3012547788.html</url>
    
    <content type="html"><![CDATA[<h1 id="Feign用法教程"><a href="#Feign用法教程" class="headerlink" title="Feign用法教程"></a>Feign用法教程</h1><ul><li>TOC<br>{:toc}</li></ul><h2 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h2><p>创建java项目，引入maven</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml">      <span class="hljs-comment">&lt;!--核心包--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>10.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--使用slf4j 打log--&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>10.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--引入logback，版本自己选择--&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="典型示例"><a href="#典型示例" class="headerlink" title="典型示例"></a>典型示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GitHub</span> &#123;<br>        <span class="hljs-meta">@RequestLine(&quot;GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</span><br>        String <span class="hljs-title function_">contributors</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;owner&quot;)</span> String owner, <span class="hljs-meta">@Param(&quot;repo&quot;)</span> String repo)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String... args)</span> &#123;<br>        <span class="hljs-type">GitHub</span> <span class="hljs-variable">github</span> <span class="hljs-operator">=</span> Feign.builder()<br>                .logger(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Slf4jLogger</span>())<br>                .logLevel(Logger.Level.FULL)<br>                .target(GitHub.class, <span class="hljs-string">&quot;https://api.github.com&quot;</span>);<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">contributors</span> <span class="hljs-operator">=</span> github.contributors(<span class="hljs-string">&quot;OpenFeign&quot;</span>, <span class="hljs-string">&quot;feign&quot;</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="支持的注解"><a href="#支持的注解" class="headerlink" title="支持的注解"></a>支持的注解</h2><table><thead><tr><th>注解</th><th>target</th><th>说明</th></tr></thead><tbody><tr><td>@RequestLine</td><td>方法上</td><td>按照上面的示例一样，可以在此注解中表名请求method，和请求地址，并且可以使用<code>&#123;表达式&#125;</code>，这样的形式来从参数中提取数据，动态构造请求地址。</td></tr><tr><td>@Param</td><td>参数上</td><td>和上面示例一样，标记一个参数，这样在各种表达式中才能使用</td></tr><tr><td>@Headers</td><td>方法上<br />类上</td><td>这个注解有一个value参数，里面放请求头，参数中和<code>@requestLine</code>类似，可以使用表达式来动态创建，如果标记在方法上则此方法对应的请求有效，如果标记在类上，则整个类所有方法对应的请求有效。</td></tr><tr><td>@QeuryMap</td><td>参数上</td><td>将一个map或pojo标记为查询参数，取提取数据扩展成查询参数拼接在url后面</td></tr><tr><td>@HeaderMap</td><td>参数上</td><td>和queryyMap同理，将键值对当成head处理</td></tr><tr><td>@Body</td><td>方法上</td><td>用法和<code>RequestLine</code>类似，它的值会被当作请求体看待，如可以是一个json字符串，里面也可以用表达式</td></tr></tbody></table><blockquote><h4 id="覆盖请求host"><a href="#覆盖请求host" class="headerlink" title="覆盖请求host"></a>覆盖请求host</h4><p>​如果不希望<code>Feign.builder</code>这样生成接口代理类时指定请求的host，那么可以在方法上添加一个<code>java.net.URI</code>的参数，此参数将覆盖builder生成代理类时传入的host。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestLine(&quot;POST /repos/&#123;owner&#125;/&#123;repo&#125;/issues&quot;)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createIssue</span><span class="hljs-params">(URI host, Issue issue, <span class="hljs-meta">@Param(&quot;owner&quot;)</span> String owner, <span class="hljs-meta">@Param(&quot;repo&quot;)</span> String repo)</span>;<br></code></pre></td></tr></table></figure></blockquote><h2 id="模板和表达式"><a href="#模板和表达式" class="headerlink" title="模板和表达式"></a>模板和表达式</h2><p>​Feign 表达式遵守 <a href="https://tools.ietf.org/html/rfc6570">这里</a>定义的String表达式（Level 1），使用<code>Param</code>注解来扩展表达式</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GitHub</span> &#123;<br>  <br>  <span class="hljs-meta">@RequestLine(&quot;GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</span><br>  List&lt;Contributor&gt; <span class="hljs-title function_">contributors</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;owner&quot;)</span> String owner, <span class="hljs-meta">@Param(&quot;repo&quot;)</span> String repository)</span>;<br>  <br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Contributor</span> &#123;<br>    String login;<br>    <span class="hljs-type">int</span> contributions;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApp</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">GitHub</span> <span class="hljs-variable">github</span> <span class="hljs-operator">=</span> Feign.builder()<br>                         .target(GitHub.class, <span class="hljs-string">&quot;https://api.github.com&quot;</span>);<br>    <br>    <span class="hljs-comment">/* owner和 repository两个参数会用来扩展RequestLine中的表达式模板</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * 真实请求的链接就会变成</span><br><span class="hljs-comment">    *https://api.github.com/repos/OpenFeign/feign/contributors</span><br><span class="hljs-comment">     */</span><br>    github.contributors(<span class="hljs-string">&quot;OpenFeign&quot;</span>, <span class="hljs-string">&quot;feign&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>表达式必须用大括号<code>&#123;&#125;</code>包起来的形式，也可以使用正则来限制表达式解析后的值，正则使用冒号<code>:</code>进行分隔，比如 <code>&#123;owner:[a-zA-Z]*&#125;</code> 这样来限制<code>owner</code>必须是大小写字母。即前面的值必须满足后面的正则表达式， feign.template.Expressions#125</p></blockquote><h3 id="请求路径和参数扩展"><a href="#请求路径和参数扩展" class="headerlink" title="请求路径和参数扩展"></a>请求路径和参数扩展</h3><p><code>RequestLine</code> 和<code>QueryMap</code>模板符合 <a href="https://tools.ietf.org/html/rfc6570">URI Template -RFC6570</a>规范，下面需要注重指出:</p><ul><li><p>未被解析的表达式将被忽略</p></li><li><p>除非使用<code>@Param</code>注解的参数对参数标记为<code>encoded</code>，否则都要进行 pct-encoded。</p><blockquote><p>这里的意思是使用<code>@Param(value = &quot;owner&quot;,encoded = true) String owner</code>这样的形式表名该参数已经被编码过了，没标记的会被自动编码。新版本encoded这个参数被弃用了，因为新版本能自动检测值有没有被编码，如果已经编码了就不会再编码，如果没编码就进行编码，所以不使用此参数，让其默认false即可</p></blockquote></li></ul><h4 id="Undefined-vs-Empty-Values"><a href="#Undefined-vs-Empty-Values" class="headerlink" title="Undefined vs Empty Values"></a>Undefined vs Empty Values</h4><p>Undefined的意思是 <code>null</code>，根据 <a href="https://tools.ietf.org/html/rfc6570">URI Template - RFC 6570</a>规范，可以为表达式提供一个空值。当Feign解析一个表达式时，它首先确认该值知否被定义，如果被定义了，则<code>query parameter</code>会被保留，如果没有被定义，则<code>query parameter</code>会被移除，下文会详细解释。</p><ul><li><p>表达式出现在path中</p><ul><li><p>如果是空字符串</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fq</span> &#123;<br>       <span class="hljs-meta">@RequestLine(value = &quot;GET /item/&#123;id&#125;/create&quot;)</span><br>       String <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> String id)</span>;<br>   &#125;<br>        <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String... args)</span> &#123;<br>       <span class="hljs-type">Fq</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Feign.builder()<br>               .logger(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Slf4jLogger</span>())<br>               .logLevel(Logger.Level.FULL)<br>               .target(Fq.class, <span class="hljs-string">&quot;http://localhost&quot;</span>);<br>       <span class="hljs-type">String</span> <span class="hljs-variable">itemCoupon</span> <span class="hljs-operator">=</span> target.getItemCoupon(<span class="hljs-string">&quot;&quot;</span>);<br>       <br><span class="hljs-comment">//结果  GET http://localhost/item//create</span><br></code></pre></td></tr></table></figure></li><li><p>如果是null</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fq</span> &#123;<br>        <span class="hljs-meta">@RequestLine(value = &quot;GET /item/&#123;id&#125;/create&quot;)</span><br>        String <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> String id)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String... args)</span> &#123;<br>        <span class="hljs-type">Fq</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Feign.builder()<br>                .logger(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Slf4jLogger</span>())<br>                .logLevel(Logger.Level.FULL)<br>                .target(Fq.class, <span class="hljs-string">&quot;http://localhost&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">itemCoupon</span> <span class="hljs-operator">=</span> target.getItemCoupon(<span class="hljs-literal">null</span>);<br><span class="hljs-comment">//结果 GET http://localhost/item//create </span><br></code></pre></td></tr></table></figure></li><li><p>如果是<code>+</code>或<code>/</code> 这种特殊字符</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fq</span> &#123;<br>       <span class="hljs-meta">@RequestLine(value = &quot;GET /item/&#123;id&#125;/create&quot;)</span><br>       String <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> String id)</span>;<br>   &#125;<br>        <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String... args)</span> &#123;<br>       <span class="hljs-type">Fq</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Feign.builder()<br>               .logger(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Slf4jLogger</span>())<br>               .logLevel(Logger.Level.FULL)<br>               .target(Fq.class, <span class="hljs-string">&quot;http://localhost&quot;</span>);<br>       <span class="hljs-type">String</span> <span class="hljs-variable">itemCoupon</span> <span class="hljs-operator">=</span> target.getItemCoupon(<span class="hljs-string">&quot;a+b/c&quot;</span>);<br><br><span class="hljs-comment">//结果  GET http://localhost/item/a+b/c/create HTTP/1.1</span><br></code></pre></td></tr></table></figure><blockquote><p>由上我们可以看出，如果参数表达式出现在path中，是不会被转码的，且如果是null的会变成空字符串。</p></blockquote></li></ul></li><li><p>表达式出现在queryString中</p><ul><li><p>空字符串</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fq</span> &#123;<br>        <span class="hljs-meta">@RequestLine(value = &quot;GET /item?id=&#123;id&#125;&quot;)</span><br>        String <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> String id)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String... args)</span> &#123;<br>        <span class="hljs-type">Fq</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Feign.builder()<br>                .logger(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Slf4jLogger</span>())<br>                .logLevel(Logger.Level.FULL)<br>                .target(Fq.class, <span class="hljs-string">&quot;http://localhost&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">itemCoupon</span> <span class="hljs-operator">=</span> target.getItemCoupon(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-comment">//结果  GET http://localhost/item?id HTTP/1.1</span><br></code></pre></td></tr></table></figure></li><li><p>如果是null</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fq</span> &#123;<br>        <span class="hljs-meta">@RequestLine(value = &quot;GET /item?id=&#123;id&#125;&quot;)</span><br>        String <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> String id)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String... args)</span> &#123;<br>        <span class="hljs-type">Fq</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Feign.builder()<br>                .logger(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Slf4jLogger</span>())<br>                .logLevel(Logger.Level.FULL)<br>                .target(Fq.class, <span class="hljs-string">&quot;http://localhost&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">itemCoupon</span> <span class="hljs-operator">=</span> target.getItemCoupon(<span class="hljs-literal">null</span>);<br><span class="hljs-comment">//结果 GET http://localhost/item HTTP/1.1</span><br>       <br></code></pre></td></tr></table></figure></li><li><p>如果是<code>+</code>或<code>/</code> 这种特殊字符</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fq</span> &#123;<br>        <span class="hljs-meta">@RequestLine(value = &quot;GET /item?id=&#123;id&#125;&quot;)</span><br>        String <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> String id)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String... args)</span> &#123;<br>        <span class="hljs-type">Fq</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Feign.builder()<br>                .logger(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Slf4jLogger</span>())<br>                .logLevel(Logger.Level.FULL)<br>                .target(Fq.class, <span class="hljs-string">&quot;http://localhost&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">itemCoupon</span> <span class="hljs-operator">=</span> target.getItemCoupon(<span class="hljs-string">&quot;a+b/c&quot;</span>);<br><span class="hljs-comment">//结果 GET http://localhost/item?id=a%2Bb%2Fc HTTP/1.1</span><br></code></pre></td></tr></table></figure><blockquote><p>由上可以看出，出现在参数中的模板表达式，如果是空字符串则参数名会被保留下来，如果是null则移除参数名，如果有特殊字符，则进行转码。</p></blockquote></li></ul></li><li><p>如果是<code>@QueryMap</code>拼接查询参数</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fq</span> &#123;<br>        <span class="hljs-meta">@RequestLine(value = &quot;GET /item&quot;)</span><br>        String <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(<span class="hljs-meta">@QueryMap</span> Map map)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String... args)</span> &#123;<br>        <span class="hljs-type">Fq</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Feign.builder()<br>                .logger(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Slf4jLogger</span>())<br>                .logLevel(Logger.Level.FULL)<br>                .target(Fq.class, <span class="hljs-string">&quot;http://localhost&quot;</span>);<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;1+1/2&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-literal">null</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">itemCoupon</span> <span class="hljs-operator">=</span> target.getItemCoupon(map);<br>        <br><span class="hljs-comment">// 结果 GET http://localhost/item?a=1%2B1%2F2&amp;b&amp;c HTTP/1.1</span><br>        <br></code></pre></td></tr></table></figure><blockquote><p>由上可以看出使用<code>RequestMap</code> 传递参数时，会对参数进行编码，且如果参数的值为null或空字符串，则保留参数的键</p></blockquote></li></ul><p>查看<a href="https://github.com/OpenFeign/feign#advanced-usage">Advanced Usage</a> 有更多的示例。</p><blockquote><p>如何处理斜杠 <code>/</code></p><p>默认情况下<code>@RequestLine</code>不会 encode 斜杠，要改变这种默认行为，可以将<code>@ReqeustLine</code>的属性<code>decodeSlash</code>设置为<code>false</code>，参考这个<a href="https://github.com/OpenFeign/feign/issues/350">issus</a>,即默认情况下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/foo/&#123;id&#125;&quot;)</span><br>String <span class="hljs-title function_">getFooById</span><span class="hljs-params">(String id)</span> &#123;<br>&#125;<br>myFeignClient.getFooById(<span class="hljs-string">&quot;/1/2/3&quot;</span>)<br><span class="hljs-comment">//真正请求地址将是 ‘/foo/1/2/3’，不会对/转码</span><br>    <br></code></pre></td></tr></table></figure></blockquote><blockquote><p>如何处理加号<code>+</code></p><p>根据url规范，加号是允许出现在path和查询参数中的，但是现实中处理起来可能不一样，有一些老系统，会把<code>+</code>当成空格，但是现代的新系统在查询参数中不会将<code>+</code>当成空格，而是显示成<code>%2B</code></p><p>如果你希望使用<code>+</code>作为空格，你可以直接只用<code> </code>字符来当成空格，或者编码成 <code>@2B</code>,</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/foo/&#123;id&#125;&quot;)</span><br>String <span class="hljs-title function_">getFooById</span><span class="hljs-params">(String id)</span> &#123;<br>&#125;<br>myFeignClient.getFooById(<span class="hljs-string">&quot;/1+1/2&quot;</span>)<br><span class="hljs-comment">//真正请求地址将是 ‘/foo/1+1/2’，不会对+转码</span><br></code></pre></td></tr></table></figure><h4 id="上面这说的-和-在路径中不会转码，但在参数中会被转码"><a href="#上面这说的-和-在路径中不会转码，但在参数中会被转码" class="headerlink" title="上面这说的+和&#x2F; 在路径中不会转码，但在参数中会被转码"></a>上面这说的+和&#x2F; 在路径中不会转码，但在参数中会被转码</h4></blockquote><h4 id="Expander接口"><a href="#Expander接口" class="headerlink" title="Expander接口"></a>Expander接口</h4><p><code>@Param</code>注解有一个可选的属性 <code>expander</code>允许控制该参数的解析，<code>expander</code>属性必须指向一个<code>Expander</code>接口的实现类，接口如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Expander</span> &#123;<br>    String <span class="hljs-title function_">expand</span><span class="hljs-params">(Object value)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fq</span> &#123;<br>       <span class="hljs-meta">@RequestLine(value = &quot;GET /item?date=&#123;date&#125;&quot;)</span><br>       String <span class="hljs-title function_">getItemCoupon</span><span class="hljs-params">(<span class="hljs-meta">@Param(value = &quot;date&quot;, expander = DateExpander.class)</span> Date date)</span>;<br>   &#125;<br><br>   <span class="hljs-comment">//自定义格式化时间的expander</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DateExpander</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Param</span>.Expander &#123;<br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> String <span class="hljs-title function_">expand</span><span class="hljs-params">(Object value)</span> &#123;<br>           <span class="hljs-keyword">if</span> (!(value <span class="hljs-keyword">instanceof</span> Date)) &#123;<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;不支持的类型&quot;</span>);<br>           &#125;<br>           <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> (Date) value;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>).format(date);<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String... args)</span> &#123;<br>       <span class="hljs-type">Fq</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> Feign.builder()<br>               .logger(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Slf4jLogger</span>())<br>               .logLevel(Logger.Level.FULL)<br>               .target(Fq.class, <span class="hljs-string">&quot;http://localhost&quot;</span>);<br><br>       <span class="hljs-type">String</span> <span class="hljs-variable">itemCoupon</span> <span class="hljs-operator">=</span> target.getItemCoupon(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br></code></pre></td></tr></table></figure><blockquote><p>框架在调用此接口前判断参数是否为null，如果为null则按照上面规范忽略此参数的键值对，不再调用此接口，所以此接口的参数会被保证非null。</p><p>此接口的返回值可以是空字符串，也可以是null。返回值，按照上面[Undefined vs Empty Values](#Undefined vs Empty Values)规范处理。</p><p>返回值中的特殊字符会被pct-encoded处理，查看<a href="https://github.com/OpenFeign/feign#custom-param-expansion">Custom @Param Expansion</a>有更多示例。</p></blockquote><h3 id="请求头扩展"><a href="#请求头扩展" class="headerlink" title="请求头扩展"></a>请求头扩展</h3><p>和<a href="#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E6%89%A9%E5%B1%95">请求参数扩展</a>类似，但进行了如下修改：</p><ul><li>默认不执行pct-encode ，（而请求参数扩展是默认encode的）。</li><li>未解析的表达式将被忽略，如果解析结果是空字符串，则这条请求头会被移除 （而请求参数空字符串会添加没有值的参数而不是忽略整个参数）</li></ul><blockquote><p>示例如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ContentService</span> &#123;<br>  <span class="hljs-meta">@RequestLine(&quot;GET /api/documents/&#123;contentType&#125;&quot;)</span><br>  <span class="hljs-meta">@Headers(&quot;Accept: &#123;contentType&#125;&quot;)</span><br>  String <span class="hljs-title function_">getDocumentByType</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;contentType&quot;)</span> String type)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="请求体扩展"><a href="#请求体扩展" class="headerlink" title="请求体扩展"></a>请求体扩展</h3><p><code>@Body</code>和<a href="#%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E6%89%A9%E5%B1%95">请求参数扩展</a>类似，但进行了如下修改：</p><ul><li>值不会进行encoder</li><li>不能解析的表达式将被忽略，（把模板当成字符串）。</li><li><code>Content-Type</code>头是必须要有的</li></ul><hr><h2 id="定制化"><a href="#定制化" class="headerlink" title="定制化"></a>定制化</h2><p>Feign允许定制，它内置了一些可以实现的接口，通过<code>Feign.builder()</code>来实现定制，如定制自定义decoder：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Bank</span> &#123;<br>  <span class="hljs-meta">@RequestLine(&quot;POST /account/&#123;id&#125;&quot;)</span><br>  Account <span class="hljs-title function_">getAccountInfo</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> String id)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BankService</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Bank</span> <span class="hljs-variable">bank</span> <span class="hljs-operator">=</span> Feign.builder().decoder(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountDecoder</span>())<br>        .target(Bank.class, <span class="hljs-string">&quot;https://api.examplebank.com&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多种接口"><a href="#多种接口" class="headerlink" title="多种接口"></a>多种接口</h2><p>这个例子中，target传递的不是（class，String） 而是一个target接口的实现类，上面传递的参数（class,String）会被构造为一个HardCodedTarget<T> (T class,String url) ，而你可以自己实现这一步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CloudService</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">CloudDNS</span> <span class="hljs-variable">cloudDNS</span> <span class="hljs-operator">=</span> Feign.builder()<br>      .target(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CloudIdentityTarget</span>&lt;CloudDNS&gt;(user, apiKey));<br>  &#125;<br>  <br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">CloudIdentityTarget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Target</span>&lt;CloudDNS&gt; &#123;<br>    <span class="hljs-comment">/* implementation of a Target */</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用自定义的target挺不错的，大家可以实现一个试试看。</p></blockquote><hr><h2 id="整合示例"><a href="#整合示例" class="headerlink" title="整合示例"></a>整合示例</h2><h3 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h3><p><a href="https://github.com/OpenFeign/feign/blob/master/gson">Gson</a>包含一个编码器一个解码器，和JSON API 一起工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">GsonCodec</span> <span class="hljs-variable">codec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonCodec</span>();<br>    <span class="hljs-type">GitHub</span> <span class="hljs-variable">github</span> <span class="hljs-operator">=</span> Feign.builder()<br>                         .encoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonEncoder</span>())<br>                         .decoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonDecoder</span>())<br>                         .target(GitHub.class, <span class="hljs-string">&quot;https://api.github.com&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h3><p><a href="https://github.com/OpenFeign/feign/blob/master/jackson">Jackson</a> 使用Jackson来处理JSON也很好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">GitHub</span> <span class="hljs-variable">github</span> <span class="hljs-operator">=</span> Feign.builder()<br>                     .encoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JacksonEncoder</span>())<br>                     .decoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JacksonDecoder</span>())<br>                     .target(GitHub.class, <span class="hljs-string">&quot;https://api.github.com&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h3><p>底层使用<a href="https://github.com/OpenFeign/feign/blob/master/okhttp">OkHttpClient</a>来处理发送请求，因为默认是使用java.net.URL connection来发送请求的，性能比较低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">GitHub</span> <span class="hljs-variable">github</span> <span class="hljs-operator">=</span> Feign.builder()<br>                     .client(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>())<br>                     .target(GitHub.class, <span class="hljs-string">&quot;https://api.github.com&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h3><p><a href="https://github.com/OpenFeign/feign/blob/master/ribbon">RibbonClient</a> 提供负载均衡，需要负载均衡的可以使用这个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">MyService</span> <span class="hljs-variable">api</span> <span class="hljs-operator">=</span> Feign.builder()<br>          .client(RibbonClient.create())<br>          .target(MyService.class, <span class="hljs-string">&quot;https://myAppProd&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Java-11-Http2"><a href="#Java-11-Http2" class="headerlink" title="Java 11 Http2"></a>Java 11 Http2</h3><p>使用java11提供的Http2,高版本jdk使用这个是很好的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">GitHub</span> <span class="hljs-variable">github</span> <span class="hljs-operator">=</span> Feign.builder()<br>                     .client(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Http2Client</span>())<br>                     .target(GitHub.class, <span class="hljs-string">&quot;https://api.github.com&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><p><a href="https://github.com/OpenFeign/feign/blob/master/hystrix">HystrixFeign</a>使用这个让Feign使用<a href="https://github.com/Netflix/Hystrix">Hystrix</a>，带有熔断器功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">MyService</span> <span class="hljs-variable">api</span> <span class="hljs-operator">=</span> HystrixFeign.builder().target(MyService.class, <span class="hljs-string">&quot;https://myAppProd&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SLF4J"><a href="#SLF4J" class="headerlink" title="SLF4J"></a>SLF4J</h3><p><a href="https://github.com/OpenFeign/feign/blob/master/slf4j">SLF4JModule</a> 这个组件允许让Feign底层使用SLF4j来记录日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">GitHub</span> <span class="hljs-variable">github</span> <span class="hljs-operator">=</span> Feign.builder()<br>                     .logger(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Slf4jLogger</span>())<br>                     .target(GitHub.class, <span class="hljs-string">&quot;https://api.github.com&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Decoders"><a href="#Decoders" class="headerlink" title="Decoders"></a>Decoders</h3><p>配置一个解码器来处理相应<code>Response</code>，默认的支持返回值为<code>String</code>,<code>byte[]</code>,<code>void</code>,可以看一下源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">GitHub</span> <span class="hljs-variable">github</span> <span class="hljs-operator">=</span> Feign.builder()<br>                     .decoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonDecoder</span>())<br>                     .target(GitHub.class, <span class="hljs-string">&quot;https://api.github.com&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想让结果进入解码器前进行预处理，可以使用<code>mapAndDecode</code>方法，如下，传递解码器时传递一个lambda来预处理响应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">JsonpApi</span> <span class="hljs-variable">jsonpApi</span> <span class="hljs-operator">=</span> Feign.builder()<br>                         .mapAndDecode((response, type) -&gt; jsopUnwrap(response, type), <span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonDecoder</span>())<br>                         .target(JsonpApi.class, <span class="hljs-string">&quot;https://some-jsonp-api.com&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Encoders"><a href="#Encoders" class="headerlink" title="Encoders"></a>Encoders</h3><p>发送一个带请求体的post请求最简单的方法就是定义一个post请求，参数是一个不带任何注解的String或者byte[],然后不要忘了添加<code>Content-Type</code>请求头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">LoginClient</span> &#123;<br>  <span class="hljs-meta">@RequestLine(&quot;POST /&quot;)</span><br>  <span class="hljs-meta">@Headers(&quot;Content-Type: application/json&quot;)</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">(String content)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    client.login(<span class="hljs-string">&quot;&#123;\&quot;user_name\&quot;: \&quot;denominator\&quot;, \&quot;password\&quot;: \&quot;secret\&quot;&#125;&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这么做很麻烦，你不得不手工处理json字符串，更简单的方法是定义一个<code>encoder</code>，如下编码器会将参数<code>Credentials</code>处理成json字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Credentials</span> &#123;<br>  <span class="hljs-keyword">final</span> String user_name;<br>  <span class="hljs-keyword">final</span> String password;<br><br>  Credentials(String user_name, String password) &#123;<br>    <span class="hljs-built_in">this</span>.user_name = user_name;<br>    <span class="hljs-built_in">this</span>.password = password;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">LoginClient</span> &#123;<br>  <span class="hljs-meta">@RequestLine(&quot;POST /&quot;)</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">(Credentials creds)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">LoginClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> Feign.builder()<br>                              .encoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonEncoder</span>())<br>                              .target(LoginClient.class, <span class="hljs-string">&quot;https://foo.com&quot;</span>);<br>    <br>    client.login(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Credentials</span>(<span class="hljs-string">&quot;denominator&quot;</span>, <span class="hljs-string">&quot;secret&quot;</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Body-templates"><a href="#Body-templates" class="headerlink" title="@Body templates"></a>@Body templates</h3><p><code>@body</code>注解可以定义一个模板，从<code>@Param</code>标记的参数中提取数据，不要忘记添加<code>Content-Type</code>头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">LoginClient</span> &#123;<br><br>  <span class="hljs-meta">@RequestLine(&quot;POST /&quot;)</span><br>  <span class="hljs-meta">@Headers(&quot;Content-Type: application/xml&quot;)</span><br>  <span class="hljs-meta">@Body(&quot;&lt;login \&quot;user_name\&quot;=\&quot;&#123;user_name&#125;\&quot; \&quot;password\&quot;=\&quot;&#123;password&#125;\&quot;/&gt;&quot;)</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">xml</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;user_name&quot;)</span> String user, <span class="hljs-meta">@Param(&quot;password&quot;)</span> String password)</span>;<br><br>  <span class="hljs-meta">@RequestLine(&quot;POST /&quot;)</span><br>  <span class="hljs-meta">@Headers(&quot;Content-Type: application/json&quot;)</span><br>  <span class="hljs-comment">// json 左右两边的括号必须转义的</span><br>  <span class="hljs-meta">@Body(&quot;%7B\&quot;user_name\&quot;: \&quot;&#123;user_name&#125;\&quot;, \&quot;password\&quot;: \&quot;&#123;password&#125;\&quot;%7D&quot;)</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">json</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;user_name&quot;)</span> String user, <span class="hljs-meta">@Param(&quot;password&quot;)</span> String password)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    client.xml(<span class="hljs-string">&quot;denominator&quot;</span>, <span class="hljs-string">&quot;secret&quot;</span>); <span class="hljs-comment">// &lt;login &quot;user_name&quot;=&quot;denominator&quot; &quot;password&quot;=&quot;secret&quot;/&gt;</span><br>    client.json(<span class="hljs-string">&quot;denominator&quot;</span>, <span class="hljs-string">&quot;secret&quot;</span>); <span class="hljs-comment">// &#123;&quot;user_name&quot;: &quot;denominator&quot;, &quot;password&quot;: &quot;secret&quot;&#125;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Headers"><a href="#Headers" class="headerlink" title="@Headers"></a>@Headers</h3><h4 id="设置请求头的api"><a href="#设置请求头的api" class="headerlink" title="设置请求头的api"></a>设置请求头的api</h4><p><code>@Headers</code>注解可以设置在类上，以表示对所有接口生效，设置在方法上表示对该方法生效。</p><p>如果类中的所有方法均要添加这个请求头，就会很有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Headers(&quot;Accept: application/json&quot;)</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">BaseApi</span>&lt;V&gt; &#123;<br>  <span class="hljs-meta">@Headers(&quot;Content-Type: application/json&quot;)</span><br>  <span class="hljs-meta">@RequestLine(&quot;PUT /api/&#123;key&#125;&quot;)</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;key&quot;)</span> String key, V value)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>并且<code>@Header</code>注解是支持动态创建请求头的，从参数中提出数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Api</span> &#123;<br>   <span class="hljs-meta">@RequestLine(&quot;POST /&quot;)</span><br>   <span class="hljs-meta">@Headers(&quot;X-Ping: &#123;token&#125;&quot;)</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">post</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;token&quot;)</span> String token)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果请求头的键值都是动态的，而且还不知道具体有多少个，可以使用<code>@HeaderMap</code>注解处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Api</span> &#123;<br>   <span class="hljs-meta">@RequestLine(&quot;POST /&quot;)</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">post</span><span class="hljs-params">(<span class="hljs-meta">@HeaderMap</span> Map&lt;String, Object&gt; headerMap)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="为每个target设置请求头"><a href="#为每个target设置请求头" class="headerlink" title="为每个target设置请求头"></a>为每个target设置请求头</h4><p>有时候，如果同一个接口针对不同host（注:host是可以通过注入一个java.net.URI在运行中改变的）使用不同的请求头，或者请求头是根据具体请求变化的，则可以使用<code>RequestInterceptor</code> 或 <code>Target</code>来实现。</p><p>使用<code>RequestInterceptor</code>的例子在<code>RequestInterceptor</code>章节再讲。</p><p>下面是使用<code>Target</code>的解决灵活的请求头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicAuthTokenTarget</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Target</span>&lt;T&gt; &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">DynamicAuthTokenTarget</span><span class="hljs-params">(Class&lt;T&gt; clazz,</span><br><span class="hljs-params">                                 UrlAndTokenProvider provider,</span><br><span class="hljs-params">                                 ThreadLocal&lt;String&gt; requestIdProvider)</span>;<br>   <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Request <span class="hljs-title function_">apply</span><span class="hljs-params">(RequestTemplate input)</span> &#123;<br>     <span class="hljs-type">TokenIdAndPublicURL</span> <span class="hljs-variable">urlAndToken</span> <span class="hljs-operator">=</span> provider.get();<br>     <span class="hljs-keyword">if</span> (input.url().indexOf(<span class="hljs-string">&quot;http&quot;</span>) != <span class="hljs-number">0</span>) &#123;<br>       input.insert(<span class="hljs-number">0</span>, urlAndToken.publicURL);<br>     &#125;<br>     input.header(<span class="hljs-string">&quot;X-Auth-Token&quot;</span>, urlAndToken.tokenId);<br>     input.header(<span class="hljs-string">&quot;X-Request-ID&quot;</span>, requestIdProvider.get());<br><br>     <span class="hljs-keyword">return</span> input.request();<br>   &#125;<br> &#125;<br> <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>     <span class="hljs-type">Bank</span> <span class="hljs-variable">bank</span> <span class="hljs-operator">=</span> Feign.builder()<br>             .target(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicAuthTokenTarget</span>(Bank.class, provider, requestIdProvider));<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="基础Api"><a href="#基础Api" class="headerlink" title="基础Api"></a>基础Api</h3><p>在很多情况下，服务端的接口遵循一致的约定，这时可以通过继承接口来处理。</p><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">BaseAPI</span> &#123;<br>  <span class="hljs-meta">@RequestLine(&quot;GET /health&quot;)</span><br>  String <span class="hljs-title function_">health</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-meta">@RequestLine(&quot;GET /all&quot;)</span><br>  List&lt;Entity&gt; <span class="hljs-title function_">all</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>你可以使用继承，来获取父类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">CustomAPI</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseAPI</span> &#123;<br>  <span class="hljs-meta">@RequestLine(&quot;GET /custom&quot;)</span><br>  String <span class="hljs-title function_">custom</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>有些情况下，返回的Response表现形式也是一样的，如创建用户发送的json，获取用户得到的json，他们两个的形式都是一样的，可以定义公共泛型父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Headers(&quot;Accept: application/json&quot;)</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">BaseApi</span>&lt;V&gt; &#123;<br><br>  <span class="hljs-meta">@RequestLine(&quot;GET /api/&#123;key&#125;&quot;)</span><br>  V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;key&quot;)</span> String key)</span>;<br><br>  <span class="hljs-comment">//获取时，将结果返序列化成V类型  </span><br>  <span class="hljs-meta">@RequestLine(&quot;GET /api&quot;)</span><br>  List&lt;V&gt; <span class="hljs-title function_">list</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">//发送时，将V类型序列化</span><br>  <span class="hljs-meta">@Headers(&quot;Content-Type: application/json&quot;)</span><br>  <span class="hljs-meta">@RequestLine(&quot;PUT /api/&#123;key&#125;&quot;)</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;key&quot;)</span> String key, V value)</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">FooApi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseApi</span>&lt;Foo&gt; &#123; &#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">BarApi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseApi</span>&lt;Bar&gt; &#123; &#125;<br></code></pre></td></tr></table></figure><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>你可以设置一个<code>Logger</code> 和 <code>Logger.Level</code>来选择用什么处理日志以及日志级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">GitHub</span> <span class="hljs-variable">github</span> <span class="hljs-operator">=</span> Feign.builder()<br>                     .decoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonDecoder</span>())<br>                     .logger(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Logger</span>.JavaLogger(<span class="hljs-string">&quot;GitHub.Logger&quot;</span>).appendToFile(<span class="hljs-string">&quot;logs/http.log&quot;</span>))<br>                     .logLevel(Logger.Level.FULL)<br>                     .target(GitHub.class, <span class="hljs-string">&quot;https://api.github.com&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：使用JavaLogger()时要避免使用无参的构造函数<code>JavaLogger()</code>来创建它，他有问题被弃用了，以后可能会删除。</p></blockquote><h3 id="Request-Interceptors"><a href="#Request-Interceptors" class="headerlink" title="Request Interceptors"></a>Request Interceptors</h3><p>当你需要改变所有的请求，无论这个请求的地址是什么时，可以<code>Request Interceptors</code>。比如你想添加<code>X-Forwarded-For</code>请求头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForwardedForInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RequestInterceptor</span> &#123;<br>  <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(RequestTemplate template)</span> &#123;<br>    template.header(<span class="hljs-string">&quot;X-Forwarded-For&quot;</span>, <span class="hljs-string">&quot;origin.host.com&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Bank</span> <span class="hljs-variable">bank</span> <span class="hljs-operator">=</span> Feign.builder()<br>                 .decoder(accountDecoder)<br>                 .requestInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ForwardedForInterceptor</span>())<br>                 .target(Bank.class, <span class="hljs-string">&quot;https://api.examplebank.com&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>拦截器另一个常用的地方就是身份认证，如需要<code>BasicAuthRequestInterceptor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Bank</span> <span class="hljs-variable">bank</span> <span class="hljs-operator">=</span> Feign.builder()<br>                 .decoder(accountDecoder)<br>                 .requestInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicAuthRequestInterceptor</span>(username, password))<br>                 .target(Bank.class, <span class="hljs-string">&quot;https://api.examplebank.com&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>拦截器在Target前面执行，在Target的apply前一行代码。</p></blockquote><h3 id="Param扩展"><a href="#Param扩展" class="headerlink" title="@Param扩展"></a>@Param扩展</h3><p>上面讲到过<code>@Param</code>注解的expander 接口，下面这个例子将如果对参数进行修改，他将date格式化成毫秒值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Api</span> &#123;<br>  <span class="hljs-meta">@RequestLine(&quot;GET /?since=&#123;date&#125;&quot;)</span> <br>    Result <span class="hljs-title function_">list</span><span class="hljs-params">(<span class="hljs-meta">@Param(value = &quot;date&quot;, expander = DateToMillis.class)</span> Date date)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意一点，如果有两个<code>@Param</code>标记的参数的名字是一样的，则后面的会覆盖前面的</p></blockquote><h3 id="QueryMap-动态查询参数"><a href="#QueryMap-动态查询参数" class="headerlink" title="@QueryMap 动态查询参数"></a>@QueryMap 动态查询参数</h3><p>一个普通的map，添加上<code>@QueryMap</code>注解，它里面的值会被拿出来作为查询参数处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Api</span> &#123;<br>  <span class="hljs-meta">@RequestLine(&quot;GET /find&quot;)</span><br>  V <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-meta">@QueryMap</span> Map&lt;String, Object&gt; queryMap)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不是map是pojo也是可以的，默认通过反射获取pojo内的字段拼接成查询参数。</p><p>也可以定义一个<code>QueryMapEncoder</code>来处理如何从pojo中拿值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Api</span> &#123;<br>  <span class="hljs-meta">@RequestLine(&quot;GET /find&quot;)</span><br>  V <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-meta">@QueryMap</span> CustomPojo customPojo)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置一个<code>queryMapEncoder</code>的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">MyApi</span> <span class="hljs-variable">myApi</span> <span class="hljs-operator">=</span> Feign.builder()<br>                 .queryMapEncoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCustomQueryMapEncoder</span>())<br>                 .target(MyApi.class, <span class="hljs-string">&quot;https://api.hostname.com&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认通过反射获取值，如果希望使用<code>java bean</code>规范通过 <code>get set</code>来获取值，可以配置一个<code>BeanQueryMapEncoder</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">MyApi</span> <span class="hljs-variable">myApi</span> <span class="hljs-operator">=</span> Feign.builder()<br>                 .queryMapEncoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanQueryMapEncoder</span>())<br>                 .target(MyApi.class, <span class="hljs-string">&quot;https://api.hostname.com&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：<code>@QueryMap</code>注解的解析在<code>@Requestline</code>之后，所以<code>@Requestline</code>上面定义的参数会被后来的<code>@QueryMap</code>定义的参数覆盖，且如果<code>@QueryMap</code>内定义一个空值参数会把<code>@Requestline</code>中定义的删掉。</p></blockquote><h3 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h3><p>配置一个error handDecoder，所有不再2xx范围内的响应，都会被此handler的decode方法处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">MyApi</span> <span class="hljs-variable">myApi</span> <span class="hljs-operator">=</span> Feign.builder()<br>                 .errorDecoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyErrorDecoder</span>())<br>                 .target(MyApi.class, <span class="hljs-string">&quot;https://api.hostname.com&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你想进行重试，可以抛出一个<code>RetryableException</code>，这样框架接收到了此异常调用注册的<code>Retryer</code>来处理重试。</p><h3 id="Retry-重试"><a href="#Retry-重试" class="headerlink" title="Retry 重试"></a>Retry 重试</h3><p>默认情况下会重试所有的<code>IoException</code>，和ErrorHandling里面抛出的<code>RetryableException</code>,通过在builder是设置一个Retryer来定制这种行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">MyApi</span> <span class="hljs-variable">myApi</span> <span class="hljs-operator">=</span> Feign.builder()<br>                 .retryer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRetryer</span>())<br>                 .target(MyApi.class, <span class="hljs-string">&quot;https://api.hostname.com&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Retryer</code>通过方法<code>continueOrPropagate(RetryableException e)</code>来决定是否重试，无返回值。</p><p>如果允许重试，则直接返回。</p><p>如果不允许重试，请将参数中的RetryableException重新抛出。</p><p>框架为每个<code>Client</code>执行器clone一个<code>Retryer</code>,所以你可以在retryer上维护状态，而不用担心冲突。</p><blockquote><p> 注:为每个client创建Retryer的方式是调用Feign.build() 时传入的Retryer的clone()方法</p></blockquote><p>如果不能重试成功，则抛出最后一次重试的<code>RetryException</code>,如果你想要导致异常的真正Exception，请使用</p><p><code>exceptionPropagationPolicy()</code>构建Feign</p><h3 id="Options配置"><a href="#Options配置" class="headerlink" title="Options配置"></a>Options配置</h3><p>可以在build Feign时设置默认的Options。</p><p>如果想为每个请求设置独立Options则，接口的参数如果有类型是<code>feign.Request.Options</code>类型的，会作为配置传入，存在多个的情况下只取第一个。</p><h3 id="静态和默认方法"><a href="#静态和默认方法" class="headerlink" title="静态和默认方法"></a>静态和默认方法</h3><p>java8+ 支持接口的静态方法和默认方法，这样就允许Feign客户端包含逻辑，</p><p>比如你想提供默认参数，或者两个接口聚合成一个一个接口返回等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">GitHub</span> &#123;<br>  <span class="hljs-meta">@RequestLine(&quot;GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</span><br>  List&lt;Contributor&gt; <span class="hljs-title function_">contributors</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;owner&quot;)</span> String owner, <span class="hljs-meta">@Param(&quot;repo&quot;)</span> String repo)</span>;<br><br>  <span class="hljs-meta">@RequestLine(&quot;GET /users/&#123;username&#125;/repos?sort=&#123;sort&#125;&quot;)</span><br>  List&lt;Repo&gt; <span class="hljs-title function_">repos</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;username&quot;)</span> String owner, <span class="hljs-meta">@Param(&quot;sort&quot;)</span> String sort)</span>;<br><span class="hljs-comment">//提供默认值</span><br>  <span class="hljs-keyword">default</span> List&lt;Repo&gt; <span class="hljs-title function_">repos</span><span class="hljs-params">(String owner)</span> &#123;<br>    <span class="hljs-keyword">return</span> repos(owner, <span class="hljs-string">&quot;full_name&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 从repos()中拿到list，再循环调用contributors拿到信息，最后返回</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">default</span> List&lt;Contributor&gt; <span class="hljs-title function_">contributors</span><span class="hljs-params">(String user)</span> &#123;<br>    <span class="hljs-type">MergingContributorList</span> <span class="hljs-variable">contributors</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MergingContributorList</span>();<br>    <span class="hljs-keyword">for</span>(Repo repo : <span class="hljs-built_in">this</span>.repos(owner)) &#123;<br>      contributors.addAll(<span class="hljs-built_in">this</span>.contributors(user, repo.getName()));<br>    &#125;<br>    <span class="hljs-keyword">return</span> contributors.mergeResult();<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> GitHub <span class="hljs-title function_">connect</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Feign.builder()<br>                .decoder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonDecoder</span>())<br>                .target(GitHub.class, <span class="hljs-string">&quot;https://api.github.com&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一些内置类"><a href="#一些内置类" class="headerlink" title="一些内置类"></a>一些内置类</h3><h4 id="feign-Response"><a href="#feign-Response" class="headerlink" title="feign.Response"></a>feign.Response</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Response</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Closeable</span> &#123;<br><span class="hljs-comment">//状态码</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> status;<br>    <span class="hljs-comment">//状态码后面的文字，如200 OK 则此字段就是OK</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String reason;<br>    <span class="hljs-comment">//响应头</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Collection&lt;String&gt;&gt; headers;<br>  <span class="hljs-comment">//响应体</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Body body;<br>    <span class="hljs-comment">//该响应对应的请求</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Request request;<br>  .<br>  .<br>  .<br></code></pre></td></tr></table></figure><h4 id="feign-Response-Body"><a href="#feign-Response-Body" class="headerlink" title="feign.Response.Body"></a>feign.Response.Body</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Body</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Closeable</span> &#123;<br><span class="hljs-comment">//数据长度</span><br>    Integer <span class="hljs-title function_">length</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//是否允许重复读取</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isRepeatable</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//返回流</span><br>    InputStream <span class="hljs-title function_">asInputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<br><br>    <span class="hljs-meta">@Deprecated</span><br>    <span class="hljs-keyword">default</span> Reader <span class="hljs-title function_">asReader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>      <span class="hljs-keyword">return</span> asReader(StandardCharsets.UTF_8);<br>    &#125;<br><span class="hljs-comment">//返回read流</span><br>    Reader <span class="hljs-title function_">asReader</span><span class="hljs-params">(Charset charset)</span> <span class="hljs-keyword">throws</span> IOException;<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>openfeign</tag>
      
      <tag>Http客户端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>free-mybatis-plugin的使用方法</title>
    <link href="/4271254320.html"/>
    <url>/4271254320.html</url>
    
    <content type="html"><![CDATA[<h2 id="free-mybatis-plugin的使用方法"><a href="#free-mybatis-plugin的使用方法" class="headerlink" title="free-mybatis-plugin的使用方法"></a>free-mybatis-plugin的使用方法</h2><ul><li>TOC<br>{:toc}</li></ul><p>​作为java界开发必备神器idea，其功能强大，提供强大的插件系统，如果使用当前主流的ssm三大框架，一定要安装free-mybatis-plugin。其大大方便了我们使用mybatis。</p><p>该插件不仅仅在mapper接口和mapper.xml文件上提供跳转按钮，还内置了generator gui界面，下面看看如何使用。</p><h3 id="插件功能"><a href="#插件功能" class="headerlink" title="插件功能"></a>插件功能</h3><p>插件一共提供了四个功能:</p><ul><li>生成mapper xml文件</li><li>快速从代码跳转到mapper及从mapper返回代码</li><li>mybatis自动补全及语法错误提示</li><li>集成mybatis generator gui界面</li></ul><p><img src="/img/in/2019-12-11-free-mybatis-plugin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20191211114318462.png" alt="image-20191211114318462"></p><h4 id="功能1：快速从代码跳转到mapper及从mapper返回代码"><a href="#功能1：快速从代码跳转到mapper及从mapper返回代码" class="headerlink" title="功能1：快速从代码跳转到mapper及从mapper返回代码"></a>功能1：快速从代码跳转到mapper及从mapper返回代码</h4><p>​这是我们最熟悉的功能，他会在我们的mapper.xml文件的select，delete，update等语句左边提供一个箭头</p><p><img src="/img/in/2019-12-11-free-mybatis-plugin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20191211114749395.png" alt="image-20191211114749395"></p><p>点击它就能跳转到与<code>namespace</code>对应的mapper接口的相应方法上，方便我们快速定位。</p><h4 id="功能2：mybatis自动补全及语法错误提示"><a href="#功能2：mybatis自动补全及语法错误提示" class="headerlink" title="功能2：mybatis自动补全及语法错误提示"></a>功能2：mybatis自动补全及语法错误提示</h4><p>​我们写sql时，弹出的代码提示就是它做的，也是十分的好用。</p><p><img src="/img/in/2019-12-11-free-mybatis-plugin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20191211115058016.png" alt="image-20191211115058016"></p><h4 id="功能3，4：集成了mybatis-generator-gui，自动生成代码但比原生的generator更好用"><a href="#功能3，4：集成了mybatis-generator-gui，自动生成代码但比原生的generator更好用" class="headerlink" title="功能3，4：集成了mybatis generator gui，自动生成代码但比原生的generator更好用"></a>功能3，4：集成了<code>mybatis generator gui</code>，自动生成代码但比原生的<code>generator</code>更好用</h4><p>​idea内置了管理数据库的工具，此插件配合数据库管理工具，可以获取到数据库的连接，表，字段等信息，通过这些信息，此插件就能generator 出对应的mapper，dao，entity等。</p><ul><li>首先打开idea的 <code>database</code>窗口，此窗口一班在最右边，和maven同列。</li></ul><p><img src="/img/in/2019-12-11-free-mybatis-plugin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20191211115724055.png" alt="image-20191211115724055"></p><p>点击maven上面的<code>database</code>按钮会弹出此窗口，点击左边箭头指示的<code>加号</code>选择好数据库类型，数据库驱动，输入完账号密码，连接上数据库，下面的schemas就会显示选中的库。我这里事先连上了，可见名称为<code>test</code>的库内有一张名称为<code>troows</code>的表，表内字段也都显示在上面。</p><ul><li>在表上右键弹出菜单</li></ul><p><img src="/img/in/2019-12-11-free-mybatis-plugin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20191211120105680.png" alt="image-20191211120105680"></p><p>这里第一项<code>mybatis-generator</code>则为gui的生成器，下面的选项还有查看建标语句等等功能，这里不多做介绍了，我们选择第一项<code>mybatis-generator</code>。弹出：</p><img src="/img/in/2019-12-11-free-mybatis-plugin的使用方法/image-20191211120307488.png" alt="image-20191211120307488"  /><p>第一行选项 <code>table setting</code> 自动填充了表名，主键字段，项目文件夹</p><p>第二行<code>model setting</code>自动填充了生成的实体类文件名，包名，和路径</p><p>第三行 <code>dao setting</code>自动填充了生成的mapper接口文件名，包名，文件路径</p><p>第四行<code>xml mapper setting</code>用来设置生成的xml文件路径</p><p>第五行<code>options</code>是生成的选项，一会一个一个来看</p><ul><li><p>我们将路径包名改成自己需要的样子，建议不要选择和项目相同的路径或包名，不然后面生成把前面覆盖了不好把控，可以生成在其他地方，然后复制过来。我将文件生成在java1文件夹下，这样不会干扰本身的程序</p><p>  <img src="/img/in/2019-12-11-free-mybatis-plugin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20191211121018781.png" alt="image-20191211121018781"></p></li></ul><p>点击确定，项目文件夹下生成了如下文件</p><p><img src="/img/in/2019-12-11-free-mybatis-plugin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20191211121202896.png" alt="image-20191211121202896"></p><h3 id="option中配置选项"><a href="#option中配置选项" class="headerlink" title="option中配置选项"></a>option中配置选项</h3><p><img src="/img/in/2019-12-11-free-mybatis-plugin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20191211121332700.png" alt="image-20191211121332700"></p><h4 id="1-分页"><a href="#1-分页" class="headerlink" title="1. 分页"></a>1. 分页</h4><p>单独勾选此选项是没效果的，还需要勾选第五列第二个，生成 example来配合使用才行</p><p>查看生成的example中，多了如下代码，可以设置limit和offset</p><p><img src="/img/in/2019-12-11-free-mybatis-plugin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20191211121609488.png" alt="image-20191211121609488"></p><p>生成的mapper中，selectByExample方法中多了分页查询的逻辑</p><p><img src="/img/in/2019-12-11-free-mybatis-plugin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20191211121701330.png" alt="image-20191211121701330"></p><hr><h4 id="2-实体注释"><a href="#2-实体注释" class="headerlink" title="2.实体注释"></a>2.实体注释</h4><p>​勾选这个选项，会在生成的实体类上添加数据库建表时添加的注释，但经过测试，不勾选也能生成注释</p><p><img src="/img/in/2019-12-11-free-mybatis-plugin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20191211121833495.png" alt="image-20191211121833495"></p><hr><h4 id="3-Overwrite-Xml-Overwrite-Java"><a href="#3-Overwrite-Xml-Overwrite-Java" class="headerlink" title="3.Overwrite-Xml , Overwrite-Java"></a>3.Overwrite-Xml , Overwrite-Java</h4><p>​这两个选项，是生成的代码会覆盖掉原来的代码</p><hr><h4 id="4-toString-hashcode-equals"><a href="#4-toString-hashcode-equals" class="headerlink" title="4.toString&#x2F;hashcode&#x2F;equals"></a>4.toString&#x2F;hashcode&#x2F;equals</h4><p>​会在实体类中自动生成上面三个方法</p><hr><h4 id="5-User-Schema"><a href="#5-User-Schema" class="headerlink" title="5.User-Schema"></a>5.User-Schema</h4><p>​按字面意思是使用数据库名的前缀，我没发现使用这个哪里改变了。</p><hr><h4 id="6-Add-ForUpdate"><a href="#6-Add-ForUpdate" class="headerlink" title="6.Add-ForUpdate"></a>6.Add-ForUpdate</h4><p>这个选项会在example中增加字段</p><p><img src="/img/in/2019-12-11-free-mybatis-plugin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20191211122359965.png" alt="image-20191211122359965"></p><p>sql语句中的 selectByExample，会判断该字段，是否加锁查询</p><p><img src="/img/in/2019-12-11-free-mybatis-plugin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20191211122450602.png" alt="image-20191211122450602"></p><hr><h4 id="7-Repository-annotation"><a href="#7-Repository-annotation" class="headerlink" title="7.Repository-annotation"></a>7.Repository-annotation</h4><p>在生成的mapper接口上，添加@repository注解</p><p><img src="/img/in/2019-12-11-free-mybatis-plugin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20191211122608857.png" alt="image-20191211122608857"></p><hr><h4 id="8-parent-interface"><a href="#8-parent-interface" class="headerlink" title="8.parent-interface"></a>8.parent-interface</h4><p>这个会给mapper接口上生成公共的泛型父类，这样TroowMapper内那些增删改查的接口就转移到父类里面去了。看起来清爽些。</p><p><img src="/img/in/2019-12-11-free-mybatis-plugin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20191211122902877.png" alt="image-20191211122902877"></p><p><img src="/img/in/2019-12-11-free-mybatis-plugin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20191211122914657.png" alt="image-20191211122914657"></p><hr><h4 id="9-jsr310-data-and-time-api"><a href="#9-jsr310-data-and-time-api" class="headerlink" title="9.jsr310:data and time api"></a>9.jsr310:data and time api</h4><p>勾选这个，生成实体类中的Data类型会被LocalDateTime代替。</p><hr><h4 id="10-jpa-Annotation"><a href="#10-jpa-Annotation" class="headerlink" title="10.jpa-Annotation"></a>10.jpa-Annotation</h4><p>如图，添加jpa的注解</p><p><img src="/img/in/2019-12-11-free-mybatis-plugin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20191211123320861.png" alt="image-20191211123320861"></p><hr><h4 id="11-Actual-Column"><a href="#11-Actual-Column" class="headerlink" title="11.Actual-Column"></a>11.Actual-Column</h4><p>一般数据库字段都是用下划线命名，java实体类都是用驼峰法命名，生成代码时会从下划线转成驼峰法，勾选这个，生成的实体类会和数据库字段保持一致，保持下划线命名的方式。</p><hr><h4 id="12-Use-Alias"><a href="#12-Use-Alias" class="headerlink" title="12.Use-Alias"></a>12.Use-Alias</h4><p> 这个很有用，勾选这个，查询sql时，会将查询结果起别名，别名为 <code>表名_字段名</code>，这有很大好处，关联查询时，就不会出现字段同名问题了。</p><p><img src="/img/in/2019-12-11-free-mybatis-plugin%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/image-20191211123744202.png" alt="image-20191211123744202"></p><hr><h4 id="13-Use-Example"><a href="#13-Use-Example" class="headerlink" title="13.Use-Example"></a>13.Use-Example</h4><p>​上面讲过了，勾选这个才会生成example，且需要example才能完成的功能，也要勾选这个</p><hr><h4 id="14-Use-Lombox"><a href="#14-Use-Lombox" class="headerlink" title="14.Use-Lombox"></a>14.Use-Lombox</h4><p>​生成的实体类上自动加上Lombox的注解，这样就不会自动生成 get set方法了</p><hr><h3 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h3><p>​上面勾选选项，每张表都要重选一次很麻烦，在<code>file-&gt;settings-&gt;tools-&gt;mybatis generator setting</code>选项里面，配置的设置，下次使用时会默认选上的，可以设置自己习惯的选项在这上面即可。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​以上就是free-mybatis-plugin插件的用法了。这个插件真的挺强大的，启用别名查询，添加分页，添加注释，添加jpa，都是挺有用的，节省我们手动处理的时间。</p><p>​</p>]]></content>
    
    
    
    <tags>
      
      <tag>mybatis</tag>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两种创建单例模式的方式</title>
    <link href="/1366727677.html"/>
    <url>/1366727677.html</url>
    
    <content type="html"><![CDATA[<h3 id="两种创建懒汉式单例模式的方法"><a href="#两种创建懒汉式单例模式的方法" class="headerlink" title="两种创建懒汉式单例模式的方法"></a>两种创建懒汉式单例模式的方法</h3><p>​先前使用findBug扫描了一下项目，发现单例的创建被提示警告了，根据其给的连接，以下两种创建单例模式的方式是正确的。</p><h4 id="第一种，使用静态辅助类来创建"><a href="#第一种，使用静态辅助类来创建" class="headerlink" title="第一种，使用静态辅助类来创建"></a>第一种，使用静态辅助类来创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回单例对象</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">singleton2</span><span class="hljs-params">()</span> &#123;    <br>    <span class="hljs-keyword">return</span> SingletonHelp.INSTANCE;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHelp</span> &#123;    <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用一个静态的类，类中静态变量INSTANCE为我们需要创建的单例实例，因为静态变量的初始化是在类初次加载进来时初始化的，他优先于程序线程的执行，所以其能保证并发情况下单例成立。</p></blockquote><h4 id="第二种，使用双重检测-volatile关键字创建"><a href="#第二种，使用双重检测-volatile关键字创建" class="headerlink" title="第二种，使用双重检测+volatile关键字创建"></a>第二种，使用双重检测+volatile关键字创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Object o;<br><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">singleton1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> o;<br>    <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            temp = o;<br>            <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">null</span>) &#123;<br>                o = temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>我们常用双重检测来创建单例模式，这个很好理解，如果对象为null则先加锁再创建，如果不为null则直接返回实例，从而实现对象的单例。但是如果忘记使用<code>volatile</code>关键字修饰对象，则可能会导致错误 。</p></blockquote><blockquote><p>因为当程序执行到 <code>o = new Object();</code>这一行时，期望的是先<code>new Object()</code>,再将创建好的对象赋值给o。但实际上当发生指令重排序时，会先执行引用的赋值操作，后执行创建对象操作，也是有可能发生的。</p><p>这将导致后面的线程判断o！&#x3D;null 返回true，但此时对象还没有创建成功，拿到的是一个半成品，导致问题。导致了不完整的对象被发布出去。</p></blockquote><blockquote><p>当加入<code>volatile</code>修改对象时，避免了指令重排序，所以创建的对象时可靠的。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将优启通启动pe制作到移动硬盘上</title>
    <link href="/2299053426.html"/>
    <url>/2299053426.html</url>
    
    <content type="html"><![CDATA[<h1 id="将优启通启动pe制作到移动硬盘上"><a href="#将优启通启动pe制作到移动硬盘上" class="headerlink" title="将优启通启动pe制作到移动硬盘上"></a>将优启通启动pe制作到移动硬盘上</h1><ul><li>TOC<br>{:toc}</li></ul><p>研究了一下如何将pe制作到移动硬盘上，毕竟移动硬盘比u盘快不少，且容量很大。</p><p>搜索了一些资料，下面是将优启通制作到移动硬盘上的详细制作过程。</p><p>首先准备一个移动硬盘，u盘也行，我的是东芝小黑盘。</p><hr><h4 id="第一步，硬盘分区"><a href="#第一步，硬盘分区" class="headerlink" title="第一步，硬盘分区"></a>第一步，硬盘分区</h4><p>​    使用DiskGenius将移动硬盘分出3-5G的空间，并格式化成主分区fat32格式备用，如图所示</p><p><img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210164521117.png" alt="image-20191210164521117"></p><h4 id="第二步，启动优启通软件，开始制作镜像"><a href="#第二步，启动优启通软件，开始制作镜像" class="headerlink" title="第二步，启动优启通软件，开始制作镜像"></a>第二步，启动优启通软件，开始制作镜像</h4><ul><li><p>找到关于程序，其他选项</p><p><img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210164758544.png" alt="image-20191210164758544"></p></li><li><p>将这里改为 <code>BOOTMGR-GRUB</code></p><p> <img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210164846600.png" alt="image-20191210164846600"></p></li><li><p>确定 保存，然后选择顶部的<code>生成iso</code>选项，选择保存位置</p><p><img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210164923365.png" alt="image-20191210164923365"></p></li><li><p>再生成之前，最好关闭window defender和其他杀毒软件，因为pe里面有一些破解工具会被当成病毒，会导致制作失败。</p></li></ul><p><img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210165052329.png" alt="image-20191210165052329"></p><ul><li><p>点击开始制作，等待制作完成后会在选择的目录下生成镜像文件，默认目录就是程序所在的目录。</p><p><img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210165219323.png" alt="image-20191210165219323"></p></li></ul><h4 id="第三步，将镜像文件解压到先前创建的5GB的fast32格式主分区内，得到如下文件，我是用的是7z解压工具"><a href="#第三步，将镜像文件解压到先前创建的5GB的fast32格式主分区内，得到如下文件，我是用的是7z解压工具" class="headerlink" title="第三步，将镜像文件解压到先前创建的5GB的fast32格式主分区内，得到如下文件，我是用的是7z解压工具"></a>第三步，将镜像文件解压到先前创建的5GB的fast32格式主分区内，得到如下文件，我是用的是7z解压工具</h4><p><img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210165335213.png" alt="image-20191210165335213"></p><h4 id="第四步，使用虚拟机测试pe是否制作成功"><a href="#第四步，使用虚拟机测试pe是否制作成功" class="headerlink" title="第四步，使用虚拟机测试pe是否制作成功"></a>第四步，使用虚拟机测试pe是否制作成功</h4><ol><li><p>   启动vm，新建虚拟机，选择典型</p><p> <img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210165458009.png" alt="image-20191210165458009"></p><p> 2.选择稍后安装系统，其实我们不需要安装系统</p></li></ol><p><img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210165526794.png" alt="image-20191210165526794"></p><p>3.这里随便选一个window版本吧，这里默认window10就可以</p><p><img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210165547853.png" alt="image-20191210165547853"></p><p>4.这里选择安装位置，起一个能识别的名字，测试完成后可以删除</p><p><img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210165633621.png" alt="image-20191210165633621"></p><p>5.磁盘大小默认即可，虚拟机创建完成</p><p>6.编辑虚拟机，点击添加按钮</p><p><img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210165817714.png" alt="image-20191210165817714"></p><p>7.弹出选项中选择添加硬盘。硬盘添加向导中，选择<code>使用物理磁盘</code></p><p><img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210165913461.png" alt="image-20191210165913461"></p><p>8.下一步，选择pe所在那那块硬盘，我电脑有3块硬盘，一块是系统固态硬盘，一块是机械硬盘，一块是移动硬盘，这里我选择第三个即我的移动硬盘，并且使用单个分区。</p><p><img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210170127326.png" alt="image-20191210170127326"></p><p>9.可以看到有两个分区，一个是5g的pe分区，一个是900多g的硬盘剩下的分区，勾选pe分区，点下一步并完成硬盘的添加。</p><p><img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210170257064.png" alt="image-20191210170257064"></p><p>10.硬盘添加完成后，可以看到有两块硬盘了。</p><p><img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210170402094.png" alt="image-20191210170402094"></p><p>11.右键这里，选择<code>电源</code> <code>打开电源时进入固件</code>，启动过程中有弹窗点确认即可</p><p><img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210170600352.png" alt="image-20191210170600352"></p><p>12.启动后界面如下</p><p><img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210170651928.png" alt="image-20191210170651928"></p><p>13.键盘上下移动光标选择 <code>hard drive（1.0）</code> 并<code>回车</code>从此硬盘启动。第一个硬盘0.0为虚拟硬盘，第二个硬盘1.0为我们后来添加的pe硬盘。</p><p><img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210170806389.png" alt="image-20191210170806389"></p><p>14.系统进入此界面，键盘上下移动光标选中第一项（默认就是第一项），回车进入。</p><p><img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210170844519.png" alt="image-20191210170844519"></p><p>15.在虚拟机内成功进入了pe。</p><p><img src="/img/in/2019-12-10-%E5%B0%86%E4%BC%98%E5%90%AF%E9%80%9A%E5%90%AF%E5%8A%A8pe%E5%88%B6%E4%BD%9C%E5%88%B0%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E4%B8%8A/image-20191210171106857.png" alt="image-20191210171106857"></p><h4 id="第五步，实体机测试"><a href="#第五步，实体机测试" class="headerlink" title="第五步，实体机测试"></a>第五步，实体机测试</h4><p>既然虚拟机能进入，接下来可以在真实机器上测试一下。我从bios中启动后是没问题的。</p><h4 id="第六步-，更新"><a href="#第六步-，更新" class="headerlink" title="第六步 ，更新"></a>第六步 ，更新</h4><p>我们可以保留制作好的iso镜像，如果pe不小心损坏了，可以删除掉再解压回去，下次优启通有更新了，也可以重新制作镜像，替换掉移动硬盘中解压的文件即可。.</p><p>以上就是将pe制作到移动硬盘上的方法，此方法不需要格式化硬盘，不会弄丢硬盘上文件，并且更新和替换都非常方便。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.itsk.com/thread-396932-1-1.html">3TB的移动硬盘如何用优启通做成PE启动盘</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>优启通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>花一天时间折腾下gitpage，将博客迁移到gitpage上</title>
    <link href="/470821367.html"/>
    <url>/470821367.html</url>
    
    <content type="html"><![CDATA[<h3 id="花一天时间折腾下gitpage，将博客迁移到gitpage上"><a href="#花一天时间折腾下gitpage，将博客迁移到gitpage上" class="headerlink" title="花一天时间折腾下gitpage，将博客迁移到gitpage上"></a>花一天时间折腾下gitpage，将博客迁移到gitpage上</h3><p>今天花点时间将博客迁移到gitpage上，下面总结下过程</p><ul><li>TOC<br>{:toc}</li></ul><h4 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1.创建仓库"></a>1.创建仓库</h4><p>这个没什么难度，创建一个[你的名字.github.io]的空白仓库即可</p><h4 id="2-开启gitpage"><a href="#2-开启gitpage" class="headerlink" title="2.开启gitpage"></a>2.开启gitpage</h4><p>在该仓库的设置里，开启gitpage，访问网址[你的名字.github.io]即可访问到空白的页面</p><h4 id="3-搜索下载喜欢的jekyll主题"><a href="#3-搜索下载喜欢的jekyll主题" class="headerlink" title="3.搜索下载喜欢的jekyll主题"></a>3.搜索下载喜欢的jekyll主题</h4><p>一顿百度，最后在知乎上找到一个好看的主题 <a href="https://www.zhihu.com/question/20223939">帖子链接</a>,于是下载之</p><h4 id="4-修改主题"><a href="#4-修改主题" class="headerlink" title="4.修改主题"></a>4.修改主题</h4><p>解压出来的文件目录如下:</p><p><img src="/img/in/2019-11-28-%E8%8A%B1%E4%B8%80%E5%A4%A9%E6%97%B6%E9%97%B4%E6%8A%98%E8%85%BE%E4%B8%8Bgitpage%E5%B0%86%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0gitpage%E4%B8%8A/1.png" alt="文件目录"></p><pre><code class="hljs">includes 模板htmllayouts  文章样式模板htmlpoistsmarkdown 源文章sitejkeyll自动生成的，可删除css 样式fonts 字体img  各种图片jsjsless样式文件pwaconfig.yml 主配置</code></pre><p>等等 <a href="https://github.com/Huxpro/huxpro.github.io">仓库地址</a> readme里面有详细解释</p><h4 id="5-将自己的文章转成主题能使用的形式"><a href="#5-将自己的文章转成主题能使用的形式" class="headerlink" title="5.将自己的文章转成主题能使用的形式"></a>5.将自己的文章转成主题能使用的形式</h4><blockquote><p>也就仿照着这个头部将信息填写进去，，上下各用三个横线包住。</p></blockquote><p><img src="/img/in/2019-11-28-%E8%8A%B1%E4%B8%80%E5%A4%A9%E6%97%B6%E9%97%B4%E6%8A%98%E8%85%BE%E4%B8%8Bgitpage%E5%B0%86%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0gitpage%E4%B8%8A/2.png" alt="文章格式"></p><p>可以看出文章文件名命名规则为<br>年-月-日-标题<br>文章内部最前面个，需要加入下面这种格式的来识别标题等</p><pre><code class="hljs">---layout:     post    #选择那个主题 layouts文件夹里的title:      &quot;你好，世界&quot;  #标题subtitle:   &quot;&quot;#副标题date:       2019-05-26  #日期author:     &quot;hcy&quot;#作者header-img: &quot;img/gene-head-img.jpg&quot; #文章头图tags:    - diary#打标签---</code></pre><p>​<br>今天是 2019-05-26#正文</p><h4 id="6-本地运行预览"><a href="#6-本地运行预览" class="headerlink" title="6.本地运行预览"></a>6.本地运行预览</h4><p>需要在本地搭建jekyll环境，而jekyll是用ruby开发的</p><h5 id="下载ruby及安装"><a href="#下载ruby及安装" class="headerlink" title="下载ruby及安装"></a>下载ruby及安装</h5><p>这个软件对window兼容不太好，教程参考这个<a href="http://jekyll-windows.juthilo.com/5-running-jekyll/">window上运行jekyll</a>进行安装</p><p>文件所在的目录下，调用<code>jekyll serve</code>命令测试运行，如果没报错的话，控制台上会显示打开127.0.0.1:4000 就可以访问啦<br>如果报错的话，可以看看下面的内容，或者根据错误信息查询，记得主配置文件config.yml里面的东西要好好看一下，一条一条的看</p><h4 id="7-遇到的问题"><a href="#7-遇到的问题" class="headerlink" title="7.遇到的问题"></a>7.遇到的问题</h4><h5 id="jekyll中文文件名本地预览问题，中文的文件名本地无法打开，会报404"><a href="#jekyll中文文件名本地预览问题，中文的文件名本地无法打开，会报404" class="headerlink" title="jekyll中文文件名本地预览问题，中文的文件名本地无法打开，会报404"></a>jekyll中文文件名本地预览问题，中文的文件名本地无法打开，会报404</h5><p>解决办法<a href="http://kael-aiur.com/%E5%85%A5%E9%97%A8%E6%8C%87%E5%BC%95/jekyll%E4%B8%AD%E6%96%87%E6%96%87%E4%BB%B6%E5%90%8D%E6%9C%AC%E5%9C%B0%E9%A2%84%E8%A7%88%E9%97%AE%E9%A2%98.html">jekyll中文文件名本地预览问题</a>如下，</p><p>修改安装目录\Ruby22-x64\lib\ruby\2.2.0\webrick\httpservlet下的filehandler.rb文件，建议先备份。</p><p>找到下列两处，添加一句（ + 的一行为添加部分）</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">path</span> = req.path_info.dup.force_encoding(Encoding.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;filesystem&quot;</span>))<br>+ <span class="hljs-built_in">path</span>.force_encoding(<span class="hljs-string">&quot;UTF-8&quot;</span>) # 加入编码<br><span class="hljs-keyword">if</span> trailing_pathsep?(req.path_info)<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">break</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">base</span> == <span class="hljs-string">&quot;/&quot;</span><br>+ <span class="hljs-keyword">base</span>.force_encoding(<span class="hljs-string">&quot;UTF-8&quot;</span>) <span class="hljs-meta"># 加入編碼</span><br><span class="hljs-keyword">break</span> unless File.directory?(File.expand_path(res.filename + <span class="hljs-keyword">base</span>))<br></code></pre></td></tr></table></figure><p>然后重启服务器即可jekyll clean &amp;&amp; jekyll s</p><h5 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h5><pre><code class="hljs">Dependency Error: Yikes! It looks like you don’t have jekyll-paginate or one of its dependencies installed. In order to use Jekyll as currently configured, you’ll need to install this gem. The full error message from Ruby is: ‘cannot load such file – jekyll-paginate’ If you run into trouble,you can find helpful resources at Getting Help</code></pre><p>运行<code>gem install jekyll-paginate</code>安装jekyll-paginate即可</p><h4 id="8-上传到github"><a href="#8-上传到github" class="headerlink" title="8.上传到github"></a>8.上传到github</h4><pre><code class="hljs">直接git绑定远程仓库，上传等30s左右就能打开了git remote add origin Urlxxxxxxgit push origin master</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>gitpage</tag>
      
      <tag>jekyll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java hkdf算法生成密钥</title>
    <link href="/2958915134.html"/>
    <url>/2958915134.html</url>
    
    <content type="html"><![CDATA[<h1 id="java-hkdf-算法生成密钥"><a href="#java-hkdf-算法生成密钥" class="headerlink" title="java hkdf 算法生成密钥"></a>java hkdf 算法生成密钥</h1><ul><li>TOC<br>{:toc}</li></ul><blockquote><p>hkdf算法包含两个过程，‘提取’ 和 ‘扩展’，来生成任意长度的，更随机的密码。</p></blockquote><h5 id="生成密码需要的元素"><a href="#生成密码需要的元素" class="headerlink" title="生成密码需要的元素"></a>生成密码需要的元素</h5><p>名称|类型|例子|说明<br>-|-|-|-|-<br>password|byte[]|”abc”.getBytes()|用户输入的密码<br>salt|byte[]|new byte[]{1,5,7,6,41,85,63,7,89}|用于提取密码<br>info|byte[]|”product-info”.getByte()|使生成密码更随机<br>length|int|64|希望生成的密钥长度</p><h5 id="1-提取"><a href="#1-提取" class="headerlink" title="1.提取"></a>1.提取</h5><blockquote><p>创建hkdfExtract函数，用salt摘要password，示例代码如下:</p><pre><code class="hljs">伪代码: prk = hkdfExtract（salt,password）</code></pre></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] hkdfExtract(<span class="hljs-type">byte</span>[] salt, <span class="hljs-type">byte</span>[] passsword) <span class="hljs-keyword">throws</span> NoSuchAlgorithmException, InvalidKeyException &#123;<br>      <span class="hljs-comment">//获取消息摘要算法，hdkfSha1 就用sha1算法，hdkfSha256就用sha256算法，也就是hkdf算法配合某一个消息摘要算法使用</span><br><span class="hljs-type">Mac</span> <span class="hljs-variable">mac</span> <span class="hljs-operator">=</span> Mac.getInstance(<span class="hljs-string">&quot;HmacSHA1&quot;</span>);<br>      <span class="hljs-comment">//用salt作为密钥初始化</span><br><span class="hljs-type">SecretKeySpec</span> <span class="hljs-variable">keySpec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(salt, <span class="hljs-string">&quot;HmacSHA1&quot;</span>);<br>      mac.init(keySpec);<br>      <span class="hljs-comment">//对password进行摘要</span><br><span class="hljs-keyword">return</span> mac.doFinal(passsword);<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>上面的意思就是用salt做sha算法的密钥，对password进行摘要，得到的结果作为<code>提取</code>步骤的结果prk</p><h5 id="2-扩展"><a href="#2-扩展" class="headerlink" title="2.扩展"></a>2.扩展</h5><pre><code class="hljs">原理：key = hkdfExpand(prk,info,length)</code></pre><p>具体逻辑,伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<span class="hljs-comment">//创建byte数组，需要多长的密钥就创建多长的数组</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>； <span class="hljs-comment">//设置一个递增的byte变量，从1开始 </span><br>digest=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>]  <span class="hljs-comment">//初始摘要结果变量，第一次是空byte数组</span><br><br><span class="hljs-type">Mac</span> <span class="hljs-variable">sha</span> <span class="hljs-operator">=</span> Mac.getInstance(<span class="hljs-string">&quot;HmacSHA1&quot;</span>);<br>sha.init(prk);<span class="hljs-comment">//使用第一步生成的prk，初始化一个sha1</span><br><br><span class="hljs-comment">//每次循环将摘要的结果存入result中，直到result内个数大于等于length为止，然后取前length个返回</span><br>whilt(<span class="hljs-literal">true</span>)&#123;<br>sha.update(digest) <span class="hljs-comment">//sha算法分别摘要，`digest`，`info`，`t`，得到的结果保存在digest中</span><br>sha.update(info)<br>sha.update(t)<br>digest = sha.doFinal();<br>t++；<span class="hljs-comment">//每次循环后，t递增</span><br>result+=digest; <br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>这里的意思是，以上一步生成的prk作为sha的密钥，对digtest、info、t进行摘要，将摘要结果保存在result中，<br>比如sha1每次摘要结果长度是20，如果参数length &gt;20 则再次对digtest、info、t摘要，将结果叠加进去<br>注意第二次的digtest为上一次摘要的结果，t也递增了，最终获得的长度将大于length，取前length个作为hkdf的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//实现代码如下</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] hkdfExpand(<span class="hljs-type">byte</span>[] prk, <span class="hljs-type">byte</span>[] info, <span class="hljs-type">int</span> length) <span class="hljs-keyword">throws</span> NoSuchAlgorithmException, InvalidKeyException &#123;<br>    <span class="hljs-type">Mac</span> <span class="hljs-variable">mac</span> <span class="hljs-operator">=</span> Mac.getInstance(<span class="hljs-string">&quot;HmacSHA1&quot;</span>);<br>    <span class="hljs-type">SecretKeySpec</span> <span class="hljs-variable">keySpec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(prk, <span class="hljs-string">&quot;HmacSHA1&quot;</span>);<br>    mac.init(keySpec);<br>    <span class="hljs-type">byte</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">byte</span>[] digest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">byte</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (pos &lt; result.length) &#123;<br>        mac.update(digest);<br>        mac.update(info);<br>        mac.update(t);<br>        digest = mac.doFinal();<br>        System.arraycopy(digest, <span class="hljs-number">0</span>, result, pos, Math.min(digest.length, length - pos));<br>        pos += digest.length;<br>        t++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="3-调用"><a href="#3-调用" class="headerlink" title="3.调用"></a>3.调用</h5><blockquote><p>经过上面两步操作，可以由给定的<code>salt</code> <code>password</code> <code>info</code> <code>keySize</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] createHkdfKey(String password,String info, <span class="hljs-type">byte</span>[] salt, <span class="hljs-type">int</span> keySize) <span class="hljs-keyword">throws</span> GeneralSecurityException &#123;<br><span class="hljs-comment">//第一步 先提取，得到prk    </span><br><span class="hljs-type">byte</span>[] prk = hkdfExtract(salt, passwoed.getBytes());<br><span class="hljs-comment">//第二步，扩展    </span><br><span class="hljs-keyword">return</span> hkdfExpand(prk, info, keySize);<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h5><pre><code class="hljs">总之hkdf算法还是比较简单的，且可以生成任意长度的密钥，可以搭配其他的摘要算法如hkdfSha1，hkdfSha256，hkdfMd5都是可以的。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>netty</tag>
      
      <tag>java加密解密</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MessageToByteEncoder使用注意</title>
    <link href="/1844705713.html"/>
    <url>/1844705713.html</url>
    
    <content type="html"><![CDATA[<h2 id="MessageToByteEncoder使用注意"><a href="#MessageToByteEncoder使用注意" class="headerlink" title="MessageToByteEncoder使用注意"></a>MessageToByteEncoder使用注意</h2><pre><code class="hljs">这个encoder会将message解析成byteBuffer，但要注意的一点是如果传入encode方法的message没有被消耗会没有被完全消耗，剩余没消耗完成的部分会被丢弃掉的从而导致encode出来的数据不全。</code></pre><h4 id="ByteToMessageCodec"><a href="#ByteToMessageCodec" class="headerlink" title="ByteToMessageCodec"></a>ByteToMessageCodec</h4><p>​这个双向codec内部使用的也是MessageToByteEncoder，也有同样的问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springmvc put请求参数绑定</title>
    <link href="/2728346615.html"/>
    <url>/2728346615.html</url>
    
    <content type="html"><![CDATA[<h3 id="springmvc-put请求参数绑定"><a href="#springmvc-put请求参数绑定" class="headerlink" title="springmvc put请求参数绑定"></a>springmvc put请求参数绑定</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><pre><code class="hljs">使用put请求 + x-www-urlencoded的形式，后端无法获取到参数</code></pre><ul><li><p>对于post请求，tomcat会帮忙解析请体中的参数封装成request，传入servlet，支持<code>form-data</code> 和 <code>x-www-urlencoded</code>两种形式的请求</p></li><li><p>对于put请求，tomcat只会帮忙解析form-data类型的请求，x-www-urlencoded形式的会以request.getInputStream的形获取</p><p>  要想让springmvc支持put + x-www-urlencoded形式的请求，<br>  1.要么配置tomcat让tomcat帮忙解析，<br>  2.要么添加<code>HttpPutFormContentFilter</code>拦截器（新版的叫做<code>FormContentFilter</code>支持delete请求），<br>  该拦截器做的事情是从request.getInputStream读取数据，解析成键值对封装到request中。</p></li></ul><h4 id="对于application-json形式的请求"><a href="#对于application-json形式的请求" class="headerlink" title="对于application&#x2F;json形式的请求"></a>对于application&#x2F;json形式的请求</h4><pre><code class="hljs">这种请求tomcat也是不帮助解析的，但springMvc自带了很多messageCovery解析这种形式的参数。原理是框架碰到了带有@RequestBody注解的参数，会尝试从request.getInputStream中读取数据然后使用自带的messageCovery进行解析从流中读取到的内容为参数通常我们会配置JackSon的messageCovery来处理json数据，反序列化成对象。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域与预检请求 PreFlightRequest，springSecurity解决跨域问题</title>
    <link href="/397637334.html"/>
    <url>/397637334.html</url>
    
    <content type="html"><![CDATA[<h2 id="跨域与预检请求-PreFlightRequest，springSecurity解决跨域问题"><a href="#跨域与预检请求-PreFlightRequest，springSecurity解决跨域问题" class="headerlink" title="跨域与预检请求 PreFlightRequest，springSecurity解决跨域问题"></a>跨域与预检请求 PreFlightRequest，springSecurity解决跨域问题</h2><ul><li>TOC<br>{:toc}</li></ul><h4 id="什么是预检请求"><a href="#什么是预检请求" class="headerlink" title="什么是预检请求"></a>什么是预检请求</h4><p>当浏览器发送post请求时，一般请求体都比较大，但如果是跨域的话，服务器会拒绝该请求，传输的数据被丢弃。<br>为了不浪费流量，浏览器在发送post前先发送一个小的options请求，将接下来的请求方式等设置到请求头中，<br>服务器检查请求头，如果服务器允许这样的请求<br>则返回200并在相应头中设置以下消息给客户端，如允许什么样的请求头，请求方式，是否允许带cookie等，<br>否则就拒绝请求。<br>这样的话，浏览器就不会再发送接下来的post请求了，从而节省资源。</p><ul><li>其中两个请求头就是<ul><li><p><code>Access-Control-Request-Method:POST</code>,表示稍后的请求使用什么method进行请求，这里是 port，</p></li><li><p><code>Access-Control-Request-Headers:content-type</code>,表示稍后的请求中自定义请求头是什么这里我是 content-type</p></li></ul></li></ul><h4 id="查看spring的CorsFilter源码"><a href="#查看spring的CorsFilter源码" class="headerlink" title="查看spring的CorsFilter源码"></a>查看spring的CorsFilter源码</h4><pre><code class="hljs">在servlet环境下，请求都要经过filter，spring为我们提供了CorsFilter来处理这个问题。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span><br><span class="hljs-params">FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br><span class="hljs-comment">//必须带有origin头部的请求，不带的则直接放行</span><br><span class="hljs-keyword">if</span> (CorsUtils.isCorsRequest(request)) &#123;<br><span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">corsConfiguration</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.configSource.getCorsConfiguration(request);<br><span class="hljs-keyword">if</span> (corsConfiguration != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//验证是否有效，源码在下面</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isValid</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.processor.processRequest(corsConfiguration, request, response);<br><span class="hljs-comment">//如果不是有效的||是预检请求则直接返回，表示拒绝</span><br><span class="hljs-comment">//这里如果验证失败了，response中会设置跨域提示相关的头部，则直接return告诉浏览器</span><br><span class="hljs-comment">//如果验证成功了，但是是预检请求，则response中设置了同意的头部，直接返回即可</span><br><span class="hljs-keyword">if</span> (!isValid || CorsUtils.isPreFlightRequest(request)) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>&#125;<br><br>filterChain.doFilter(request, response);<br>&#125;<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">上面源码可以看出，拦截器对请求进行检查，对是预检请求的request进行处理检查没通过则isValid为false，直接返回，此时response被设置了401状态码，前台看到的是401如果检查通过，但是是预检请求也直接返回，此时前台收到的是无内容的200响应</code></pre><h4 id="如何判断是预检请求的逻辑"><a href="#如何判断是预检请求的逻辑" class="headerlink" title="如何判断是预检请求的逻辑"></a>如何判断是预检请求的逻辑</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPreFlightRequest</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br><span class="hljs-comment">//</span><br><span class="hljs-keyword">return</span> (isCorsRequest(request) <br>&amp;&amp; HttpMethod.OPTIONS.matches(request.getMethod()) <br>&amp;&amp;request.getHeader(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD) != <span class="hljs-literal">null</span>);<br>&#125;<br><br><br></code></pre></td></tr></table></figure><pre><code class="hljs">上面源码isPreFlightRequest中三个`&amp;&amp;`连接的判断可以看出，满足预检请求的条件是1.是cors请求，即带有origin头的，如get方式的请求就不带有origin头，所以就不是cors请求2.必须是options的请求  3.带有Access-Control-Request-Method请求头，表示接下来的请求方式满足上面三个条件就是预检请求了</code></pre><h4 id="this-processor-processRequest-corsConfiguration-request-response-这里面做了什么"><a href="#this-processor-processRequest-corsConfiguration-request-response-这里面做了什么" class="headerlink" title="this.processor.processRequest(corsConfiguration, request, response)这里面做了什么"></a>this.processor.processRequest(corsConfiguration, request, response)这里面做了什么</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> CorsConfiguration config, HttpServletRequest request,</span><br><span class="hljs-params">HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//非cors请求的直接返回true</span><br><span class="hljs-keyword">if</span> (!CorsUtils.isCorsRequest(request)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//设过Access-Control-Allow-Origin的直接返回true，如果此filter前面还有其他filter处理过了，就会有Access-Control-Allow-Origin头了</span><br><span class="hljs-type">ServletServerHttpResponse</span> <span class="hljs-variable">serverResponse</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletServerHttpResponse</span>(response);<br><span class="hljs-keyword">if</span> (responseHasCors(serverResponse)) &#123;<br>logger.trace(<span class="hljs-string">&quot;Skip: response already contains \&quot;Access-Control-Allow-Origin\&quot;&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//是同源的直接返回true，同源的请求满足cors，允许放行</span><br><span class="hljs-type">ServletServerHttpRequest</span> <span class="hljs-variable">serverRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletServerHttpRequest</span>(request);<br><span class="hljs-keyword">if</span> (WebUtils.isSameOrigin(serverRequest)) &#123;<br>logger.trace(<span class="hljs-string">&quot;Skip: request is from same origin&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//得到是否是预检请求</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">preFlightRequest</span> <span class="hljs-operator">=</span> CorsUtils.isPreFlightRequest(request);<br><span class="hljs-comment">//如果config为空，则没有配置文件，然后判断如果是预检请求则拒绝，如果不是预检请求则放行。</span><br><span class="hljs-keyword">if</span> (config == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (preFlightRequest) &#123;<br>rejectRequest(serverResponse);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//真实检测逻辑，获取各种请求头和配置文件进行对比</span><br><span class="hljs-keyword">return</span> handleInternal(serverRequest, serverResponse, config, preFlightRequest);<br>&#125;<br><br><br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">handleInternal</span><span class="hljs-params">(ServerHttpRequest request, ServerHttpResponse response,</span><br><span class="hljs-params">CorsConfiguration config, <span class="hljs-type">boolean</span> preFlightRequest)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//获取origin头</span><br><span class="hljs-type">String</span> <span class="hljs-variable">requestOrigin</span> <span class="hljs-operator">=</span> request.getHeaders().getOrigin();<br><span class="hljs-comment">//与配置的AllowedOrigins进行比较，得到匹配的</span><br><span class="hljs-type">String</span> <span class="hljs-variable">allowOrigin</span> <span class="hljs-operator">=</span> checkOrigin(config, requestOrigin);<br><span class="hljs-type">HttpHeaders</span> <span class="hljs-variable">responseHeaders</span> <span class="hljs-operator">=</span> response.getHeaders();<br><br>responseHeaders.addAll(HttpHeaders.VARY, Arrays.asList(HttpHeaders.ORIGIN,<br>HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, HttpHeaders.ACCESS_CONTROL_REQUEST_HEADERS));<br><span class="hljs-comment">//如果origin都不匹配，返回false</span><br><span class="hljs-keyword">if</span> (allowOrigin == <span class="hljs-literal">null</span>) &#123;<br>logger.debug(<span class="hljs-string">&quot;Reject: &#x27;&quot;</span> + requestOrigin + <span class="hljs-string">&quot;&#x27; origin is not allowed&quot;</span>);<br>rejectRequest(response);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//获取请求method，如果是预检请求则获取Access-Control-Request-Method里的method</span><br><span class="hljs-type">HttpMethod</span> <span class="hljs-variable">requestMethod</span> <span class="hljs-operator">=</span> getMethodToUse(request, preFlightRequest);<br><span class="hljs-comment">//检查请求头是否是AllowedMethods里配置的</span><br>List&lt;HttpMethod&gt; allowMethods = checkMethods(config, requestMethod);<br><span class="hljs-keyword">if</span> (allowMethods == <span class="hljs-literal">null</span>) &#123;<br>logger.debug(<span class="hljs-string">&quot;Reject: HTTP &#x27;&quot;</span> + requestMethod + <span class="hljs-string">&quot;&#x27; is not allowed&quot;</span>);<br>rejectRequest(response);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//获取请求header，如果是预检请求则获取Access-Control-Request-Headers里配置的</span><br>List&lt;String&gt; requestHeaders = getHeadersToUse(request, preFlightRequest);<br><span class="hljs-comment">//请求头与AllowedHeader里的进行匹配</span><br>List&lt;String&gt; allowHeaders = checkHeaders(config, requestHeaders);<br><span class="hljs-keyword">if</span> (preFlightRequest &amp;&amp; allowHeaders == <span class="hljs-literal">null</span>) &#123;<br>logger.debug(<span class="hljs-string">&quot;Reject: headers &#x27;&quot;</span> + requestHeaders + <span class="hljs-string">&quot;&#x27; are not allowed&quot;</span>);<br>rejectRequest(response);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//上面的method，origin，head 三个检测都通过的话，则说明请求是自己人请求的，放行设置响应头</span><br>responseHeaders.setAccessControlAllowOrigin(allowOrigin);<br><br><span class="hljs-keyword">if</span> (preFlightRequest) &#123;<br>responseHeaders.setAccessControlAllowMethods(allowMethods);<br>&#125;<br><br><span class="hljs-keyword">if</span> (preFlightRequest &amp;&amp; !allowHeaders.isEmpty()) &#123;<br>responseHeaders.setAccessControlAllowHeaders(allowHeaders);<br>&#125;<br><br><span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(config.getExposedHeaders())) &#123;<br>responseHeaders.setAccessControlExposeHeaders(config.getExposedHeaders());<br>&#125;<br><br><span class="hljs-keyword">if</span> (Boolean.TRUE.equals(config.getAllowCredentials())) &#123;<br>responseHeaders.setAccessControlAllowCredentials(<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (preFlightRequest &amp;&amp; config.getMaxAge() != <span class="hljs-literal">null</span>) &#123;<br>responseHeaders.setAccessControlMaxAge(config.getMaxAge());<br>&#125;<br><br>response.flush();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="总结，什么时候允许request向下进入servlet"><a href="#总结，什么时候允许request向下进入servlet" class="headerlink" title="总结，什么时候允许request向下进入servlet"></a>总结，什么时候允许request向下进入servlet</h4><ul><li><p>非cors请求，即头部不带origin的：有效</p></li><li><p>response上已经设置过Access-Control-Allow-Origin：有效</p></li><li><p>同源请求：有效</p></li><li><p>缺少cors配置，是预检请求：拒绝</p></li><li><p>缺少cors配置，不是预检请求：有效</p></li><li><p>如果头部中的origin和配置的AllowedOrigins不匹配：拒绝</p></li><li><p>如果头部中的Access-Control-Request-Method和配置的AllowedMethods不匹配：拒绝</p></li><li><p>如果头部中的Access-Control-Request-Headers与配置中AllowedHeader不匹配且是预检请求：拒绝</p></li></ul><h4 id="在springSecurity-的config中配置cors的例子"><a href="#在springSecurity-的config中配置cors的例子" class="headerlink" title="在springSecurity 的config中配置cors的例子"></a>在springSecurity 的config中配置cors的例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">   http.cors().configurationSource(request -&gt; &#123;<br>         <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsConfiguration</span>();<br><span class="hljs-comment">//设置允许的头部，与请求头中的origin进行比对</span><br>         c.setAllowedOrigins(Arrays.asList(<span class="hljs-string">&quot;http://192.168.31.114&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>));<br><span class="hljs-comment">//设置允许的method，和请求method或预检请求Access-Control-Request-Method指定的method进行比对</span><br>         c.setAllowedMethods(Arrays.asList(<span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;OPTIONS&quot;</span>, <span class="hljs-string">&quot;PUT&quot;</span>));<br><span class="hljs-comment">//设置请求头，与请求head比对或预检请求的Access-Control-Request-Headers比对</span><br>         c.addAllowedHeader(<span class="hljs-string">&quot;content-type&quot;</span>);<br><span class="hljs-comment">//允许携带cookie</span><br>         c.setAllowCredentials(<span class="hljs-literal">true</span>);<br>         c.setMaxAge(<span class="hljs-number">1800L</span>);<br>         <span class="hljs-keyword">return</span> c;<br>     &#125;);<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>springSecurity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty应该怎样处理异常</title>
    <link href="/1825389021.html"/>
    <url>/1825389021.html</url>
    
    <content type="html"><![CDATA[<h3 id="netty应该怎样处理异常"><a href="#netty应该怎样处理异常" class="headerlink" title="netty应该怎样处理异常"></a>netty应该怎样处理异常</h3><h5 id="netty-在ChannelInBouindHandler中为我们提供了exceptionCaught-方法，看下源码来看看他在什么情况下会被调用"><a href="#netty-在ChannelInBouindHandler中为我们提供了exceptionCaught-方法，看下源码来看看他在什么情况下会被调用" class="headerlink" title="netty 在ChannelInBouindHandler中为我们提供了exceptionCaught()方法，看下源码来看看他在什么情况下会被调用"></a>netty 在ChannelInBouindHandler中为我们提供了exceptionCaught()方法，看下源码来看看他在什么情况下会被调用</h5><p>首先点开 <code>ctx.fireChannelRead(msg);</code>的源码查看,发现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title class_">ChannelHandlerContext</span> <span class="hljs-title function_">fireChannelRead</span>(<span class="hljs-params">final <span class="hljs-title class_">Object</span> msg</span>) &#123;<br>       <span class="hljs-title function_">invokeChannelRead</span>(<span class="hljs-title function_">findContextInbound</span>(<span class="hljs-variable constant_">MASK_CHANNEL_READ</span>), msg);<br>       <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>   &#125;<br><br>   <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">invokeChannelRead</span>(<span class="hljs-params">final <span class="hljs-title class_">AbstractChannelHandlerContext</span> next, <span class="hljs-title class_">Object</span> msg</span>) &#123;<br>       final <span class="hljs-title class_">Object</span> m = next.<span class="hljs-property">pipeline</span>.<span class="hljs-title function_">touch</span>(<span class="hljs-title class_">ObjectUtil</span>.<span class="hljs-title function_">checkNotNull</span>(msg, <span class="hljs-string">&quot;msg&quot;</span>), next);<br>       <span class="hljs-title class_">EventExecutor</span> executor = next.<span class="hljs-title function_">executor</span>();<br>       <span class="hljs-keyword">if</span> (executor.<span class="hljs-title function_">inEventLoop</span>()) &#123;<br>           next.<span class="hljs-title function_">invokeChannelRead</span>(m);<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           executor.<span class="hljs-title function_">execute</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>               <span class="hljs-meta">@Override</span><br>               <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>                   next.<span class="hljs-title function_">invokeChannelRead</span>(m);<br>               &#125;<br>           &#125;);<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">invokeChannelRead</span>(<span class="hljs-params"><span class="hljs-title class_">Object</span> msg</span>) &#123;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-title function_">invokeHandler</span>()) &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               ((<span class="hljs-title class_">ChannelInboundHandler</span>) <span class="hljs-title function_">handler</span>()).<span class="hljs-title function_">channelRead</span>(<span class="hljs-variable language_">this</span>, msg);<br>           &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Throwable</span> t) &#123;<br>               <span class="hljs-title function_">notifyHandlerException</span>(t);<br>           &#125;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-title function_">fireChannelRead</span>(msg);<br>       &#125;<br>   &#125;<br><br><br></code></pre></td></tr></table></figure><p>上面代码会在pinline中查找下一个inHandler，并回掉他的ChannelRead方法,且用try catch处理回掉过程。<br>如果报错会调用<code>notifyHandlerException(t)</code>方法</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notifyHandlerException</span><span class="hljs-params">(Throwable cause)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (inExceptionCaught(cause)) &#123;<br>           <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>               logger.warn(<br>                       <span class="hljs-string">&quot;An exception was thrown by a user handler &quot;</span> +<br>                               <span class="hljs-string">&quot;while handling an exceptionCaught event&quot;</span>, cause);<br>           &#125;<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br><br>       invokeExceptionCaught(cause);<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invokeExceptionCaught</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Throwable cause)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (invokeHandler()) &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-keyword">handler</span>().exceptionCaught(<span class="hljs-keyword">this</span>, cause);<br>           &#125; <span class="hljs-keyword">catch</span> (Throwable <span class="hljs-keyword">error</span>) &#123;<br>               <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                   logger.debug(<br>                       <span class="hljs-string">&quot;An exception &#123;&#125;&quot;</span> +<br>                       <span class="hljs-string">&quot;was thrown by a user handler&#x27;s exceptionCaught() &quot;</span> +<br>                       <span class="hljs-string">&quot;method while handling the following exception:&quot;</span>,<br>                       ThrowableUtil.stackTraceToString(<span class="hljs-keyword">error</span>), cause);<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>                   logger.warn(<br>                       <span class="hljs-string">&quot;An exception &#x27;&#123;&#125;&#x27; [enable DEBUG level for full stacktrace] &quot;</span> +<br>                       <span class="hljs-string">&quot;was thrown by a user handler&#x27;s exceptionCaught() &quot;</span> +<br>                       <span class="hljs-string">&quot;method while handling the following exception:&quot;</span>, <span class="hljs-keyword">error</span>, cause);<br>               &#125;<br>           &#125;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           fireExceptionCaught(cause);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p><code>notifyHandlerException(t)</code>方法会调用<code>handler()</code>即当前handler的<code>exceptionCaught(this, cause);</code>方法</p><p>如果当前handler实现ChannelInboundHandlerAdapter且没实现exceptionCaught方法的话，默认会调用<code> ctx.fireExceptionCaught(cause)</code>,即下一个handler的<code>exceptionCaught</code>方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​netty中执行handler报错时，会先调用当前handler的exceptionCaught方法，如果没有当前没重写exceptionCaught方法会调用下一个handler的exceptionCaught方法。<br>​所以如果错误需要在当前handler处理，则重写exceptionCaught方法，自己选择要不要将异常传递下去，<br>如果当前handler不能处理，可以在pipline链最后一位放置一个重写exceptionCaught方法的handler<br>，放在pipline最后一位即可。</p><p>​</p><p>​有一种情况下，<code>ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE</code>，这是一个监听器，它会将错误从head节点向下传播。</p>]]></content>
    
    
    
    <tags>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty 不要要在future监听器的回掉函数中抛出异常</title>
    <link href="/1878396521.html"/>
    <url>/1878396521.html</url>
    
    <content type="html"><![CDATA[<h3 id="netty-不要要在future监听器的回掉函数中抛出异常"><a href="#netty-不要要在future监听器的回掉函数中抛出异常" class="headerlink" title="netty 不要要在future监听器的回掉函数中抛出异常"></a>netty 不要要在future监听器的回掉函数中抛出异常</h3><pre><code class="hljs">promise身上添加的监听器，当promise完成过后，会回掉`notifyListeners();`方法。通知所有的监听器在监听器内抛出的异常都会被吃掉打印出来。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//判断是否要通知监听器</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyListeners</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> executor();<br>        <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">InternalThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> InternalThreadLocalMap.get();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">stackDepth</span> <span class="hljs-operator">=</span> threadLocals.futureListenerStackDepth();<br>            <span class="hljs-keyword">if</span> (stackDepth &lt; MAX_LISTENER_STACK_DEPTH) &#123;<br>                threadLocals.setFutureListenerStackDepth(stackDepth + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    notifyListenersNow();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    threadLocals.setFutureListenerStackDepth(stackDepth);<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        safeExecute(executor, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                notifyListenersNow();<br>            &#125;<br>        &#125;);<br>    &#125;<br><br><span class="hljs-comment">//根据监听器类不同的处理方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyListenersNow</span><span class="hljs-params">()</span> &#123;<br>    Object listeners;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-comment">// Only proceed if there are listeners to notify and we are not already notifying listeners.</span><br>        <span class="hljs-keyword">if</span> (notifyingListeners || <span class="hljs-built_in">this</span>.listeners == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        notifyingListeners = <span class="hljs-literal">true</span>;<br>        listeners = <span class="hljs-built_in">this</span>.listeners;<br>        <span class="hljs-built_in">this</span>.listeners = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (listeners <span class="hljs-keyword">instanceof</span> DefaultFutureListeners) &#123;<br>            notifyListeners0((DefaultFutureListeners) listeners);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            notifyListener0(<span class="hljs-built_in">this</span>, (GenericFutureListener&lt;?&gt;) listeners);<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.listeners == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// Nothing can throw from within this method, so setting notifyingListeners back to false does not</span><br>                <span class="hljs-comment">// need to be in a finally block.</span><br>                notifyingListeners = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            listeners = <span class="hljs-built_in">this</span>.listeners;<br>            <span class="hljs-built_in">this</span>.listeners = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//循环遍历所有的监听器</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyListeners0</span><span class="hljs-params">(DefaultFutureListeners listeners)</span> &#123;<br>    GenericFutureListener&lt;?&gt;[] a = listeners.listeners();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> listeners.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i ++) &#123;<br>        notifyListener0(<span class="hljs-built_in">this</span>, a[i]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//回掉operationComplete方法，捕获所有的Throwable并warn输出出来</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyListener0</span><span class="hljs-params">(Future future, GenericFutureListener l)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        l.operationComplete(future);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>            logger.warn(<span class="hljs-string">&quot;An exception was thrown by &quot;</span> + l.getClass().getName() + <span class="hljs-string">&quot;.operationComplete()&quot;</span>, t);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code class="hljs">不要在监听器中抛出异常，那样不会生效果，但可以将异常传递出去</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springSecurity的两种rememberMe方式</title>
    <link href="/1766048619.html"/>
    <url>/1766048619.html</url>
    
    <content type="html"><![CDATA[<h2 id="springSecurity的两种rememberMe方式"><a href="#springSecurity的两种rememberMe方式" class="headerlink" title="springSecurity的两种rememberMe方式"></a>springSecurity的两种rememberMe方式</h2><pre><code class="hljs">springSecurity 使用RememberMeAuthenticationFilter处理记住我功能，代码逻辑</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span><br><span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br><span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (HttpServletRequest) req;<br><span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> (HttpServletResponse) res;<br><span class="hljs-comment">//当前处于未登录状态</span><br><span class="hljs-keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//使用rememberMeServices进行自动登录，返回登录成功标识</span><br><span class="hljs-type">Authentication</span> <span class="hljs-variable">rememberMeAuth</span> <span class="hljs-operator">=</span> rememberMeServices.autoLogin(request,response);<br><br><span class="hljs-keyword">if</span> (rememberMeAuth != <span class="hljs-literal">null</span>) &#123;<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//验证rememberMeAuth的key和rememberMeServices的key是否一致</span><br>rememberMeAuth = authenticationManager.authenticate(rememberMeAuth);<br><br><span class="hljs-comment">// Store to SecurityContextHolder</span><br>SecurityContextHolder.getContext().setAuthentication(rememberMeAuth);<br><br>onSuccessfulAuthentication(request, response, rememberMeAuth);<br><br><span class="hljs-keyword">if</span> (successHandler != <span class="hljs-literal">null</span>) &#123;<br>successHandler.onAuthenticationSuccess(request, response,<br>rememberMeAuth);<br><br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">catch</span> (AuthenticationException authenticationException) &#123;<br><br>&#125;<br><br>chain.doFilter(request, response);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>chain.doFilter(request, response);<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="springSeciruity提供的实现"><a href="#springSeciruity提供的实现" class="headerlink" title="springSeciruity提供的实现"></a>springSeciruity提供的实现</h3><pre><code class="hljs">上面的filter使用RememberMeServices来处理自动登录，TokenBasedRememberMeServices和PersistentTokenBasedRememberMeServices是springSecurity提供的两种处理remenberMe的实现类他俩都继承自 AbstractRememberMeServices</code></pre><h3 id="0-AbstractRememberMeServices"><a href="#0-AbstractRememberMeServices" class="headerlink" title="0.AbstractRememberMeServices"></a>0.AbstractRememberMeServices</h3><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-comment">//自动登录方法</span><br><span class="hljs-variable">public</span> <span class="hljs-variable">final</span> <span class="hljs-title class_">Authentication</span> <span class="hljs-title function_">autoLogin</span>(<span class="hljs-params">HttpServletRequest</span> <span class="hljs-params">request</span>,<br><span class="hljs-params">HttpServletResponse</span> <span class="hljs-params">response</span>) &#123;<br><br><span class="hljs-comment">//获取cookie中的指定cookie</span><br><span class="hljs-title class_">String</span> <span class="hljs-variable">rememberMeCookie</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">extractRememberMeCookie</span>(<span class="hljs-variable">request</span>);<br><br><span class="hljs-title class_">UserDetails</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><span class="hljs-title function_">try</span> &#123;<br><span class="hljs-comment">//base64转成字符串，再按照.分隔成数组</span><br><span class="hljs-title class_">String</span>[] <span class="hljs-variable">cookieTokens</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">decodeCookie</span>(<span class="hljs-variable">rememberMeCookie</span>);<br><span class="hljs-comment">//子类实现的登录方法</span><br><span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">processAutoLoginCookie</span>(<span class="hljs-variable">cookieTokens</span>, <span class="hljs-variable">request</span>, <span class="hljs-variable">response</span>);<br><span class="hljs-comment">//检查用户状态，是否锁定，是否有效等</span><br><span class="hljs-variable">userDetailsChecker</span>.<span class="hljs-property">check</span>(<span class="hljs-variable">user</span>);<br><span class="hljs-comment">//返回验证成功的Authentication</span><br><span class="hljs-keyword">return</span> <span class="hljs-title function_">createSuccessfulAuthentication</span>(<span class="hljs-variable">request</span>, <span class="hljs-variable">user</span>);<br>&#125;<br><span class="hljs-title function_">catch</span> (<span class="hljs-title class_">CookieTheftException</span> <span class="hljs-variable">cte</span>) &#123;<br><span class="hljs-title function_">cancelCookie</span>(<span class="hljs-variable">request</span>, <span class="hljs-variable">response</span>);<br><span class="hljs-variable">throw</span> <span class="hljs-variable">cte</span>;<br>&#125;<br><span class="hljs-title function_">catch</span> (<span class="hljs-title class_">UsernameNotFoundException</span> <span class="hljs-variable">noUser</span>) &#123;<br><span class="hljs-variable">logger</span>.<span class="hljs-property">debug</span>(<span class="hljs-string">&quot;Remember-me login was valid but corresponding user not found.&quot;</span>,<br><span class="hljs-variable">noUser</span>);<br>&#125;<br><span class="hljs-title function_">catch</span> (<span class="hljs-title class_">InvalidCookieException</span> invalidCookie) &#123;<br><span class="hljs-variable">logger</span>.<span class="hljs-property">debug</span>(<span class="hljs-string">&quot;Invalid remember-me cookie: &quot;</span> <span class="hljs-operator">+</span> invalidCookie.<span class="hljs-property">getMessage</span>());<br>&#125;<br><span class="hljs-title function_">catch</span> (<span class="hljs-title class_">AccountStatusException</span> <span class="hljs-variable">statusInvalid</span>) &#123;<br><span class="hljs-variable">logger</span>.<span class="hljs-property">debug</span>(<span class="hljs-string">&quot;Invalid UserDetails: &quot;</span> <span class="hljs-operator">+</span> <span class="hljs-variable">statusInvalid</span>.<span class="hljs-property">getMessage</span>());<br>&#125;<br><span class="hljs-title function_">catch</span> (<span class="hljs-title class_">RememberMeAuthenticationException</span> <span class="hljs-variable">e</span>) &#123;<br><span class="hljs-variable">logger</span>.<span class="hljs-property">debug</span>(<span class="hljs-variable">e</span>.<span class="hljs-property">getMessage</span>());<br>&#125;<br><br><span class="hljs-title function_">cancelCookie</span>(<span class="hljs-variable">request</span>, <span class="hljs-variable">response</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="1-使用TokenBasedRememberMeServices如何实现processAutoLoginCookie方法的"><a href="#1-使用TokenBasedRememberMeServices如何实现processAutoLoginCookie方法的" class="headerlink" title="1. 使用TokenBasedRememberMeServices如何实现processAutoLoginCookie方法的"></a>1. 使用TokenBasedRememberMeServices如何实现processAutoLoginCookie方法的</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">protected</span> <span class="hljs-title class_">UserDetails</span> <span class="hljs-title function_">processAutoLoginCookie</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] cookieTokens,</span><br><span class="hljs-params"><span class="hljs-title class_">HttpServletRequest</span> request, <span class="hljs-title class_">HttpServletResponse</span> response</span>) &#123;<br><span class="hljs-comment">//验证cookie中解码完成的值数组长度是3，分别是[用户名，过期时间戳，md5(用户名：过期时间：密码：key)]</span><br><span class="hljs-keyword">if</span> (cookieTokens.<span class="hljs-property">length</span> != <span class="hljs-number">3</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidCookieException</span>(<span class="hljs-string">&quot;Cookie token did not contain 3&quot;</span><br>+ <span class="hljs-string">&quot; tokens, but contained &#x27;&quot;</span> + <span class="hljs-title class_">Arrays</span>.<span class="hljs-title function_">asList</span>(cookieTokens) + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>&#125;<br><br>long tokenExpiryTime;<br><span class="hljs-comment">//数组第二个元素转成Long</span><br><span class="hljs-keyword">try</span> &#123;<br>tokenExpiryTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>(cookieTokens[<span class="hljs-number">1</span>]).<span class="hljs-title function_">longValue</span>();<br>&#125;<br><span class="hljs-keyword">catch</span> (<span class="hljs-title class_">NumberFormatException</span> nfe) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidCookieException</span>(<br><span class="hljs-string">&quot;Cookie token[1] did not contain a valid number (contained &#x27;&quot;</span><br>+ cookieTokens[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;&#x27;)&quot;</span>);<br>&#125;<br><span class="hljs-comment">//验证是否过期</span><br><span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTokenExpired</span>(tokenExpiryTime)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidCookieException</span>(<span class="hljs-string">&quot;Cookie token[1] has expired (expired on &#x27;&quot;</span><br>+ <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(tokenExpiryTime) + <span class="hljs-string">&quot;&#x27;; current time is &#x27;&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>+ <span class="hljs-string">&quot;&#x27;)&quot;</span>);<br>&#125;<br><span class="hljs-comment">//使用UserDetailsService 查询出用户信息</span><br><span class="hljs-title class_">UserDetails</span> userDetails = <span class="hljs-title function_">getUserDetailsService</span>().<span class="hljs-title function_">loadUserByUsername</span>(<br>cookieTokens[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">//重新构造验证签名</span><br><span class="hljs-title class_">String</span> expectedTokenSignature = <span class="hljs-title function_">makeTokenSignature</span>(tokenExpiryTime,<br>userDetails.<span class="hljs-title function_">getUsername</span>(), userDetails.<span class="hljs-title function_">getPassword</span>());<br><span class="hljs-comment">//比较重新构造的签名和cookie中数组第三位中的签名是否一致</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-title function_">equals</span>(expectedTokenSignature, cookieTokens[<span class="hljs-number">2</span>])) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidCookieException</span>(<span class="hljs-string">&quot;Cookie token[2] contained signature &#x27;&quot;</span><br>+ cookieTokens[<span class="hljs-number">2</span>] + <span class="hljs-string">&quot;&#x27; but expected &#x27;&quot;</span> + expectedTokenSignature + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> userDetails;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><pre><code class="hljs">上面的方法就是根据cookie中查询的用户名到数据库中查询出真实用户信息。根据真实的信息，构造出签名与cookie中的签名进行比较。这样可以防止cookie伪造，但不能防止cookie被别人窃取使用。</code></pre><h3 id="2-使用PersistentTokenBasedRememberMeServices如何实现processAutoLoginCookie方法的"><a href="#2-使用PersistentTokenBasedRememberMeServices如何实现processAutoLoginCookie方法的" class="headerlink" title="2. 使用PersistentTokenBasedRememberMeServices如何实现processAutoLoginCookie方法的"></a>2. 使用PersistentTokenBasedRememberMeServices如何实现processAutoLoginCookie方法的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">protected</span> UserDetails <span class="hljs-title function_">processAutoLoginCookie</span><span class="hljs-params">(String[] cookieTokens,</span><br><span class="hljs-params">HttpServletRequest request, HttpServletResponse response)</span> &#123;<br><br><span class="hljs-keyword">if</span> (cookieTokens.length != <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidCookieException</span>(<span class="hljs-string">&quot;Cookie token did not contain &quot;</span> + <span class="hljs-number">2</span><br>+ <span class="hljs-string">&quot; tokens, but contained &#x27;&quot;</span> + Arrays.asList(cookieTokens) + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>&#125;<br><span class="hljs-comment">//获取cookie中的series和token。series是标识唯一cookie，token是生成cookie时创建的随机值</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">presentedSeries</span> <span class="hljs-operator">=</span> cookieTokens[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">presentedToken</span> <span class="hljs-operator">=</span> cookieTokens[<span class="hljs-number">1</span>];<br><span class="hljs-comment">//根据series到数据库中查询出此cookie的信息</span><br><span class="hljs-type">PersistentRememberMeToken</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> tokenRepository<br>.getTokenForSeries(presentedSeries);<br><br><span class="hljs-keyword">if</span> (token == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// No series match, so we can&#x27;t authenticate using this cookie</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RememberMeAuthenticationException</span>(<br><span class="hljs-string">&quot;No persistent token found for series id: &quot;</span> + presentedSeries);<br>&#125;<br><br><span class="hljs-comment">//比较数据库中查询出的token中的Token值是否与cookie中的token值相同，防止cookie伪造</span><br><span class="hljs-keyword">if</span> (!presentedToken.equals(token.getTokenValue())) &#123;<br><span class="hljs-comment">// Token doesn&#x27;t match series value. Delete all logins for this user and throw</span><br><span class="hljs-comment">// an exception to warn them.</span><br>tokenRepository.removeUserTokens(token.getUsername());<br><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CookieTheftException</span>(<br>messages.getMessage(<br><span class="hljs-string">&quot;PersistentTokenBasedRememberMeServices.cookieStolen&quot;</span>,<br><span class="hljs-string">&quot;Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack.&quot;</span>));<br>&#125;<br><span class="hljs-comment">//验证是否过期</span><br><span class="hljs-keyword">if</span> (token.getDate().getTime() + getTokenValiditySeconds() * <span class="hljs-number">1000L</span> &lt; System<br>.currentTimeMillis()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RememberMeAuthenticationException</span>(<span class="hljs-string">&quot;Remember-me login has expired&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//上面两步验证说明，cookie是有效的，这里创建新的token（Series不变，Token变成随机值）</span><br><span class="hljs-type">PersistentRememberMeToken</span> <span class="hljs-variable">newToken</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersistentRememberMeToken</span>(<br>token.getUsername(), token.getSeries(), generateTokenData(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//将修改后的Token更新到数据库 和返回给前台</span><br>tokenRepository.updateToken(newToken.getSeries(), newToken.getTokenValue(),<br>newToken.getDate());<br>addCookie(newToken, request, response);<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception e) &#123;<br>logger.error(<span class="hljs-string">&quot;Failed to update token: &quot;</span>, e);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RememberMeAuthenticationException</span>(<br><span class="hljs-string">&quot;Autologin failed due to data access problem&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> getUserDetailsService().loadUserByUsername(token.getUsername());<br>&#125;<br><br></code></pre></td></tr></table></figure><pre><code class="hljs">这个rememberMeServices的处理逻辑是，每次自动登录成功后将cookie中的某个随机值和数据库同步更新，假设cookie别别人盗用，自动登录后盗用者的cookie被更新了。主人的cookie就会变无效。下次主人会自动登录失败，系统就能发现cookie被盗用，此时删除数据库中的对应cookie验证，通知用户改密码等.</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>springSecurity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HeaderWriterFilter内部做了什么，导致静态资源不能访问了</title>
    <link href="/3487395032.html"/>
    <url>/3487395032.html</url>
    
    <content type="html"><![CDATA[<h2 id="HeaderWriterFilter内部做了什么，导致静态资源不能访问了"><a href="#HeaderWriterFilter内部做了什么，导致静态资源不能访问了" class="headerlink" title="HeaderWriterFilter内部做了什么，导致静态资源不能访问了"></a>HeaderWriterFilter内部做了什么，导致静态资源不能访问了</h2><pre><code class="hljs">此filter会向相应中添加一些响应头，如果不搞清楚可能出现各种问题，策略如下面</code></pre><h4 id="ContentTypeOptionsConfig，默认启用"><a href="#ContentTypeOptionsConfig，默认启用" class="headerlink" title="ContentTypeOptionsConfig，默认启用"></a>ContentTypeOptionsConfig，默认启用</h4><pre><code class="hljs">配置x-content-type-options响应头服务器设置该响应头，X-Content-Type-Options: nosniff，则浏览器拒绝MIME不正确的响应，放置MIME攻击</code></pre><h4 id="XXssConfig-默认-1-mode-block"><a href="#XXssConfig-默认-1-mode-block" class="headerlink" title="XXssConfig  默认 1;mode&#x3D;block"></a>XXssConfig  默认 1;mode&#x3D;block</h4><pre><code class="hljs">X-XSS-Protection 响应头，有三种值0： 表示关闭浏览器的XSS防护机制1：删除检测到的恶意代码， 如果响应报文中没有看到X-XSS-Protection 字段，那么浏览器就认为X-XSS-Protection配置为1，这是浏览器的默认设置1; mode=block：如果检测到恶意代码，在不渲染恶意代码</code></pre><h4 id="CacheControlConfig-默认启用"><a href="#CacheControlConfig-默认启用" class="headerlink" title="CacheControlConfig  默认启用"></a>CacheControlConfig  默认启用</h4><pre><code class="hljs">CacheControl响应头，控制缓存</code></pre><h4 id="HstsConfig"><a href="#HstsConfig" class="headerlink" title="HstsConfig"></a>HstsConfig</h4><pre><code class="hljs">Strict-Transport-Security响应头，只有https请求时添加此响应头告诉浏览器使用https方式访问</code></pre><h4 id="FrameOptionsConfig-默认启用"><a href="#FrameOptionsConfig-默认启用" class="headerlink" title="FrameOptionsConfig 默认启用"></a>FrameOptionsConfig 默认启用</h4><pre><code class="hljs">X-Frame-Options响应头，默认值DENY是否允许被iframe访问，DENY， SAMEORIGIN， ALLOW-FROMDENY：禁止被iframeSAMEORIGIN：允许同源ALLOW-FROM：这种不支持配置需要AllowFromStrategy类处理</code></pre><p>####HpkpConfig<br>添加Public-Key-Pins或者Public-Key-Pins-Report-Only<br>默认无配置，不启用<br>https相关的东东</p><p>####ContentSecurityPolicyConfig<br>添加Content-Security-Policy响应头或者Content-Security-Policy-Report-Only<br>与xss漏洞有关，默认无配置不开启</p><h4 id="ReferrerPolicyConfig-默认无配置，不启用"><a href="#ReferrerPolicyConfig-默认无配置，不启用" class="headerlink" title="ReferrerPolicyConfig 默认无配置，不启用"></a>ReferrerPolicyConfig 默认无配置，不启用</h4><pre><code class="hljs">Referrer-Policy响应头发送referer的策略</code></pre><h4 id="FeaturePolicyConfig"><a href="#FeaturePolicyConfig" class="headerlink" title="FeaturePolicyConfig"></a>FeaturePolicyConfig</h4><pre><code class="hljs">Feature-Policy响应头默认无配置，不启用控制浏览器启用或禁止一些api</code></pre><hr><pre><code class="hljs">springSecurity会根据上面写的规则，添加若干个响应头。我遇到的情况是，因为默认启用了FrameOptionsConfig:deny，导致了前端不能访问图片资源了，将这个策略禁用即可</code></pre><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><br><span class="hljs-comment">//禁用headerFilter 的禁止iframe访问策略</span><br>http<span class="hljs-selector-class">.headers</span>()<span class="hljs-selector-class">.frameOptions</span>()<span class="hljs-selector-class">.disable</span>();<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>springSecurity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringSecurityConf配置</title>
    <link href="/327144437.html"/>
    <url>/327144437.html</url>
    
    <content type="html"><![CDATA[<h2 id="SpringSecurityConf配置"><a href="#SpringSecurityConf配置" class="headerlink" title="SpringSecurityConf配置"></a>SpringSecurityConf配置</h2><h3 id="上配置文件"><a href="#上配置文件" class="headerlink" title="上配置文件"></a>上配置文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//开启配置</span><br><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringSecurityConf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;<br><br><span class="hljs-comment">//自己写的userService</span><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//解决跨域问题，在此处配置就不用在WebMvcConfigurationSupport里面配置了</span><br>        http.cors().configurationSource(request -&gt; &#123;<br>            <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorsConfiguration</span>();<br>            c.setAllowedOrigins(Arrays.asList(<span class="hljs-string">&quot;http://192.168.31.114&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>));<br>            c.setAllowedMethods(Arrays.asList(<span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;OPTIONS&quot;</span>, <span class="hljs-string">&quot;PUT&quot;</span>));<br>            c.setAllowCredentials(<span class="hljs-literal">true</span>);<br>            c.setMaxAge(<span class="hljs-number">1800L</span>);<br>            <span class="hljs-keyword">return</span> c;<br>        &#125;);<br><br>        <span class="hljs-comment">//禁用headerFilter 的禁止iframe访问策略</span><br>        http.headers().frameOptions().disable();<br>http.headers().cacheControl().disable();<br>        <span class="hljs-comment">//禁止csrf</span><br>        http.csrf().disable();<br>        <span class="hljs-comment">//退出登录逻辑</span><br>        http.logout()<br>                .logoutUrl(<span class="hljs-string">&quot;/system/logout&quot;</span>)<br>                .logoutSuccessHandler((request, response, authentication) -&gt; &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;s\&quot;:\&quot;1\&quot;,\&quot;r\&quot;:\&quot;login out success\&quot;&#125;&quot;</span>;<br>                    sendOut(str, response);<br>                &#125;);<br>        <span class="hljs-comment">//登录post，登录成功，登录失败 处理逻辑</span><br>        http.formLogin().loginPage(<span class="hljs-string">&quot;/&quot;</span>).loginProcessingUrl(<span class="hljs-string">&quot;/system/login&quot;</span>)<br>                .successHandler((request, response, authentication) -&gt; &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;s\&quot;:\&quot;1\&quot;,\&quot;r\&quot;:\&quot;login success\&quot;&#125;&quot;</span>;<br>                    sendOut(str, response);<br>                &#125;)<br>                .failureHandler((request, response, exception) -&gt; &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;s\&quot;:\&quot;0\&quot;,\&quot;r\&quot;:\&quot;&quot;</span> + exception.getMessage() + <span class="hljs-string">&quot;\&quot;&#125;&quot;</span>;<br>                    sendOut(str, response);<br>                &#125;);<br>        <span class="hljs-comment">//未登陆用户访问接口回调逻辑</span><br>        http.exceptionHandling().authenticationEntryPoint((request, response, authException) -&gt; sendOut(<span class="hljs-string">&quot;&#123;\&quot;s\&quot;:\&quot;0\&quot;,\&quot;r\&quot;:\&quot;not login\&quot;&#125;&quot;</span>, response));<br>        <span class="hljs-comment">//记住我功能，两个key要设置成一样的</span><br>        <span class="hljs-type">TokenBasedRememberMeServices</span> <span class="hljs-variable">rememberMeServices</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TokenBasedRememberMeServices</span>(<span class="hljs-string">&quot;TokenBasedRememberMeServicesKey$#&amp;^$&quot;</span>, userDetailsService);<br>        rememberMeServices.setAlwaysRemember(<span class="hljs-literal">true</span>);<br>        rememberMeServices.setCookieName(<span class="hljs-string">&quot;system.rememberMe&quot;</span>);<br>        http.rememberMe().rememberMeServices(rememberMeServices).key(<span class="hljs-string">&quot;TokenBasedRememberMeServicesKey$#&amp;^$&quot;</span>);<br><br>        <span class="hljs-comment">//权限路径</span><br>        http.authorizeRequests().antMatchers(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-string">&quot;/**/*.ico&quot;</span>).permitAll();<br>        http.authorizeRequests().anyRequest().authenticated();<br>    &#125;<br><br>    <span class="hljs-comment">//这个类配置认证管理器的AuthenticationManagerBuilder</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);<br>    &#125;<br><br><br>    <span class="hljs-comment">//框架会将此service 包装成一个DaoAuthenticationProvider</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">UserDetailsService</span> <span class="hljs-variable">userDetailsService</span> <span class="hljs-operator">=</span> username -&gt; &#123;<br><span class="hljs-comment">//从数据库查</span><br>        com.test.<span class="hljs-type">User</span> <span class="hljs-variable">userByUserName</span> <span class="hljs-operator">=</span> userService.getUserByUserName(username);<br>        <span class="hljs-comment">//只允许登录管理员类型的账户</span><br>        <span class="hljs-keyword">if</span> (userByUserName == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernameNotFoundException</span>(username);<br>        &#125;<br><span class="hljs-comment">//UserAdv实现了UserDetails</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserAdv</span>(userByUserName);<br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">PasswordEncoder</span> <span class="hljs-variable">passwordEncoder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PasswordEncoder</span>() &#123;<br><span class="hljs-comment">//明文转密文的方法，此处自己写的基于md5的转换方式        </span><br><span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">encode</span><span class="hljs-params">(CharSequence rawPassword)</span> &#123;<br>            <span class="hljs-keyword">return</span> UserService.securityPassword(rawPassword.toString());<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> rawPassword 用户上传的密码</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> encodedPassword userDetailsService查询的密码</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> 决定是否匹配, 这里只要上传的密码进行加密后的结果等于查询出的密码，则说明匹配</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(CharSequence rawPassword, String encodedPassword)</span> &#123;<br>            <span class="hljs-keyword">return</span> encode(rawPassword).equals(encodedPassword);<br>        &#125;<br>    &#125;;<br><br><span class="hljs-comment">//发送json给response</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendOut</span><span class="hljs-params">(String str, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">if</span> (response != <span class="hljs-literal">null</span> &amp;&amp; !response.isCommitted()) &#123;<br>            response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getOutputStream()) &#123;<br>                out.write(str.getBytes(StandardCharsets.UTF_8));<br>                response.flushBuffer();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>springSecurity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jenkins git 报“Host key verification failed”错误处理</title>
    <link href="/4237278774.html"/>
    <url>/4237278774.html</url>
    
    <content type="html"><![CDATA[<h2 id="jenkins-git-报“Host-key-verification-failed”错误处理"><a href="#jenkins-git-报“Host-key-verification-failed”错误处理" class="headerlink" title="jenkins git 报“Host key verification failed”错误处理"></a>jenkins git 报“Host key verification failed”错误处理</h2><pre><code class="hljs">现象是手动cmd窗口中能正常使用git，能正常push到github，但jenkins中使用bat批处理就报此错误问题出现的原因是jenkins无法找到user/.ssh/下面的配置，解决方法有两个</code></pre><h3 id="方法一，让jenkins的服务以当前用户身份执行"><a href="#方法一，让jenkins的服务以当前用户身份执行" class="headerlink" title="方法一，让jenkins的服务以当前用户身份执行"></a>方法一，让jenkins的服务以当前用户身份执行</h3><ul><li>0.打开系统服务</li><li>1.找到jenkins的服务</li><li>2.停止服务</li><li>3.双击点击<code>登录</code>选项卡</li><li>4.输入用户名密码，这里要求windows用户设一个密码</li><li>5.保存，启动服务</li><li>6.jenkins 就会读取 用户目录下的.&#x2F;ssh&#x2F;known_hosts，发现问题解决</li></ul><h3 id="方法二-复制ssh文件，这样jenkins就能找到ssh密钥了"><a href="#方法二-复制ssh文件，这样jenkins就能找到ssh密钥了" class="headerlink" title="方法二 复制ssh文件，这样jenkins就能找到ssh密钥了"></a>方法二 复制ssh文件，这样jenkins就能找到ssh密钥了</h3><p>将<code>user\.ssh</code>里面的三个文件，复制到 <code>C:\Windows\System32\config\systemprofile\.ssh\</code>文件夹下。<br>分别是 id_rsa，id_rsa.pub，known_hosts</p><p>参考信息：</p><p><a href="https://stackoverflow.com/questions/41780145/setting-jenkins-git-returns-host-key-verification-failed-error">window配置</a></p><p><a href="https://stackoverflow.com/questions/15174194/jenkins-host-key-verification-failed">linux配置</a></p><p><a href="https://blog.csdn.net/cfh0081/article/details/78540674">原文链接</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jenkins 自动编译，发布，运行项目</title>
    <link href="/1995720483.html"/>
    <url>/1995720483.html</url>
    
    <content type="html"><![CDATA[<h2 id="jenkins-自动编译，发布项目"><a href="#jenkins-自动编译，发布项目" class="headerlink" title="jenkins 自动编译，发布项目"></a>jenkins 自动编译，发布项目</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><pre><code class="hljs">检测svn/git项目改动，如果改动则自动拉出源码，编译好，上传到服务器上，关闭服务器上运行的项目，并启动新编译的项目</code></pre><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><pre><code class="hljs">项目由svn或git管理这里以maven项目举例子有远程服务器或本地起虚拟机模拟都行，但要能shh链接上</code></pre><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="1-配置好jenkins-达到自动编译的效果"><a href="#1-配置好jenkins-达到自动编译的效果" class="headerlink" title="1.配置好jenkins 达到自动编译的效果"></a>1.配置好jenkins 达到自动编译的效果</h4><ul><li>   1.创建jenkins maven风格的项目</li><li>   2.源码管理选择subversive，填好url 密钥</li><li>   3.构建 poll SCM 填写 corn表达式，因为开发阶段更新比较频繁，这里没两分钟检测一次 H&#x2F;2 * * * * </li><li>   4.保存并构建一下</li></ul><h5 id="如果上面没配置错误的话，手动启动构建一下会从svn上拉出源码，并在【jenkins安装目录-workspace-项目文件名-】文件夹下进行编译，"><a href="#如果上面没配置错误的话，手动启动构建一下会从svn上拉出源码，并在【jenkins安装目录-workspace-项目文件名-】文件夹下进行编译，" class="headerlink" title="如果上面没配置错误的话，手动启动构建一下会从svn上拉出源码，并在【jenkins安装目录\workspace\项目文件名\】文件夹下进行编译，"></a>如果上面没配置错误的话，手动启动构建一下会从svn上拉出源码，并在【jenkins安装目录\workspace\项目文件名\】文件夹下进行编译，</h5><h5 id="java项目的话会target目录下生成jar-war包"><a href="#java项目的话会target目录下生成jar-war包" class="headerlink" title="java项目的话会target目录下生成jar&#x2F;war包"></a>java项目的话会target目录下生成jar&#x2F;war包</h5><h4 id="2-继续配置jenkins"><a href="#2-继续配置jenkins" class="headerlink" title="2.继续配置jenkins"></a>2.继续配置jenkins</h4><ul><li><p>1.转到post Steps 选择 ‘send files or execute commands over SSH’ 前提装好jenkins的ssh插件并配置好，选择<code>Run only if build succeeds </code>这样只有编译成功了才执行上传操作</p></li><li><p>2.选择好服务器</p></li><li><p>3.Source files 填写【target&#x2F;sc-pro-1.0.jar】路径是相对于【jenkins安装目录\workspace\项目文件名\】来处理的，sc-pro-1.0.jar按照实际的来</p></li><li><p>4.Remove prefix 即移除路径前缀，就是上面填写的字符串，我们只保留文件名，将前面的字符串都去除这里填写【target&#x2F;】</p></li><li><p>5.Remote directory 远程文件夹的路径这里我填写【&#x2F;home&#x2F;suu&#x2F;sprintboot8585&#x2F;temp】这样就把第一次填写的文件路径，去除第二部填写的前缀，通过ssh传输到【&#x2F;home&#x2F;suu&#x2F;sprintboot8585&#x2F;temp&#x2F;sc-pro-1.0.jar】，如果上一步的targer&#x2F;不填写就会在服务器上的temp文件夹下创建目录结构【&#x2F;home&#x2F;suu&#x2F;sprintboot8585&#x2F;temp&#x2F;target&#x2F;sc-pro-1.0.jar】</p></li><li><p>6.Exec command 这里填写执行的linux命令，我们事先写好sh脚本放在服务器上，这里启动脚本，我填写【source  &#x2F;home&#x2F;suu&#x2F;sprintboot8585&#x2F;temp&#x2F;display_sc-pro.sh】</p></li></ul><h4 id="3-服务器脚本编写，脚本逻辑"><a href="#3-服务器脚本编写，脚本逻辑" class="headerlink" title="3.服务器脚本编写，脚本逻辑"></a>3.服务器脚本编写，脚本逻辑</h4><ul><li>1.找到项目任务pid</li><li>2.kill掉项目</li><li>3.将项目从上传的temp文件夹下移动到真正执行的目录下</li><li>4.启动新项目</li></ul><h4 id="我的springboot项目是这样编写的"><a href="#我的springboot项目是这样编写的" class="headerlink" title="我的springboot项目是这样编写的"></a>我的springboot项目是这样编写的</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br>fileName=<span class="hljs-string">&quot;sc-pro-1.0.jar&quot;</span><br>outPath=<span class="hljs-string">&quot;/home/suu/sprintboot8585/temp&quot;</span><br>runPath=<span class="hljs-string">&quot;/home/suu/sprintboot8585/springboot&quot;</span><br><br><span class="hljs-comment"># check</span><br><span class="hljs-function"><span class="hljs-title">check</span></span>()&#123;<br><span class="hljs-keyword">if</span> [ $? -eq 0 ];<span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;success <span class="hljs-variable">$1</span>&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;fail <span class="hljs-variable">$1</span>&quot;</span><br><span class="hljs-built_in">exit</span><br><span class="hljs-keyword">fi</span><br>&#125;<br><br><span class="hljs-comment">#kill pid</span><br><span class="hljs-function"><span class="hljs-title">killPid</span></span>()&#123;<br><span class="hljs-built_in">kill</span> -9 <span class="hljs-variable">$1</span><br>check <span class="hljs-string">&quot;kill <span class="hljs-variable">$fileName</span>&quot;</span><br>&#125;<br><br><span class="hljs-comment"># start new </span><br><span class="hljs-comment"># 将jar包覆盖移动到执行目录下</span><br><span class="hljs-comment"># 调用nohup命令执行新的程序</span><br><span class="hljs-function"><span class="hljs-title">startNew</span></span>()&#123;<br><span class="hljs-built_in">mv</span> -f <span class="hljs-variable">$outPath</span>/<span class="hljs-variable">$fileName</span> <span class="hljs-variable">$runPath</span>/<span class="hljs-variable">$fileName</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$runPath</span><br><span class="hljs-built_in">nohup</span> java -jar <span class="hljs-variable">$fileName</span>  &gt; <span class="hljs-variable">$runPath</span>/nohup.out &amp;<br>&#125;<br><br><span class="hljs-comment"># checkFile 检查新jar包是否存在</span><br><span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&quot;<span class="hljs-variable">$fileName</span>&quot;</span> ];<span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;file <span class="hljs-variable">$fileName</span> not found&quot;</span><br><span class="hljs-built_in">exit</span><br><span class="hljs-keyword">fi</span><br><br><br><span class="hljs-comment">#fid pid，，找到就程序的pid</span><br>n1=`ps -ef |grep <span class="hljs-variable">$fileName</span> |grep -v grep |awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>`<br>check  <span class="hljs-string">&quot;find PID&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;find PID:<span class="hljs-variable">$n1</span>&quot;</span><br><br><br><span class="hljs-comment">#kill pid if pid exeit,强制结束旧程序</span><br><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$n1</span>&quot;</span> ];<span class="hljs-keyword">then</span><br>killPid <span class="hljs-string">&quot;<span class="hljs-variable">$n1</span>&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;not find pid&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 调用启动函数</span><br>startNew<br></code></pre></td></tr></table></figure><p>####4.回到jenkins，手动发布一下，观察console输出信息，能正确获取源码，编译，测试，上传，杀死程序，启动程序</p>]]></content>
    
    
    
    <tags>
      
      <tag>jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jenkins自动构建项目并发布到maven私服</title>
    <link href="/1595091183.html"/>
    <url>/1595091183.html</url>
    
    <content type="html"><![CDATA[<h3 id="jenkins自动构建项目并发布到maven私服"><a href="#jenkins自动构建项目并发布到maven私服" class="headerlink" title="jenkins自动构建项目并发布到maven私服"></a>jenkins自动构建项目并发布到maven私服</h3><h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h4><pre><code class="hljs">安装好jenkins项目maven能正常手动发布项目源码从svn或者git管理</code></pre><h4 id="达到的目的"><a href="#达到的目的" class="headerlink" title="达到的目的"></a>达到的目的</h4><pre><code class="hljs">jenkins会轮询svn项目的更改，如果发现项目更改了，则重新编译，并发布到maven私服上</code></pre><h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h4><pre><code class="hljs">1.打开jenkins网页，添加自由风格的项目，名字任意如【project1】2.配置General2.1 配置Discard old builds指定保存的记录天数和最大构建个数，自动删除前面的构建，防止占用太多存储空间3.源码管理我选择subversion，填写url选择密码凭据3.1这样每次执行任务时，会将svn的源码下载到该文件夹下，没有该文件夹会自动创建4.构建触发器选择Poll SCM，定时轮询svn服务器4.1其中corn表达式和平时用的稍有不同,点击输入框后面的问号有说明，我这里写 H * * * * 即每分钟检查一次，因为开发阶段更新比较频繁5.构建步骤选择`Execute windows batch command`即执行window批处理脚本，因为jenkins我是在本机windows上安装的5.1使用jenkins调用我们的bat脚本，来进行项目编译发布5.2如果我们配置123.bat，默认会调用【jenkins安装目录\workspace\project1\123.bat】，也可以写死绝对路经如【c:123.bat】这样也可以找到5.3我将脚本放置在【jenkins安装目录\workspace\autoPublish.bat】所以我配置路径时写的是【../autoPublish.bat】这样就能找到我的脚本了5.3脚本执行环境的目录为【jenkind安装目录\workspace\project\】6.bat文件中我们可以这样写 ::=========================@echo offmvn deploy::=========================7.这里面写的就是普通maven命令，他会自动将项目进行编译，测试，发布到私服，前提条件是已经配置好pom，能手动完成</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot 添加defaultServlet实现更好的文件下载功能</title>
    <link href="/2261257528.html"/>
    <url>/2261257528.html</url>
    
    <content type="html"><![CDATA[<h1 id="Springboot-添加DefaultServlet实现更好的文件下载功能"><a href="#Springboot-添加DefaultServlet实现更好的文件下载功能" class="headerlink" title="Springboot 添加DefaultServlet实现更好的文件下载功能"></a>Springboot 添加DefaultServlet实现更好的文件下载功能</h1><p>​        <code>defaultServlet</code>是<code>tomcat</code>为我们提供的能下载或打开<code>tomcat</code>项目文件夹下的静态文件的<code>servlet</code>，他的<code>url-pattern</code>是 <code>/</code>。<br>​        但如果使用<code>springboot</code>，会自动注册<code>dispatchServlet</code>到容器中<code>url-pattern</code>也是 <code>/</code>会把<code>defaultServlet</code>给覆盖掉。</p><h2 id="实现目的"><a href="#实现目的" class="headerlink" title="实现目的"></a>实现目的</h2><ul><li>实现文件下载和文件打开功能</li><li>文件存储目录在 <code>D:/files/</code>文件夹下</li><li>如果访问 <code>localhost/download/xxx.jpg</code>则到该<code>d:/files/</code>下查找<code>xxx.jpg</code>下载</li><li>如果访问<code>localhost/download/aa/bb/cc/xxx.jpg</code> 则到<code>d:/files/aa/bb/cc/</code>下查找</li><li>如果访问<code>localhost/static/xxx.jpg</code> 则在<code>d:/files/xxx.jpg</code>在浏览器<code>打开而不是下载</code></li></ul><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>​        我们继承一个<code>DefaultServlet</code>并在<code>init</code>方法里面将文件存储的目录配置进去。然后将这个<code>Servlet</code>添加到<code>Tomcat</code>里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletConfig</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*配置DownloadServlet，拦截/static/* 和 /download/*的请求，且程序启动后就初始化而不是等第一次访问才初始化</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title function_">servletRegistrationBean</span><span class="hljs-params">()</span> &#123;<br>        ServletRegistrationBean&lt;Servlet&gt; register = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletRegistrationBean</span>&lt;&gt;();<br>        <span class="hljs-type">DefaultServlet</span> <span class="hljs-variable">defaultServlet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DownloadServlet</span>();<br>        register.setServlet(defaultServlet);<br>        register.addUrlMappings(<span class="hljs-string">&quot;/static/*&quot;</span>, <span class="hljs-string">&quot;/download/*&quot;</span>);<br>        register.setLoadOnStartup(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> register;<br>    &#125;<br><br><span class="hljs-comment">//继承defaultServlet</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DownloadServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DefaultServlet</span> &#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1537326382082402617L</span>;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         *  String amount = &quot;/download&quot;;  //从文件path中移除此路径,前置路径 如访问路径是 localhost/download/123.jpg,则真实查找路径是&#x27;/123.jpg&#x27;（即移除&#x27;/download&#x27;)</span><br><span class="hljs-comment">         *  String basePath = &quot;d:/files&quot;; //文件存储所在的文件夹绝对路径,末尾不要以‘/’结尾</span><br><span class="hljs-comment">         *  String internalPath = &quot;/&quot;; // 不知道有什么用，DirResourceSet应该没用到</span><br><span class="hljs-comment">         *  DefaultServlet使用若干个ResourceSet进行读取资源，默认读取tomcat项目根目录下的文件，我们自己在设置两个，分别处理/static的和/download的请求</span><br><span class="hljs-comment">         * */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>            <span class="hljs-type">WebResourceRoot</span> <span class="hljs-variable">attribute</span> <span class="hljs-operator">=</span> (WebResourceRoot) getServletContext().getAttribute(Globals.RESOURCES_ATTR);<br><br>            attribute.addPreResources(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DirResourceSet</span>(attribute, <span class="hljs-string">&quot;/static&quot;</span>, <span class="hljs-string">&quot;d:/files&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>));<br>            attribute.addPreResources(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DirResourceSet</span>(attribute, <span class="hljs-string">&quot;/download&quot;</span>, <span class="hljs-string">&quot;d:/files&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>));<br>            <span class="hljs-built_in">super</span>.init();<br>        &#125;<br><br><span class="hljs-comment">//如果是/download开头的请求，则设置ContentType为流，否则servlet会自行推理，如图片就会直接打开而不是下载</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>            <span class="hljs-keyword">if</span> (req.getRequestURI().startsWith(<span class="hljs-string">&quot;/download&quot;</span>)) &#123;<br>                resp.setContentType(<span class="hljs-string">&quot;application/octet-stream&quot;</span>);<br>            &#125;<br>            <span class="hljs-built_in">super</span>.service(req, resp);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>​    这里重写service方法的目的是 如果发现<code>/download</code>开头的请求，要设置响应头为<code>application/octet-stream</code>，这样浏览器就能下载该文件，而不是展示该文件。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>​        以上就是在<code>SpringMvc</code>环境下，处理静态资源展示和下载的实现方式。</p>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>defaultServlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot 启动报log4j错误</title>
    <link href="/602288951.html"/>
    <url>/602288951.html</url>
    
    <content type="html"><![CDATA[<h2 id="springboot-启动报-ERROR-StatusLogger-Log4j2-could-not-find-a-logging-implementation-Please-add-log4j-core-to-the-classpath-Using-SimpleLogger-to-log-to-the-console"><a href="#springboot-启动报-ERROR-StatusLogger-Log4j2-could-not-find-a-logging-implementation-Please-add-log4j-core-to-the-classpath-Using-SimpleLogger-to-log-to-the-console" class="headerlink" title="springboot 启动报 ERROR StatusLogger Log4j2 could not find a logging implementation. Please add log4j-core to the classpath. Using SimpleLogger to log to the console"></a>springboot 启动报 <code>ERROR StatusLogger Log4j2 could not find a logging implementation. Please add log4j-core to the classpath. Using SimpleLogger to log to the console</code></h2><p>报错信息看起来与log4j有关，项目没打算用log4j，也没有主动引入log4j的，困扰了好久，以下是解决思路</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">springboot</span>版本<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><hr><ol><li><p>查看maven 发现log4j-api包被 springboot-starter下的springboot-starter-loggering引入的。</p></li><li><p>用idea ctrl+shift+f搜索报错信息，找到了报错日志点为 <code>org.apache.logging.log4j.LogManager</code>的静态代码块中，由于if语句<code>if (ProviderUtil.hasProviders())</code>判断为false，进入else语句打印出此log，猜测某个地方反射加载此类</p></li><li><p>查看堆栈信息，找到<code>org.jboss.logging.LoggerProviders#findProvider</code>发现代码如下</p></li></ol><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">tryJBossLogManager</span><span class="hljs-params">(cl, <span class="hljs-keyword">null</span>)</span></span>;<br>&#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br><br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">tryLog4j2</span><span class="hljs-params">(cl, <span class="hljs-keyword">null</span>)</span></span>;<br>&#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br><br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">tryLog4j</span><span class="hljs-params">(cl, <span class="hljs-keyword">null</span>)</span></span>;<br>&#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br><br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    Class.forName(<span class="hljs-string">&quot;ch.qos.logback.classic.Logger&quot;</span>, <span class="hljs-keyword">false</span>, cl);<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">trySlf4j</span><span class="hljs-params">(<span class="hljs-keyword">null</span>)</span></span>;<br>&#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">tryJDK</span><span class="hljs-params">(<span class="hljs-keyword">null</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>####代码去依次尝试获取jboss的log， log4j2， log4j， slf4j， jdklog来处理log.</p><h4 id="通过反射来加载org-apache-logging-log4j-LogManager时执行的上面静态代码块。"><a href="#通过反射来加载org-apache-logging-log4j-LogManager时执行的上面静态代码块。" class="headerlink" title="通过反射来加载org.apache.logging.log4j.LogManager时执行的上面静态代码块。"></a>通过反射来加载<code>org.apache.logging.log4j.LogManager</code>时执行的上面静态代码块。</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LoggerProvider tryLog4j2(<span class="hljs-keyword">final</span> ClassLoader cl, <span class="hljs-keyword">final</span> String via) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-keyword">Class</span>.forName(<span class="hljs-string">&quot;org.apache.logging.log4j.Logger&quot;</span>, <span class="hljs-keyword">true</span>, cl);<br>    <span class="hljs-keyword">Class</span>.forName(<span class="hljs-string">&quot;org.apache.logging.log4j.LogManager&quot;</span>, <span class="hljs-keyword">true</span>, cl);<br>    <span class="hljs-keyword">Class</span>.forName(<span class="hljs-string">&quot;org.apache.logging.log4j.spi.AbstractLogger&quot;</span>, <span class="hljs-keyword">true</span>, cl);<br>    LoggerProvider provider = <span class="hljs-keyword">new</span> Log4j2LoggerProvider();<br>    logProvider(provider, via);<br>    <span class="hljs-keyword">return</span> provider;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="查看报错点的if判断if-ProviderUtil-hasProviders-里面的代码如下"><a href="#查看报错点的if判断if-ProviderUtil-hasProviders-里面的代码如下" class="headerlink" title="查看报错点的if判断if (ProviderUtil.hasProviders())里面的代码如下"></a>查看报错点的if判断<code>if (ProviderUtil.hasProviders())</code>里面的代码如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PROVIDER_RESOURCE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;META-INF/log4j-provider.properties&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasProviders</span><span class="hljs-params">()</span> &#123;<br>        lazyInit();<br>        <span class="hljs-keyword">return</span> !PROVIDERS.isEmpty();<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lazyInit</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// noinspection DoubleCheckedLocking</span><br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            STARTUP_LOCK.lockInterruptibly();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProviderUtil</span>();<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                STARTUP_LOCK.unlock();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> InterruptedException e) &#123;<br>            LOGGER.fatal(<span class="hljs-string">&quot;Interrupted before Log4j Providers could be loaded.&quot;</span>, e);<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br>&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ProviderUtil</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> LoaderUtil.UrlResource resource : LoaderUtil.findUrlResources(PROVIDER_RESOURCE)) &#123;<br>            loadProvider(resource.getUrl(), resource.getClassLoader());<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>调用了ProviderUtil的构造方法，其中尝试获取配置文件<code>META-INF/log4j-provider.properties</code>但是获取为空<br>这样<code>PROVIDERS</code>这个list的值就为空，从而<code>hasProviders</code>方法返回false。</p><h3 id="但是我的另一个项目启动时却不会打印出这样的错误log信息，按照上面的思路观察源码，发现另一个项目引入的是log4j-api-2-11-1-而报错的项目引入的是log4j-api-2-8-1，其中"><a href="#但是我的另一个项目启动时却不会打印出这样的错误log信息，按照上面的思路观察源码，发现另一个项目引入的是log4j-api-2-11-1-而报错的项目引入的是log4j-api-2-8-1，其中" class="headerlink" title="但是我的另一个项目启动时却不会打印出这样的错误log信息，按照上面的思路观察源码，发现另一个项目引入的是log4j-api 2.11.1 而报错的项目引入的是log4j-api 2.8.1，其中"></a>但是我的另一个项目启动时却不会打印出这样的错误log信息，按照上面的思路观察源码，发现另一个项目引入的是<code>log4j-api 2.11.1</code> 而报错的项目引入的是<code>log4j-api 2.8.1</code>，其中</h3><h3 id="2-11-1的ProviderUtil构造方法变成了这样"><a href="#2-11-1的ProviderUtil构造方法变成了这样" class="headerlink" title="2.11.1的ProviderUtil构造方法变成了这样"></a>2.11.1的ProviderUtil构造方法变成了这样</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">private <span class="hljs-built_in">ProviderUtil</span>() &#123;<br>    for (final ClassLoader classLoader : LoaderUtil.getClassLoaders()) &#123;<br>        try &#123;<br>            <span class="hljs-built_in">loadProviders</span>(classLoader);<br>        &#125; catch (final Throwable ex) &#123;<br>            LOGGER<span class="hljs-selector-class">.debug</span>(&quot;Unable to retrieve provider from ClassLoader &#123;&#125;&quot;, classLoader, ex);<br>        &#125;<br>    &#125;<br>    for (final LoaderUtil.UrlResource resource : LoaderUtil.findUrlResources(PROVIDER_RESOURCE)) &#123;<br>        <span class="hljs-built_in">loadProvider</span>(resource.getUrl(), resource<span class="hljs-selector-class">.getClassLoader</span>());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="更高版本的log4j-api中适应多个classLoad尝试加载providers，在这里成功的找到了一个，随意if没有报错"><a href="#更高版本的log4j-api中适应多个classLoad尝试加载providers，在这里成功的找到了一个，随意if没有报错" class="headerlink" title="更高版本的log4j-api中适应多个classLoad尝试加载providers，在这里成功的找到了一个，随意if没有报错"></a>更高版本的log4j-api中适应多个classLoad尝试加载providers，在这里成功的找到了一个，随意if没有报错</h3><h2 id="观察maven的配置中并没有引入log4j的包，然后查看父项目的maven配置"><a href="#观察maven的配置中并没有引入log4j的包，然后查看父项目的maven配置" class="headerlink" title="观察maven的配置中并没有引入log4j的包，然后查看父项目的maven配置"></a>观察maven的配置中并没有引入log4j的包，然后查看父项目的maven配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>#根据maven的依赖加载原理，依赖关系近的会覆盖远的，所以父项目的依赖覆盖了springboot-start中的依赖，导致版本不一致。<br>#删除父项目中引入的依赖即可，问题原因找到</p>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot 添加自定义过滤器，servlet,监听器,拦截器</title>
    <link href="/1155163571.html"/>
    <url>/1155163571.html</url>
    
    <content type="html"><![CDATA[<h2 id="springboot-添加自定义过滤器，servlet-监听器-拦截器"><a href="#springboot-添加自定义过滤器，servlet-监听器-拦截器" class="headerlink" title="springboot 添加自定义过滤器，servlet,监听器,拦截器"></a>springboot 添加自定义过滤器，servlet,监听器,拦截器</h2><h3 id="开发阶段需要添加一个过滤器来做一些log，方便调试，如打印方法执行时间，方法参数等信息"><a href="#开发阶段需要添加一个过滤器来做一些log，方便调试，如打印方法执行时间，方法参数等信息" class="headerlink" title="开发阶段需要添加一个过滤器来做一些log，方便调试，如打印方法执行时间，方法参数等信息"></a>开发阶段需要添加一个过滤器来做一些log，方便调试，如打印方法执行时间，方法参数等信息</h3><h2 id="1-添加过滤器"><a href="#1-添加过滤器" class="headerlink" title="1.添加过滤器"></a>1.添加过滤器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterConfig</span> &#123;<br><br><span class="hljs-comment">//配置filter，默认filter的顺序是最后执行的，可以修改，这里不进行修改</span><br><span class="hljs-comment">//springboot 默认会添加一些编码相关的filter在最前面，如果该顺序不要改太小，OrderedCharacterEncodingFilter的顺序是 `Ordered.HIGHEST_PRECEDENCE`</span><br><span class="hljs-comment">//这里使用默认顺序</span><br><span class="hljs-comment">//注意UrlPatterns不是ant路径模式，不要写成了 `/**`否则不生效</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title function_">filterRegistrationBean</span><span class="hljs-params">()</span> &#123;<br>        FilterRegistrationBean&lt;Filter&gt; register = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterRegistrationBean</span>&lt;&gt;();<br>        register.setFilter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeFilter</span>());<br>        register.addUrlPatterns(<span class="hljs-string">&quot;/*&quot;</span>);<br>        <span class="hljs-keyword">return</span> register;<br>    &#125;<br><br><br><span class="hljs-comment">//过滤器器打印请求路径和参数，方法执行完成统计执行毫秒值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(TimeFilter.class);<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>            <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> (HttpServletRequest) request;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            log.info(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, req.getServletPath(), JSONObject.toJSONString(request.getParameterMap()));<br>            chain.doFilter(request, response);<br>            log.info(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;ms&quot;</span>, req.getServletPath(), System.currentTimeMillis() - start);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="！！同理-相同的办法可以添加自定义servlet-listener等，分别构造出一个-ServletRegistrationBean-FilterRegistrationBean-ServletListenerRegistrationBean"><a href="#！！同理-相同的办法可以添加自定义servlet-listener等，分别构造出一个-ServletRegistrationBean-FilterRegistrationBean-ServletListenerRegistrationBean" class="headerlink" title="！！同理 相同的办法可以添加自定义servlet listener等，分别构造出一个 ServletRegistrationBean , FilterRegistrationBean,ServletListenerRegistrationBean"></a>！！同理 相同的办法可以添加自定义servlet listener等，分别构造出一个 <code>ServletRegistrationBean</code> , <code>FilterRegistrationBean</code>,<code>ServletListenerRegistrationBean</code></h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="2-添加拦截器"><a href="#2-添加拦截器" class="headerlink" title="2.添加拦截器"></a>2.添加拦截器</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//继承WebMvcConfigurationSupport</span><br><span class="hljs-meta">@Configuration</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;<br><br>    <span class="hljs-comment">//重写此方法</span><br>    <span class="hljs-comment">//注意此处的路径格式是ant模式</span><br>       <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void addInterceptors(<span class="hljs-type">InterceptorRegistry</span> reg) &#123;<br>        reg.addInterceptor(<span class="hljs-keyword">new</span> loginInterceptor())<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">loginInterceptor</span> <span class="hljs-title">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        public boolean preHandle(<span class="hljs-type">HttpServletRequest</span> request, <span class="hljs-type">HttpServletResponse</span> response, <span class="hljs-type">Object</span> handler) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>            <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;请求经过拦截器&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven 的resources标签使用</title>
    <link href="/3232883387.html"/>
    <url>/3232883387.html</url>
    
    <content type="html"><![CDATA[<h1 id="maven-的resources标签使用"><a href="#maven-的resources标签使用" class="headerlink" title="maven 的resources标签使用"></a>maven 的resources标签使用</h1><ul><li>TOC<br>{:toc}</li></ul><h2 id="默认情况下的maven资源配置"><a href="#默认情况下的maven资源配置" class="headerlink" title="默认情况下的maven资源配置"></a>默认情况下的maven资源配置</h2><p>​        此标签用来控制资源的拷贝，maven对资源的控制是使用<code>maven-resources</code>插件完成的。</p><p>使用<code>mvn help:effective-pom</code>查看实际使用的配置。<code>resources插件</code>默认会执行<code>testResources</code> 和 <code>resources</code> 两个goal</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>default-testResources<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>process-test-resources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>testResources<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>default-resources<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>process-resources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>resources<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​        resources插件默认执行上面两个goal，这两个步骤分别对测试资源和正式资源进行拷贝。</p><p>从哪里拷贝到哪里是由<code>resources</code>标签决定。默认<code>resources</code>标签是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>&gt;</span>C:/ijtest/testmaven/target/classes<span class="hljs-tag">&lt;/<span class="hljs-name">outputDirectory</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">testOutputDirectory</span>&gt;</span>C:/ijtest/testmaven/target/test-classes<span class="hljs-tag">&lt;/<span class="hljs-name">testOutputDirectory</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>C:/ijtest/testmaven/src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">testResources</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">testResource</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>C:/ijtest/testmaven/src/test/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">testResource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">testResources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​        可以看到默认目标分别是<code>src/main/resources</code> 和 <code>src/test/resources</code> ， 而输出目标分别是<code>target/classes</code> 和<code>target/test-classes</code>。</p><p>也可以使用变量代替：<br><code>$&#123;project.build.outputDirectory&#125;</code> 表示默认的输出目录，即target目录。<br><code>$&#123;project.basedir&#125;</code> 表示项目目录，即pom文件所在的目录（会与target同级）</p><h2 id="定制Resources标签"><a href="#定制Resources标签" class="headerlink" title="定制Resources标签"></a>定制Resources标签</h2><p>​    我们自定义<code>resources</code>标签可以覆盖超级pom的默认配置。下面只讲解<code>resources</code>标签，<code>testResources</code>标签是同理的。</p><p> <em><strong>这个标签写在<code>build</code>标签下，用来配置resources插件工作</strong></em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span>abc<span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application.*<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><h3 id="directory"><a href="#directory" class="headerlink" title="directory"></a>directory</h3><p>  ​        表示原资源路径，请填写相对路径，相对于pom所在的目录，即如果<code>pom.xml</code>在<code>d:project</code>文件夹下，默认的相对路径为<code>d:project/</code>  ，拼在一起就变成<code>d:project/src/main/resources</code>，所以这里填写路径不要以 <code>/</code>开头，否则会变成绝对路径。这个选项是必填的。</p><p>  ​    </p></li><li><h3 id="targetPath"><a href="#targetPath" class="headerlink" title="targetPath"></a>targetPath</h3><p>​         资源拷贝的目标地址，这个路径是选填的。默认输出路径为<code>target/classes/</code>，如此处填写<code>abc</code>，</p><p>则会将<code>src/main/resources</code>下的文件拷贝到<code>target/classes/abc</code>文件夹下。不写就是拷贝到<code>target/classes/</code>。</p></li><li><h3 id="includes-和-excludes"><a href="#includes-和-excludes" class="headerlink" title="includes 和 excludes"></a>includes 和 excludes</h3><p> maven默认会将<code>directory</code>下的文件全部拷贝到<code>targetPath</code>下，但是受这两个属性控制。</p><ul><li><p><strong>如果存在 <code>includes</code> 则只将<code>includes</code>指定的文件拷贝，其余不拷贝。</strong></p></li><li><p><strong>如果在<code>excludes</code> 则将排除掉指定文件外的剩余文件拷贝。</strong></p></li><li><p><strong>如果同时存在，则按照先后顺序过滤。</strong></p><blockquote><p>例如先存在<code>includes</code>，后存在<code>excludes</code>，则先使用<code>includes</code>筛选出满足条件的文件，再使用    <code>excludes</code>对上面筛选出来的文件进行二次筛选。</p></blockquote></li><li><p><strong>如果同时存在，且同时操作同一个文件，则以excludes为准。</strong></p><blockquote><p>因为无论excludes在前还是在后，都会将文件过滤掉，所以同一个文件来说一定会被过滤掉。</p></blockquote></li><li><p><strong>上面的四个规则是对于同一个<code>resource</code>标签内的<code>includes、excludes</code>来讲的，不是同一个<code>resource</code>标签互相不影响。</strong></p><blockquote><p>例如下面的例子使用一个<code>resource</code>过滤掉所有的<code>application*.properties</code>，</p><p>再使用另一个<code>resource</code>添加进来。</p></blockquote></li></ul><hr><p> ​    有时使用单个<code>resource</code>标签可能无法完成想要的行为，可以多个<code>resource</code>组合使用如</p><p> 想要<code>resources</code>文件夹下的<code>application*.properties</code>文件，根据配置选择打包哪个，可以这样写。</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>    //这个resource排除掉所有application*.properties<br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>application*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    //这个resource添加了application.properties 和 application-$&#123;profile.active&#125;.properties<br>    <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>application-$&#123;profile.active&#125;.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><h3 id="filtering"><a href="#filtering" class="headerlink" title="filtering"></a>filtering</h3><p> ​    这个选项可以是true或 false，表示是否对资源进行过滤，也就是说，可以在配置文件里写一些动态的值，maven会将值替换成真正的值，设成false则不会过滤。</p><p> 比如下面<code>properties</code>文件中的一条记录，maven编译完成后值会被替换成<code>profile.active</code>这个变量代表的值。</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.profiles.active</span>= <span class="hljs-string">@profile.active@</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        需要注意的一点是，如果在自己的pom里配置的resource标签，超级父pom里的resource就会失效了，比如下面这样配置后，只会拷贝<code>src/main/myImage</code>里的内容，默认的<code>src/main/resources</code>内的内容就不会被拷贝了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/myImage<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​        </p><p>​        可以再添加一个，两个<code>resource</code>共同配置即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/myImage<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty buttyBuf的三种复制方式</title>
    <link href="/2246394244.html"/>
    <url>/2246394244.html</url>
    
    <content type="html"><![CDATA[<h1 id="netty-buttyBuf的三种复制方式"><a href="#netty-buttyBuf的三种复制方式" class="headerlink" title="netty buttyBuf的三种复制方式"></a>netty buttyBuf的三种复制方式</h1><h4 id="copy-物理复制，复制数据构成新buf，且与原buf无关，大小等于数据长度"><a href="#copy-物理复制，复制数据构成新buf，且与原buf无关，大小等于数据长度" class="headerlink" title="copy     物理复制，复制数据构成新buf，且与原buf无关，大小等于数据长度"></a>copy     物理复制，复制数据构成新buf，且与原buf无关，大小等于数据长度</h4><h4 id="duplicate-逻辑复制，复制原buf的索引构成新buf，和原数据一模一样"><a href="#duplicate-逻辑复制，复制原buf的索引构成新buf，和原数据一模一样" class="headerlink" title="duplicate 逻辑复制，复制原buf的索引构成新buf，和原数据一模一样"></a>duplicate 逻辑复制，复制原buf的索引构成新buf，和原数据一模一样</h4><h4 id="slice-切片，获取原buf指定范围的映射，大小等于切片的数据长度"><a href="#slice-切片，获取原buf指定范围的映射，大小等于切片的数据长度" class="headerlink" title="slice  切片，获取原buf指定范围的映射，大小等于切片的数据长度"></a>slice  切片，获取原buf指定范围的映射，大小等于切片的数据长度</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs nix">@Test<br>public void test2() &#123;<br>ByteBuf b <span class="hljs-operator">=</span> getBuf();<br>System.out.println(<span class="hljs-string">&quot;原始数据:&quot;</span> <span class="hljs-operator">+</span> b);<br><span class="hljs-operator">//</span>原始数据:UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf(<span class="hljs-params">ridx:</span> <span class="hljs-number">4</span>, <span class="hljs-params">widx:</span> <span class="hljs-number">12</span>, <span class="hljs-params">cap:</span> <span class="hljs-number">1024</span>)<br><br><br><span class="hljs-attr">b</span> <span class="hljs-operator">=</span> getBuf();<br>System.out.println(<span class="hljs-string">&quot;copy:&quot;</span> <span class="hljs-operator">+</span> b.copy());<br><span class="hljs-operator">//</span>copy:UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf(<span class="hljs-params">ridx:</span> <span class="hljs-number">0</span>, <span class="hljs-params">widx:</span> <span class="hljs-number">8</span>, <span class="hljs-params">cap:</span> <span class="hljs-number">8</span>)<br><br><br><span class="hljs-attr">b</span> <span class="hljs-operator">=</span> getBuf();<br>System.out.println(<span class="hljs-string">&quot;duplicate：&quot;</span> <span class="hljs-operator">+</span> b.duplicate());<br><span class="hljs-operator">//</span>duplicate：UnpooledDuplicatedByteBuf(<span class="hljs-params">ridx:</span> <span class="hljs-number">4</span>, <span class="hljs-params">widx:</span> <span class="hljs-number">12</span>, <span class="hljs-params">cap:</span> <span class="hljs-number">1024</span>, <span class="hljs-params">unwrapped:</span> UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf(<span class="hljs-params">ridx:</span> <span class="hljs-number">4</span>, <span class="hljs-params">widx:</span> <span class="hljs-number">12</span>, <span class="hljs-params">cap:</span> <span class="hljs-number">1024</span>))<br><br><br><span class="hljs-attr">b</span> <span class="hljs-operator">=</span> getBuf();<br>System.out.println(<span class="hljs-string">&quot;slice;&quot;</span> <span class="hljs-operator">+</span> b.slice());<br><span class="hljs-symbol">//slice</span>;UnpooledSlicedByteBuf(<span class="hljs-params">ridx:</span> <span class="hljs-number">0</span>, <span class="hljs-params">widx:</span> <span class="hljs-number">8</span>, <span class="hljs-params">cap:</span> <span class="hljs-number">8</span><span class="hljs-operator">/</span><span class="hljs-number">8</span>, <span class="hljs-params">unwrapped:</span> UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf(<span class="hljs-params">ridx:</span> <span class="hljs-number">4</span>, <span class="hljs-params">widx:</span> <span class="hljs-number">12</span>, <span class="hljs-params">cap:</span> <span class="hljs-number">1024</span>))<br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs abnf">//返回一个总长度为<span class="hljs-number">1024</span>，数据长度为<span class="hljs-number">12</span>，读索引为<span class="hljs-number">4</span>，写索引为<span class="hljs-number">12</span>的bytebuf<br>public static ByteBuf getBuf() &#123;<br>ByteBuf b <span class="hljs-operator">=</span> Unpooled.buffer(<span class="hljs-number">1024</span>)<span class="hljs-comment">;</span><br>b.writeInt(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>b.writeInt(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br>b.writeInt(<span class="hljs-number">3</span>)<span class="hljs-comment">;</span><br>b.readInt()<span class="hljs-comment">;</span><br>return b<span class="hljs-comment">;</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>追踪一下slf4j的工作原理</title>
    <link href="/4227925025.html"/>
    <url>/4227925025.html</url>
    
    <content type="html"><![CDATA[<ul><li>TOC<br>{:toc}</li></ul><h1 id="追踪一下slf4j的工作原理"><a href="#追踪一下slf4j的工作原理" class="headerlink" title="追踪一下slf4j的工作原理"></a>追踪一下slf4j的工作原理</h1><p><code>slf4j</code> 是一个<code>java</code>界非常流行的日志门面框架，使用它，你可以任意更换底层实现，如<code>logback</code>、<code>log4j</code>，而不需要修改代码。那他是如何做到的。</p><h2 id="引入slf4j的包"><a href="#引入slf4j的包" class="headerlink" title="引入slf4j的包"></a>引入<code>slf4j</code>的包</h2><p>​这里采用最新稳定版,因为只引入<code>slf4j</code>无法打印日志，这里选择<code>logback</code>作为底层实现。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="测试输出"><a href="#测试输出" class="headerlink" title="测试输出"></a>测试输出</h2><p>​从<code>LoggerFactory</code>获取一个<code>Logger</code>对象，就能使用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(T1.class);<br>log.info(<span class="hljs-string">&quot;info&quot;</span>);<br>log.debug(<span class="hljs-string">&quot;debug&quot;</span>);<br>log.warn(<span class="hljs-string">&quot;warn&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><h3 id="委托给ILoggerFactory"><a href="#委托给ILoggerFactory" class="headerlink" title="委托给ILoggerFactory"></a>委托给ILoggerFactory</h3><p>​    获取过程中采用懒加载模式，为避免多线程堵塞，使用状态位标识初始化时的多种状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用类全路径名创建Logger</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Logger <span class="hljs-title function_">getLogger</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> &#123;<br>       <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> getLogger(clazz.getName());<br>      <span class="hljs-keyword">return</span> logger;<br>   &#125;<br><br><span class="hljs-comment">//通过获取ILoggerFactory工厂，创建Logger</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Logger <span class="hljs-title function_">getLogger</span><span class="hljs-params">(String name)</span> &#123;<br>   <span class="hljs-type">ILoggerFactory</span> <span class="hljs-variable">iLoggerFactory</span> <span class="hljs-operator">=</span> getILoggerFactory();<br>   <span class="hljs-keyword">return</span> iLoggerFactory.getLogger(name);<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">判断状态位 INITIALIZATION_STATE，状态位共五种状态</span><br><span class="hljs-comment">UNINITIALIZED   尚未初始化</span><br><span class="hljs-comment">SUCCESSFUL_INITIALIZATION  成功初始化</span><br><span class="hljs-comment">NOP_FALLBACK_INITIALIZATION 无底层实现类</span><br><span class="hljs-comment">FAILED_INITIALIZATION  初始化报错</span><br><span class="hljs-comment">ONGOING_INITIALIZATION  初始化中</span><br><span class="hljs-comment">*/</span><br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ILoggerFactory <span class="hljs-title function_">getILoggerFactory</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//这里类似懒汉单例模式，加锁后设置状态位为ONGOING_INITIALIZATION，然后调用初始化代码。这样就只能有一个线程会初始化loggerfactory，其他线程走下面的switch 中的 ONGOING_INITIALIZATION。</span><br>       <span class="hljs-keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;<br>           <span class="hljs-keyword">synchronized</span> (LoggerFactory.class) &#123;<br>               <span class="hljs-keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;<br>                   INITIALIZATION_STATE = ONGOING_INITIALIZATION;<br>                   performInitialization();<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">switch</span> (INITIALIZATION_STATE) &#123;<br>       <span class="hljs-comment">//初始化成功，返回单例的LoggerFactory</span><br>       <span class="hljs-keyword">case</span> SUCCESSFUL_INITIALIZATION:<br>           <span class="hljs-keyword">return</span> StaticLoggerBinder.getSingleton().getLoggerFactory();<br>       <span class="hljs-comment">//没底层实现时走这里        </span><br>       <span class="hljs-keyword">case</span> NOP_FALLBACK_INITIALIZATION:<br>           <span class="hljs-keyword">return</span> NOP_FALLBACK_FACTORY;<br>       <span class="hljs-comment">//初始化过程中抛异常，这里也抛异常        </span><br>       <span class="hljs-keyword">case</span> FAILED_INITIALIZATION:<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(UNSUCCESSFUL_INIT_MSG);<br>       <span class="hljs-comment">//初始化中，返回一个代理Factory，此代理Factory能创建代理Logger</span><br>       <span class="hljs-keyword">case</span> ONGOING_INITIALIZATION:<br>           <span class="hljs-comment">// support re-entrant behavior.</span><br>           <span class="hljs-comment">// See also http://jira.qos.ch/browse/SLF4J-97</span><br>           <span class="hljs-keyword">return</span> SUBST_FACTORY;<br>       &#125;<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Unreachable code&quot;</span>);<br>   &#125;<br><br><br><span class="hljs-comment">//这里的INITIALIZATION_STATE的定义，其加了volatile关键字，多线程修改他时，能立刻被看到</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIALIZATION_STATE</span> <span class="hljs-operator">=</span> UNINITIALIZED;<br><br></code></pre></td></tr></table></figure><h3 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h3><ul><li>1.如果第一次访问，为未初始化状态，<code>UNINITIALIZED</code>，则让第一个获得锁的进行初始化，且不会堵塞后来的线程，将状态切换成<code>ONGOING_INITIALIZATION</code>。</li><li>2.如果初始化成功，<code>SUCCESSFUL_INITIALIZATION</code>，后来的线程可以直接从<code>StaticLoggerBinder</code>中获取<code>loggerFactory</code>。</li><li>3.如果没有底层实现类，<code>NOP_FALLBACK_INITIALIZATION</code>，则返回<code>NOP_FALLBACK_FACTORY</code>。</li><li>4.如果初始化报错了，<code>FAILED_INITIALIZATION</code>，则直接抛出异常，阻止程序继续执行。</li><li>5.如果正在初始化中<code>ONGOING_INITIALIZATION</code>，则返回一个代理<code>loggerFactory</code>，他会把所有的<code>logger</code>记录在队列中，等待真正初始化完成后，用真实的<code>logger</code>把队列中的日志输出出来。</li></ul><p>​        其中比较有意思的就是，<code>slf4j</code>为了在初始化<code>Factory</code>期间不堵塞程序，设置了<code>ONGOING_INITIALIZATION</code>状态，在此状态下（初始化中）获取<code>Factory</code>会返回<code>SubstituteLoggerFactory</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初始化中时，返回的临时loggerfactory</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">SubstituteLoggerFactory</span> <span class="hljs-variable">SUBST_FACTORY</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubstituteLoggerFactory</span>();<br><br></code></pre></td></tr></table></figure><h3 id="SubstituteLoggerFactory实现细节"><a href="#SubstituteLoggerFactory实现细节" class="headerlink" title="SubstituteLoggerFactory实现细节"></a><code>SubstituteLoggerFactory</code>实现细节</h3><p>​        下面代码是<code>SubstituteLoggerFactory</code>的<code>getLogger()</code>方法。        </p><p>第二行的<code>loggers</code> 是一个<code>Map</code>，<code>getLogger</code>方法会返回<code>SubstituteLogger</code>对象，并缓存到<code>loggers</code>里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//SubstituteLoggerFactory的getLogger方法</span><br>   <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">public</span>  Logger <span class="hljs-title function_">getLogger</span><span class="hljs-params">(String name)</span> &#123;<br>       <span class="hljs-type">SubstituteLogger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> loggers.get(name);<br>       <span class="hljs-keyword">if</span> (logger == <span class="hljs-literal">null</span>) &#123;<br>           logger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubstituteLogger</span>(name, eventQueue, postInitialization);<br>           loggers.put(name, logger);<br>       &#125;<br>       <span class="hljs-keyword">return</span> logger;<br>   &#125;<br></code></pre></td></tr></table></figure><p>​        </p><h3 id="SubstituteLogger实现细节"><a href="#SubstituteLogger实现细节" class="headerlink" title="SubstituteLogger实现细节"></a><code>SubstituteLogger</code>实现细节</h3><p>​        这个logger是一个代理logger，它包含一个<code>_delegate</code>对象，当<code>_delegate</code>为空时,会根据<code>createdPostInitialization</code>标志位返回<code>NOP_LOGGER</code>或者<code>EventRecodingLogger</code>。</p><p><code>EventRecodingLogger</code>会将日志输出到到<code>eventQueue</code>里。</p><p><code>createdPostInitialization</code>默认是false，Logger初始化后该值被设置为true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//SubstituteLogger的info方法，是如何实现的</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Logger _delegate;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> createdPostInitialization;<br>  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">(String msg)</span> &#123;<br>       delegate().info(msg);<br>   &#125;<br><br>   Logger <span class="hljs-title function_">delegate</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">if</span>(_delegate != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> _delegate;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(createdPostInitialization) &#123;<br>           <span class="hljs-keyword">return</span> NOPLogger.NOP_LOGGER;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">return</span> getEventRecordingLogger();<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> Logger <span class="hljs-title function_">getEventRecordingLogger</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">if</span> (eventRecodingLogger == <span class="hljs-literal">null</span>) &#123;<br>           eventRecodingLogger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventRecodingLogger</span>(<span class="hljs-built_in">this</span>, eventQueue);<br>       &#125;<br>       <span class="hljs-keyword">return</span> eventRecodingLogger;<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>​      <code>delegate()</code>方法会有三种返回可能，</p><ol><li>如果存在被代理的<code>_delegate</code>，则返回<code>_delegate</code></li><li>如果<code>createdPostInitialization</code>为<code>true</code>，则返回一个<code>nopLogger</code>，否则返回一个<code>EventRecodingLogger</code>。</li><li><code>nopLogger</code> 会扔掉所有的日志</li><li><code>EventRecodingLogger</code>会将所有日志放入<code>queue</code>中存储起来。</li></ol><p><strong>所以slf4j在初始化阶段的日志也不会丢失，而是存储在queue中，等到初始化完成，会取出来输出。</strong></p><h3 id="loggerFactory初始化过程"><a href="#loggerFactory初始化过程" class="headerlink" title="loggerFactory初始化过程"></a><code>loggerFactory</code>初始化过程</h3><p>​        核心在bind方法里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//用类加载器加载名称叫做 ‘org/slf4j/impl/StaticLoggerBinder.class’的类，这个字符串是写死在代码里的。因为可能存在多个实现，所以使用Set&lt;URL&gt;</span><br>           Set&lt;URL&gt; staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();<br>       <span class="hljs-comment">//调用StaticLoggerBinder的静态方法，StaticLoggerBinder可能不存在而报NoClassDefFoundError下面会捕获这个异常。</span><br>           StaticLoggerBinder.getSingleton();<br><span class="hljs-comment">//修改状态位为success</span><br>           INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;<br><span class="hljs-comment">//将SubstituteLoggerFactory的loggers（map）存储的临时logger获取出来，设置logger中的_delegate变量为真实logger</span><br>           fixSubstituteLoggers();<br><span class="hljs-comment">//从队列中取出日志，用真实logger输出</span><br>           replayEvents();<br>           <span class="hljs-comment">//清理SubstituteLoggerFactory 内map中存储的logger，清理队列</span><br>           SUBST_FACTORY.clear();<br>       &#125; <span class="hljs-keyword">catch</span> (NoClassDefFoundError ncde) &#123;<br><span class="hljs-comment">//如果报NoClassDefFoundError，可能是没有任何实现类，这时将状态位设为NOP_FALLBACK_INITIALIZATION</span><br>           <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> ncde.getMessage();<br>           <span class="hljs-keyword">if</span> (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) &#123;<br>               INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               failedBinding(ncde);<br>               <span class="hljs-keyword">throw</span> ncde;<br>           &#125;<br><span class="hljs-comment">//如果报NoSuchMethodError，可能是底层实现类没有按照要求实现，将状态位设为FAILED_INITIALIZATION</span><br>       &#125; <span class="hljs-keyword">catch</span> (java.lang.NoSuchMethodError nsme) &#123;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> nsme.getMessage();<br>           <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; msg.contains(<span class="hljs-string">&quot;org.slf4j.impl.StaticLoggerBinder.getSingleton()&quot;</span>)) &#123;<br>               INITIALIZATION_STATE = FAILED_INITIALIZATION;<br>           &#125;<br>           <span class="hljs-keyword">throw</span> nsme;<br>       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>           failedBinding(e);<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Unexpected initialization failure&quot;</span>, e);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code class="hljs">    `slf4j`会反射`org/slf4j/impl/StaticLoggerBinder.class`类，如果发现多个实现类，会输出日志提醒用户存在多个实现，并使用第一个实现类。</code></pre><p>​            他会直接调用<code>StaticLoggerBinder.getSingleton()</code>,如果不存在<code>org/slf4j/impl/StaticLoggerBinder.class</code>会抛<code>ClassNotFound</code>异常，这就表明底层实现不存在。</p><p>​获取<code>StaticLoggerBinder</code>实例过后，会调用<code>fixSubstituteLoggers()</code>修复初始话中创建的临时<code>logger</code>，会将存储在<code>queue</code>中的日志重新输出。</p><h2 id="一个bug"><a href="#一个bug" class="headerlink" title="一个bug"></a>一个bug</h2><p>​      上面的实现其实存在一个<code>BUG</code>，核心方法<code>bind()</code>里面的<code>fixSubstituteLoggers()</code>方法，<code>replayEvents()</code>方法只会在存在底层log实现时才会执行，不存在底层实现会抛异常进入<code>cache</code>代码块。如果这种情况下将导致日志一直输出到<code>Queue</code>里面，导致<code>OOM</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这几行代码在没有底层实现时不能执行</span><br>fixSubstituteLoggers();<br>replayEvents();<br>SUBST_FACTORY.clear();<br></code></pre></td></tr></table></figure><h2 id="2020-04-更新"><a href="#2020-04-更新" class="headerlink" title="2020-04 更新"></a>2020-04 更新</h2><p>​        上面提到的bug已经在<code>1.7.30</code>版本修复，新版本在<code>finally</code>代码块里面处理的这些逻辑，无论是否初始化成功都会释放<code>Queue</code>里面的日志，所以不用担心日志不释放的问题。</p><h3 id="但极端情况下还会出现问题"><a href="#但极端情况下还会出现问题" class="headerlink" title="但极端情况下还会出现问题"></a>但极端情况下还会出现问题</h3><p>​1. 线程A执行下面代码，因为第一次执行会触发初始化逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Logger <span class="hljs-title function_">getLogger</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-type">ILoggerFactory</span> <span class="hljs-variable">iLoggerFactory</span> <span class="hljs-operator">=</span> getILoggerFactory();<br>    <span class="hljs-keyword">return</span> iLoggerFactory.getLogger(name);<br>&#125;<br></code></pre></td></tr></table></figure><p>​      2. 线程B在执行下面代码，获取到的<code>ILoggerFactory</code>是<code>SubstituteLoggerFactory</code>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Logger <span class="hljs-title function_">getLogger</span><span class="hljs-params">(String name)</span> &#123;<br>       <span class="hljs-type">ILoggerFactory</span> <span class="hljs-variable">iLoggerFactory</span> <span class="hljs-operator">=</span> getILoggerFactory();<br>    sleep(<span class="hljs-number">10000</span>); <span class="hljs-comment">//假设线程B执行到这里，让出cpu</span><br>       <span class="hljs-keyword">return</span> iLoggerFactory.getLogger(name);<br>   &#125;<br></code></pre></td></tr></table></figure><p>​      3. 线程A接着执行，直到<code>LoggerFactory</code>初始化完成，在方法<code>fixSubstituteLoggers（）</code>里面会将<code>SubstituteLoggerFactory</code>里面的状态位<code>postInitialization</code>设为true，并修复创建<code>LoggerFactory</code>期间生成的的代理<code>Logger</code>。</p><p>​      4. 接着线程B继续执行，他会拿到<code>ILoggerFactory</code>对象获取到一个<code>SubstituteLogger</code>，这个<code>SubstituteLogger</code>不能得到修复，会恒返回<code>NOP_LOGGER</code>实例。从而使日志失效。</p><h3 id="新版本"><a href="#新版本" class="headerlink" title="新版本"></a>新版本</h3><p><code>1.8</code>版本以后<code>slf4j</code>加载底层实现改为<code>java</code>的<code>SPI</code>技术做了。请看这个类<code>java.util.ServiceLoader</code>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>slf4j</tag>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>guava eventBus使用和分析</title>
    <link href="/3966182547.html"/>
    <url>/3966182547.html</url>
    
    <content type="html"><![CDATA[<h2 id="guava-eventBus使用和分析"><a href="#guava-eventBus使用和分析" class="headerlink" title="guava eventBus使用和分析"></a>guava eventBus使用和分析</h2><pre><code class="hljs">eventBus就是类似于观察这模式，我们将监听器注册到eventBus内，调用eventBus的post（object）方法，将任何object对象发送到eventbus中，如果某个eventbus内的监听器对该object感兴趣，则会被回掉。并将该object作为参数传进去</code></pre><h2 id="为什么使用"><a href="#为什么使用" class="headerlink" title="为什么使用"></a>为什么使用</h2><pre><code class="hljs">eventBus使用非常方便，效率高，且监听器只需加一个注解即可，不需要特定的方法名，不需要实现特定的接口，不需要知道自己身处于哪个eventbus中。</code></pre><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//任写一个类，任写一个方法，但只能有一个参数，且在方法上，加上Subscribe注解,这就是一个观察者</span><br><span class="hljs-comment">//参数类型为这个方法感兴趣的类型，注解标记此方法是一个监听者，一个类中可以多个方法都加此注解，这样每个方法都是一个监听者。</span><br><br><span class="hljs-keyword">import</span> com.google.common.eventbus.Subscribe;<br><br><span class="hljs-comment">/*这是一个监听者*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Listerer3</span> &#123;<br><span class="hljs-meta">@Subscribe</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(Integer event)</span> &#123;<br>System.out.println(event);<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">//创建eventBus，注册监听者，发送数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//创建eventBus</span><br><span class="hljs-type">EventBus</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventBus</span>();<br><span class="hljs-comment">//注册观察者</span><br>e.register(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Listerer3</span>());<br><span class="hljs-comment">//发送消息，发送的消息是int类型的，这样监听其他类型的监听者就不会收到这条消息</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>e.post(i);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>***注意 消息监听者不只是能够监听类型完全匹配的消息，如果监听的是父类型，而消息是子类型，也是可以收到的 ***</p></blockquote><h2 id="消息是根据什么找到观察者的"><a href="#消息是根据什么找到观察者的" class="headerlink" title="消息是根据什么找到观察者的"></a>消息是根据什么找到观察者的</h2><pre><code class="hljs">消息可以使任意类型的，他根据观察者的参数类型进行匹配，如果观察者的能够处理则调用观察者的方法。否则不调用。其中如果观察者需要父类型的事件，而事件本身是子类型的同样可以触发。匹配方式是 `obj instanceof param` 而不是 `obj.getClass() == param.getClass()`</code></pre><h2 id="eventbus底层是如何实现的"><a href="#eventbus底层是如何实现的" class="headerlink" title="eventbus底层是如何实现的"></a>eventbus底层是如何实现的</h2><h3 id="注册观察者"><a href="#注册观察者" class="headerlink" title="注册观察者"></a>注册观察者</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs perl"> void register(Object listener) &#123;<br><br><span class="hljs-regexp">//</span>通过反射获取该<span class="hljs-class"><span class="hljs-keyword">class</span>及父类的的所有方法，检索带有 `@<span class="hljs-title">Subscribe</span>`注解的方法</span><br><span class="hljs-class">//键为<span class="hljs-title">Subscriber</span>注解方法的参数类型，值为同为此类型的所有<span class="hljs-title">method</span>，包装成<span class="hljs-title">Subscriber</span>对象</span><br><span class="hljs-class">   <span class="hljs-title">Multimap</span>&lt;<span class="hljs-title">Class</span>&lt;?&gt;, <span class="hljs-title">Subscriber</span>&gt; <span class="hljs-title">listenerMethods</span> = <span class="hljs-title">findAllSubscribers</span>(<span class="hljs-title">listener</span>)</span>;<br><br>//循环遍历，并放入subscribers对象的Map&lt;<span class="hljs-class"><span class="hljs-keyword">class</span>,<span class="hljs-title">Set</span>&lt;&gt;&gt;中</span><br><span class="hljs-class">   <span class="hljs-title">for</span> (<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">Class</span>&lt;?&gt;, <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">Subscriber</span>&gt;&gt; <span class="hljs-title">entry</span><span class="hljs-attr"> : listenerMethods</span>.<span class="hljs-title">asMap</span>().<span class="hljs-title">entrySet</span>()) </span>&#123;<br>     Class&lt;?&gt; eventType = entry.getKey();<br>     Collection&lt;Subscriber&gt; eventMethodsInListener = entry.getValue();<br><br>     CopyOnWriteArraySet&lt;Subscriber&gt; eventSubscribers = subscribers.get(eventType);<br><br>     <span class="hljs-keyword">if</span> (eventSubscribers == null) &#123;<br>       CopyOnWriteArraySet&lt;Subscriber&gt; newSet = new CopyOnWriteArraySet&lt;&gt;();<br>       eventSubscribers =<br>           MoreObjects.firstNonNull(subscribers.putIfAbsent(eventType, newSet), newSet);<br>     &#125;<br><br>     eventSubscribers.addAll(eventMethodsInListener);<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="取消注册观察者"><a href="#取消注册观察者" class="headerlink" title="取消注册观察者"></a>取消注册观察者</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs swift"> void unregister(<span class="hljs-type">Object</span> listener) &#123;<br><br><span class="hljs-comment">//通过反射获取该class及父类的的所有方法，检索带有 `@Subscribe`注解的方法</span><br><span class="hljs-comment">//键为Subscriber注解方法的参数类型，值为同为此类型的所有method，包装成Subscriber对象</span><br>   <span class="hljs-type">Multimap</span>&lt;<span class="hljs-type">Class</span>&lt;?&gt;, <span class="hljs-type">Subscriber</span>&gt; listenerMethods <span class="hljs-operator">=</span> findAllSubscribers(listener);<br><br><span class="hljs-comment">//遍历map，从总的观察者集合中移除这些观察者，每个观察者等同于一个带注解的方法</span><br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span>&lt;<span class="hljs-type">Class</span>&lt;?&gt;, <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">Subscriber</span>&gt;&gt; entry : listenerMethods.asMap().entrySet()) &#123;<br>     <span class="hljs-type">Class</span>&lt;?&gt; eventType <span class="hljs-operator">=</span> entry.getKey();<br>     <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">Subscriber</span>&gt; listenerMethodsForType <span class="hljs-operator">=</span> entry.getValue();<br><br>     <span class="hljs-type">CopyOnWriteArraySet</span>&lt;<span class="hljs-type">Subscriber</span>&gt; currentSubscribers <span class="hljs-operator">=</span> subscribers.get(eventType);<br>     <span class="hljs-keyword">if</span> (currentSubscribers <span class="hljs-operator">==</span> null <span class="hljs-operator">||</span> <span class="hljs-operator">!</span>currentSubscribers.removeAll(listenerMethodsForType)) &#123;<br>       <span class="hljs-keyword">throw</span> new <span class="hljs-type">IllegalArgumentException</span>(<br>           <span class="hljs-string">&quot;missing event subscriber for an annotated method. Is &quot;</span> <span class="hljs-operator">+</span> listener <span class="hljs-operator">+</span> <span class="hljs-string">&quot; registered?&quot;</span>);<br>     &#125;<br><br>     <span class="hljs-comment">// don&#x27;t try to remove the set if it&#x27;s empty; that can&#x27;t be done safely without a lock</span><br>     <span class="hljs-comment">// anyway, if the set is empty it&#x27;ll just be wrapping an array of length 0</span><br>   &#125;<br> &#125;<br><br></code></pre></td></tr></table></figure><h3 id="发布消息"><a href="#发布消息" class="headerlink" title="发布消息"></a>发布消息</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">post</span>(<span class="hljs-params">Object <span class="hljs-keyword">event</span></span>)</span> &#123;<br><span class="hljs-comment">//根据消息类型，和消息的祖先类型，获取对应的观察者    </span><br>Iterator&lt;Subscriber&gt; eventSubscribers = subscribers.getSubscribers(<span class="hljs-keyword">event</span>);<br>   <span class="hljs-comment">//至少有一个观察者，则循环回掉他们的方法，否则，发送一个DeadEvent，可以写一个观察者观察DeadEvent类，这样如果有某种类型的事件没有观察者可以检测到</span><br><span class="hljs-keyword">if</span> (eventSubscribers.hasNext()) &#123;<br>     dispatcher.dispatch(<span class="hljs-keyword">event</span>, eventSubscribers);<br>   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">event</span> instanceof DeadEvent)) &#123;<br>     <span class="hljs-comment">// the event had no subscribers and was not itself a DeadEvent</span><br>     post(<span class="hljs-keyword">new</span> DeadEvent(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">event</span>));<br>   &#125;<br> &#125;<br><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code class="hljs">注册时会将对象的父类，父父类等的带注解的方法统统注册进来，得到一个参数类型为键，实际method为值的map ，即 map&lt;class,Set&lt;Method&gt;&gt;取消注册时，也会遍历祖先，因为有缓存了可能就不用遍历了，得到 map&lt;class,List&lt;Method&gt;&gt; ， 从总map中减去该map发布消息时，通过消息的类型，找到所有观察者，回掉他们的方法。不仅仅只是订阅了该消息类型的观察者，订阅了他父类的观察者同样可以收到消息。</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><pre><code class="hljs">两个相同的观察者不能注册多次，判断相同的方法是 方法所在的对象是同一个，方法相同。也就是说，一个类的同一个对象不能注册多次，同一个类可以new多个对象，每个new出来的新对象可以共同存在。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可以使用位操作存储简单一对多的情况</title>
    <link href="/4248451535.html"/>
    <url>/4248451535.html</url>
    
    <content type="html"><![CDATA[<h1 id="可以使用位操作存储简单一对多的情况"><a href="#可以使用位操作存储简单一对多的情况" class="headerlink" title="可以使用位操作存储简单一对多的情况"></a>可以使用位操作存储简单一对多的情况</h1><h3 id="需求如下"><a href="#需求如下" class="headerlink" title="需求如下"></a>需求如下</h3><pre><code class="hljs">数据库中 user表有字段userLevel标识用户等级1 普通用户2 高级用户3 vip用户4 管理员5 开发人员另一张公告表A，发布公告时，需要指定类型的用户能看到，如只给管理员发公告，或者 只给 普通用户，高级用户发公告，其他人看不到</code></pre><h4 id="当然可以采用中间表的形式，每个公告存储该公告能访问的对应等级的user。今天我们采用另一种方法"><a href="#当然可以采用中间表的形式，每个公告存储该公告能访问的对应等级的user。今天我们采用另一种方法" class="headerlink" title="当然可以采用中间表的形式，每个公告存储该公告能访问的对应等级的user。今天我们采用另一种方法"></a>当然可以采用中间表的形式，每个公告存储该公告能访问的对应等级的user。今天我们采用另一种方法</h4><h3 id="二进制位法，原理如下"><a href="#二进制位法，原理如下" class="headerlink" title="二进制位法，原理如下"></a>二进制位法，原理如下</h3><ul><li>设对应关系如下：</li></ul><table><thead><tr><th>用户等级</th><th>标识</th><th>code</th></tr></thead><tbody><tr><td>普通用户</td><td>1</td><td>1&lt;&lt;0</td></tr><tr><td>高级用户</td><td>2</td><td>1&lt;&lt;2</td></tr><tr><td>vip用户</td><td>3</td><td>1&lt;&lt;3</td></tr><tr><td>管理员</td><td>4</td><td>1&lt;&lt;4</td></tr><tr><td>开发人员</td><td>5</td><td>1&lt;&lt;5</td></tr></tbody></table><pre><code class="hljs">0 0 0 0 0 0 0 1  == 普通用户0 0 0 0 0 0 1 0  == 高级用户0 0 0 0 0 1 0 0  == vip用户0 0 0 0 1 0 0 0  == 管理员0 0 0 1 0 0 0 0  == 开发人员0 0 0 0 0 0 1 1  == 普通用户 + 高级用户0 0 0 0 1 0 1 0  == 高级用户 + 管理员</code></pre><hr><pre><code class="hljs">每种等级的用户占用一个32位int类型的一位，当发公告时，按位存储能看到该公告人的等级，如：想要 普通用户和高级用户看到 存储 (1&lt;&lt;0) &amp; (1&lt;&lt;2) 即 0b01 &amp; 0b10 = 0b11 = 3,这个3标识了普通用户和高级用户</code></pre><h4 id="如何查询-如查询普通用户查看到的公告"><a href="#如何查询-如查询普通用户查看到的公告" class="headerlink" title="如何查询? ,如查询普通用户查看到的公告"></a>如何查询? ,如查询普通用户查看到的公告</h4><blockquote><p>select * from A where userLeverCode &amp; 1 !&#x3D; 0</p></blockquote><pre><code class="hljs">这样的sql就能查询到所有包含普通用户的公告了。</code></pre><h4 id="下面的sql用于测试"><a href="#下面的sql用于测试" class="headerlink" title="下面的sql用于测试"></a>下面的sql用于测试</h4><pre><code class="hljs">select 1&amp;1select 1&amp;2select 1&amp;3select 4&amp;6</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vertx buffer类</title>
    <link href="/815345507.html"/>
    <url>/815345507.html</url>
    
    <content type="html"><![CDATA[<h1 id="vertx-buffer类"><a href="#vertx-buffer类" class="headerlink" title="vertx buffer类"></a>vertx buffer类</h1><h2 id="Buffer类"><a href="#Buffer类" class="headerlink" title="Buffer类"></a>Buffer类</h2><pre><code class="hljs">vertx的Buffer接口实现类 BufferImpl 对netty的ByteBuf进行封装，隐藏了复杂的读写指针操作，改写了一些基本操作进行改写，如read 操作  -&gt; 移除了write 操作 -&gt; appendget -&gt;  getset -&gt; setcopy -&gt; copyslice-&gt; slice当然方便操作的同时带来的是一点点性能损失。封装的ByteBuf都是Unpoold的，享受不到ByteBuf池带来的好处。</code></pre><h2 id="不同类型变量的内存占用"><a href="#不同类型变量的内存占用" class="headerlink" title="不同类型变量的内存占用"></a>不同类型变量的内存占用</h2><pre><code class="hljs">byte 1字节short 2字节medium 3字节int 4字节long 8字节double 8字节其中appendIntLE 表示将 int 的bit反着插入buffer中，appendUnsignedInt 表示插入无符号位的int，将int符号位当成普通bit使用这样getUnsignedInt就必须以long类型来接受了。</code></pre><h2 id="1-创建buffer"><a href="#1-创建buffer" class="headerlink" title="1.创建buffer"></a>1.创建buffer</h2><pre><code class="hljs">创建buffer 由Buffer接口的静态方法实现。有以下几个构造工厂方法：Buffer.buffer()；  默认大小为 integer.max的空bufferstatic Buffer buffer(int initialSizeHint)； 指定大小的bufferstatic Buffer buffer(String string)； 将string以u8的编码转成byte[] 再调用下面的构造方法static Buffer buffer(String string, String enc)；将string以指定编码转成byte[]，再调用下面的构造方法static Buffer buffer(byte[] bytes)； 默认integer.max的buffer，写入指定数据static Buffer buffer(ByteBuf byteBuf)； 从netty的bufferBuf中拷贝数据，构造新的buffer</code></pre><h2 id="2-拷贝和切片"><a href="#2-拷贝和切片" class="headerlink" title="2.拷贝和切片"></a>2.拷贝和切片</h2><h3 id="2-1-拷贝"><a href="#2-1-拷贝" class="headerlink" title="2.1 拷贝"></a>2.1 拷贝</h3><pre><code class="hljs">拷贝函数，底层调用netty的ByteBuf的copy方法，复制一个ByteBuf ，再new一个Buffer。新建的Buffer 和原来的没有关系，只是写指针相同，大小相同，内容相同。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Buffer <span class="hljs-title function_">copy</span><span class="hljs-params">()</span> &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferImpl</span>(buffer.copy());<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-切片"><a href="#2-2-切片" class="headerlink" title="2.2 切片"></a>2.2 切片</h3><pre><code class="hljs">切片函数，返回一个原buffer的切片，切片buffer的大小等于切片范围， 底层和原buffer是同一个ButeBuf，因为切片的大小在调用切片函数时，就确定了，所以无法在对切片返回的buffer进行append操作，但可以修改它，这样原buffer也会被修改。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 底层实现"><br>public Buffer slice() &#123;<br>   return new BufferImpl(buffer.slice());<br> &#125;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br><span class="hljs-type">Buffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> Buffer.buffer(<span class="hljs-string">&quot;abc&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;新创建的:&quot;</span> + buffer); <span class="hljs-comment">//此时底层Bytebuf大小为Integer.max，内容为abc</span><br><br><span class="hljs-type">Buffer</span> <span class="hljs-variable">copy</span> <span class="hljs-operator">=</span> buffer.slice(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//创建切片， 此切片的大小为2 内容为 bc</span><br>System.out.println(<span class="hljs-string">&quot;切片:&quot;</span> + copy);<br><br>copy.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;d&quot;</span>); <span class="hljs-comment">//修改切片第1位，也就是原Buffer的第二位，为d此时切片大小为2 ，内容为bd</span><br>System.out.println(<span class="hljs-string">&quot;修改后的原buffer:&quot;</span> + buffer.toString());  <span class="hljs-comment">//原buffer的内容也跟着变成abd了。</span><br>System.out.println(<span class="hljs-string">&quot;修改后的切片:&quot;</span> + copy); <span class="hljs-comment">//切片变成 bd</span><br><br>copy.appendString(<span class="hljs-string">&quot;e&quot;</span>); <span class="hljs-comment">//这句会报错，因为切片的大小被固定为2，只能修改无法再添加</span><br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><pre><code class="hljs">当然一般用切片只是为了提高性能，不要原buffer 和 切片都进行修改，不然容易把自己搞混了，还有获取的切片大小固定，不能再添加内容了，不然会报错。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>vertx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vertx jsonArray jsonObject json指针</title>
    <link href="/1760204374.html"/>
    <url>/1760204374.html</url>
    
    <content type="html"><![CDATA[<h1 id="vertx-jsonArray-jsonObject-json指针"><a href="#vertx-jsonArray-jsonObject-json指针" class="headerlink" title="vertx jsonArray jsonObject json指针"></a>vertx jsonArray jsonObject json指针</h1><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><pre><code class="hljs">jsonobject 相当于一个Map&lt;String,Object&gt; , jsonArray相当于一个 List&lt;Object&gt;</code></pre><h2 id="JsonObject"><a href="#JsonObject" class="headerlink" title="JsonObject"></a>JsonObject</h2><pre><code class="hljs">构造方法，可以通过jsonString,构造，或者map构造。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">String</span> <span class="hljs-variable">jsonStrng</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;name\&quot;:\&quot;小明\&quot;&#125;&quot;</span>;<br><span class="hljs-type">JsonObject</span> <span class="hljs-variable">j1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonObject</span>(jsonStrng);<br><br>Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;小明&quot;</span>);<br>map.put(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;12&quot;</span>);<br><span class="hljs-type">JsonObject</span> <span class="hljs-variable">j2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonObject</span>(map);<br><br></code></pre></td></tr></table></figure><h4 id="获取值-添加值-键set-转成map"><a href="#获取值-添加值-键set-转成map" class="headerlink" title="获取值 &#x2F; 添加值 &#x2F;键set &#x2F;转成map"></a>获取值 &#x2F; 添加值 &#x2F;键set &#x2F;转成map</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">jsonStrng</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;name\&quot;:\&quot;小明\&quot;,\&quot;class\&quot;:\&quot;小学一年级\&quot;,\&quot;school\&quot;:&#123;\&quot;name\&quot;:\&quot;xx小学\&quot;,\&quot;address\&quot;:\&quot;北京\&quot;&#125;&#125;&quot;</span>;<br><span class="hljs-type">JsonObject</span> <span class="hljs-variable">j1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonObject</span>(jsonStrng);<br><br><span class="hljs-comment">//获取值</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> j1.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;获取值：&quot;</span>+name);<br><br><span class="hljs-comment">//获取值，为空则返回默认值</span><br><span class="hljs-type">String</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> j1.getString(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;空&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;获取值，为空则默认值&quot;</span>+age);<br><br><span class="hljs-comment">//如果不提供默认值则返回null</span><br><span class="hljs-type">String</span> <span class="hljs-variable">age1</span> <span class="hljs-operator">=</span> j1.getString(<span class="hljs-string">&quot;age&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;获取值，为空则返回null:&quot;</span>+age1);<br><br><span class="hljs-comment">//获取键的set集合</span><br>Set&lt;String&gt; strings = j1.fieldNames();<br>System.out.println(<span class="hljs-string">&quot;获取键的集合&quot;</span>+strings);<br><br><span class="hljs-comment">//转成map</span><br>Map&lt;String, Object&gt; map = j1.getMap();<br><br><span class="hljs-comment">//put 可以连续的调用put方法</span><br><br>j1.put(<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-string">&quot;bar&quot;</span>).put(<span class="hljs-string">&quot;num&quot;</span>,<span class="hljs-number">123</span>);<br><br><br></code></pre></td></tr></table></figure><h4 id="合并json"><a href="#合并json" class="headerlink" title="合并json"></a>合并json</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">&quot;name&quot;: &quot;小明&quot;,</span><br><span class="hljs-comment">&quot;class&quot;: &quot;小学一年级&quot;,</span><br><span class="hljs-comment">&quot;school&quot;: &#123;</span><br><span class="hljs-comment">&quot;name&quot;: &quot;xx小学&quot;,</span><br><span class="hljs-comment">&quot;address&quot;: &quot;北京&quot;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">jsonStrng</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;name\&quot;:\&quot;小明\&quot;,\&quot;class\&quot;:\&quot;小学一年级\&quot;,\&quot;school\&quot;:&#123;\&quot;name\&quot;:\&quot;xx小学\&quot;,\&quot;address\&quot;:\&quot;北京\&quot;&#125;&#125;&quot;</span>;<br><span class="hljs-type">JsonObject</span> <span class="hljs-variable">j1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonObject</span>(jsonStrng);<br><br><span class="hljs-comment">//将此json内的值，替换成提供的jsonObject的值</span><br><span class="hljs-type">String</span> <span class="hljs-variable">jsonStrng2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;name\&quot;:\&quot;小明\&quot;,\&quot;class\&quot;:\&quot;小学一年级\&quot;,\&quot;school\&quot;:&#123;\&quot;address\&quot;:\&quot;安徽\&quot;&#125;&#125;&quot;</span>;<br><span class="hljs-type">JsonObject</span> <span class="hljs-variable">j2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonObject</span>(jsonStrng2);<br><span class="hljs-type">JsonObject</span> <span class="hljs-variable">j3</span> <span class="hljs-operator">=</span> j1.mergeIn(j2);<br>System.out.println(<span class="hljs-string">&quot;合并json1：&quot;</span>+j3);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">mergeIn(JsonObject obj);</span><br><span class="hljs-comment">mergeIn(JsonObject obj,Boolean deep);</span><br><span class="hljs-comment">mergeIn(JsonObject obj,int deep);</span><br><span class="hljs-comment">第一个表示浅合并，只要键相同则直接替换，</span><br><span class="hljs-comment">第二个如果参数传true，则表示深度合并，即如果某个键对应的值也是json，则对值内的json也进行合并。</span><br><span class="hljs-comment">第三个可以指定合并的深度，深度内为深合并，深度外为浅合并。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">上面的代码，浅合并结果为</span><br><span class="hljs-comment">&#123;&quot;name&quot;:&quot;小明&quot;,&quot;class&quot;:&quot;小学一年级&quot;,&quot;school&quot;:&#123;&quot;address&quot;:&quot;安徽&quot;&#125;&#125;</span><br><span class="hljs-comment">深合并结果为</span><br><span class="hljs-comment">&#123;&quot;name&quot;:&quot;小明&quot;,&quot;class&quot;:&quot;小学一年级&quot;,&quot;school&quot;:&#123;&quot;name&quot;:&quot;xx小学&quot;,&quot;address&quot;:&quot;安徽&quot;&#125;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><h4 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h4><pre><code class="hljs"> encode 方法  正常打印出json字符串（一行） encodePrettily方法 格式化打印json（更容易观察）</code></pre><h2 id="JsonArray"><a href="#JsonArray" class="headerlink" title="JsonArray"></a>JsonArray</h2><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//通过字符串构造</span><br><span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;[1, 2, 3, 4]&quot;</span>;<br><span class="hljs-type">JsonArray</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonArray</span>(json);<br><br><span class="hljs-comment">//通过list构造</span><br>List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>);<br><span class="hljs-type">JsonArray</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonArray</span>(list);<br><br></code></pre></td></tr></table></figure><h4 id="基本操作，请查看api"><a href="#基本操作，请查看api" class="headerlink" title="基本操作，请查看api"></a>基本操作，请查看api</h4><h2 id="JsonPointer-json指针"><a href="#JsonPointer-json指针" class="headerlink" title="JsonPointer json指针"></a>JsonPointer json指针</h2><pre><code class="hljs">json指针，类似于xml的xpath表达式，通过表达式可以直接获取对应位置的值。基本用法如下</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;name\&quot;:\&quot;小明\&quot;,\&quot;class\&quot;:\&quot;小学一年级\&quot;,\&quot;school\&quot;:&#123;\&quot;name\&quot;:\&quot;xx小学\&quot;,\&quot;address\&quot;:\&quot;北京\&quot;&#125;&#125;&quot;</span>;<br><span class="hljs-type">JsonObject</span> <span class="hljs-variable">entries</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonObject</span>(json);<br><br><br><span class="hljs-type">JsonPointer</span> <span class="hljs-variable">append</span> <span class="hljs-operator">=</span> JsonPointer.from(<span class="hljs-string">&quot;/school/address&quot;</span>); <span class="hljs-comment">//创建指针，指定路径</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> append.queryJson(entries);  <span class="hljs-comment">//用该指针，查询上面的json</span><br>System.out.println(o); <span class="hljs-comment">//获取查询到的结果 ‘北京’</span><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>vertx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis 找不到statement</title>
    <link href="/3441268053.html"/>
    <url>/3441268053.html</url>
    
    <content type="html"><![CDATA[<h1 id="mybatis-找不到statement-“Mapped-Statements-collection-does-not-contain-value-for-xx-“"><a href="#mybatis-找不到statement-“Mapped-Statements-collection-does-not-contain-value-for-xx-“" class="headerlink" title="mybatis 找不到statement “Mapped Statements collection does not contain value for xx “"></a>mybatis 找不到statement “Mapped Statements collection does not contain value for xx “</h1><h3 id="我发生这样的原因是因为我的扫描配置的是-‘classpath-mapper-Mapper-xml’-而我后面新建的mapper文件命名是，userMapperEx-xml-导致命名和通配命名不一致，扫描不到。在此记录一下。"><a href="#我发生这样的原因是因为我的扫描配置的是-‘classpath-mapper-Mapper-xml’-而我后面新建的mapper文件命名是，userMapperEx-xml-导致命名和通配命名不一致，扫描不到。在此记录一下。" class="headerlink" title="我发生这样的原因是因为我的扫描配置的是 ‘classpath:mapper&#x2F;*Mapper.xml’ ,而我后面新建的mapper文件命名是，userMapperEx.xml 导致命名和通配命名不一致，扫描不到。在此记录一下。"></a>我发生这样的原因是因为我的扫描配置的是 ‘classpath:mapper&#x2F;*Mapper.xml’ ,而我后面新建的mapper文件命名是，userMapperEx.xml 导致命名和通配命名不一致，扫描不到。在此记录一下。</h3>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>thymeleaf 自定义表达式,静态方法</title>
    <link href="/2860358226.html"/>
    <url>/2860358226.html</url>
    
    <content type="html"><![CDATA[<h2 id="thymeleaf-自定义表达式-静态方法"><a href="#thymeleaf-自定义表达式-静态方法" class="headerlink" title="thymeleaf 自定义表达式,静态方法"></a>thymeleaf 自定义表达式,静态方法</h2><h3 id="1-模板内置了一些方法，比如格式化时间的"><a href="#1-模板内置了一些方法，比如格式化时间的" class="headerlink" title="1.模板内置了一些方法，比如格式化时间的"></a>1.模板内置了一些方法，比如格式化时间的</h3><pre><code class="hljs">$&#123;#dates.format(article.date,&#39;yyyy-MM-dd HH:mm&#39;)&#125;</code></pre><p>但有时候不满足我们的需求，需要自定义方法。</p><h3 id="2-需求，遍历list，拼接list中对象的某个字段，以逗号分隔"><a href="#2-需求，遍历list，拼接list中对象的某个字段，以逗号分隔" class="headerlink" title="2.需求，遍历list，拼接list中对象的某个字段，以逗号分隔"></a>2.需求，遍历list，拼接list中对象的某个字段，以逗号分隔</h3><pre><code class="hljs">如：List&lt;People&gt; list = new ArrayList&lt;&gt;();list.add(new People(1,&quot;小明&quot;));list.add(new People(2,&quot;小李&quot;));list.add(new People(3,&quot;小红&quot;));list.add(new People(4,&quot;小张&quot;));现在想在页面上得到 “小明，小李，小红，小张” 这样拼接的字符串在内置函数是无法做到这一点的</code></pre><h3 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3.解决方法"></a>3.解决方法</h3><h4 id="3-1-写静态方法"><a href="#3-1-写静态方法" class="headerlink" title="3.1 写静态方法"></a>3.1 写静态方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/*遍历集合，找到name对应的字段，并用 separator 拼接成字符串*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IString</span> &#123;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">joinObjects</span><span class="hljs-params">(List&lt;Object&gt; list, String name, String separator)</span> &#123;<br>List&lt;String&gt; tempList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list.size());<br><span class="hljs-keyword">for</span> (Object o : list) &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">property</span> <span class="hljs-operator">=</span> BeanUtils.getSimpleProperty(o, name);<br><span class="hljs-keyword">if</span> (StringUtils.isNotBlank(property)) &#123;<br>tempList.add(property);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> StringUtils.join(tempList.iterator(), separator);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-写一个表达式配置工厂，这个类对于多个表达式可以通用"><a href="#3-2-写一个表达式配置工厂，这个类对于多个表达式可以通用" class="headerlink" title="3.2 写一个表达式配置工厂，这个类对于多个表达式可以通用"></a>3.2 写一个表达式配置工厂，这个类对于多个表达式可以通用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IExpressionFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IExpressionObjectFactory</span> &#123;<br><br><span class="hljs-comment">//缓存下</span><br><span class="hljs-keyword">private</span> Map&lt;String, Object&gt; map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">IExpressionFactory</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span> &#123;<br><span class="hljs-built_in">this</span>.map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(map);<br>&#125;<br><br><span class="hljs-comment">/*获取表达式名字set集合*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title function_">getAllExpressionObjectNames</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> map.keySet();<br>&#125;<br><span class="hljs-comment">/*根据表达式名字获取表达式对象*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">buildObject</span><span class="hljs-params">(IExpressionContext context, String expressionObjectName)</span> &#123;<br><span class="hljs-keyword">return</span> map.get(expressionObjectName);<br>&#125;<br><span class="hljs-comment">//是否允许缓存</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCacheable</span><span class="hljs-params">(String expressionObjectName)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="3-3-将上面的表达式工厂配置到springboot中"><a href="#3-3-将上面的表达式工厂配置到springboot中" class="headerlink" title="3.3 将上面的表达式工厂配置到springboot中"></a>3.3 将上面的表达式工厂配置到springboot中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IExpressionFactoryDialect</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractDialect</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IExpressionObjectDialect</span> &#123;<br><br><span class="hljs-comment">//表达式配置工厂</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IExpressionObjectFactory iExpressionFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">IExpressionFactoryDialect</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;hcyExpression&quot;</span>);<br><span class="hljs-comment">//map中可以多个</span><br>Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-comment">//配置我们刚才写的工具类，key为页面上引用的名字</span><br>map.put(<span class="hljs-string">&quot;iStrings&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IString</span>());<br>iExpressionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IExpressionFactory</span>(map);<br>&#125;<br><br><span class="hljs-comment">/*返回工厂*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> IExpressionObjectFactory <span class="hljs-title function_">getExpressionObjectFactory</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> iExpressionFactory;<br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="3-4-使用"><a href="#3-4-使用" class="headerlink" title="3.4 使用"></a>3.4 使用</h4><pre><code class="hljs">$&#123;#iStrings.joinObjects(articles,&#39;title&#39;,&#39;,&#39;) &#125;页面上采用 #iStrings的方式引用该对象，传递参数（list，name，分隔符） ，可以获取获取list中对象的title字段 拼接得到的字符串</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>servlet-mapping 路径配置 斜杠、斜杠星区别</title>
    <link href="/3472592907.html"/>
    <url>/3472592907.html</url>
    
    <content type="html"><![CDATA[<h1 id="servlet-mapping-路径配置怎么配，-区别"><a href="#servlet-mapping-路径配置怎么配，-区别" class="headerlink" title="servlet-mapping 路径配置怎么配， / /* 区别"></a>servlet-mapping 路径配置怎么配， <code>/</code> <code>/*</code> 区别</h1><h2 id="1-匹配规则"><a href="#1-匹配规则" class="headerlink" title="1.匹配规则"></a>1.匹配规则</h2><pre><code class="hljs">/xx 表示精准匹配xx路径*.action 表示匹配action为后缀的/ 表示匹配所有路径，优先级较低/* 匹配所有路径 优先级小于 /xx这种精准匹配，小于/xx/*这种路径比他更为精准的匹配 大于*.action这种后缀匹配，这将导致一些问题</code></pre><hr><h2 id="2-默认servlet处理静态资源和jsp，为什么什么都不写也能访问静态资源和jsp"><a href="#2-默认servlet处理静态资源和jsp，为什么什么都不写也能访问静态资源和jsp" class="headerlink" title="2.默认servlet处理静态资源和jsp，为什么什么都不写也能访问静态资源和jsp"></a>2.默认servlet处理静态资源和jsp，为什么什么都不写也能访问静态资源和jsp</h2><pre><code class="hljs">因为: tomcat容器自带两个servlet，请查看tomcat的web.xml（非项目的），里面写着两个servlet分别是//默认的servlet 名字叫default&lt;servlet&gt;&lt;servlet-name&gt;default&lt;/servlet-name&gt;&lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt;&lt;init-param&gt;  &lt;param-name&gt;debug&lt;/param-name&gt;  &lt;param-value&gt;0&lt;/param-value&gt;&lt;/init-param&gt;&lt;init-param&gt;  &lt;param-name&gt;listings&lt;/param-name&gt;  &lt;param-value&gt;false&lt;/param-value&gt;&lt;/init-param&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;//默认的servlet 名字叫jsp&lt;servlet&gt;&lt;servlet-name&gt;jsp&lt;/servlet-name&gt;&lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt;&lt;init-param&gt;  &lt;param-name&gt;classdebuginfo&lt;/param-name&gt;  &lt;param-value&gt;true&lt;/param-value&gt;&lt;/init-param&gt;&lt;init-param&gt;  &lt;param-name&gt;fork&lt;/param-name&gt;  &lt;param-value&gt;false&lt;/param-value&gt;&lt;/init-param&gt;&lt;init-param&gt;  &lt;param-name&gt;xpoweredBy&lt;/param-name&gt;  &lt;param-value&gt;false&lt;/param-value&gt;&lt;/init-param&gt;&lt;load-on-startup&gt;3&lt;/load-on-startup&gt;&lt;/servlet&gt;</code></pre><h2 id="他们拦截路径分别是"><a href="#他们拦截路径分别是" class="headerlink" title="他们拦截路径分别是"></a>他们拦截路径分别是</h2><pre><code class="hljs">&lt;servlet-mapping&gt;&lt;servlet-name&gt;default&lt;/servlet-name&gt;&lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;//jsp 拦截&lt;servlet-mapping&gt;&lt;servlet-name&gt;jsp&lt;/servlet-name&gt;&lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;&lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><blockquote><p>可以看出default servlet 默认情况下处理webapp目录下的静态文件，比如我们放一张图片或一个css文件在webapp目录下可以直接访问<br>  jsp servlet 处理webapp目录下的*.jsp文件，这样我们不用写任何代码就能访问jsp文件</p></blockquote><hr><h2 id="3-配置springmvc，如何不影响静态资源访问"><a href="#3-配置springmvc，如何不影响静态资源访问" class="headerlink" title="3.配置springmvc，如何不影响静态资源访问"></a>3.配置springmvc，如何不影响静态资源访问</h2><h3 id="3-1-配置方式1"><a href="#3-1-配置方式1" class="headerlink" title="3.1 配置方式1"></a>3.1 配置方式1</h3><pre><code class="hljs">&lt;servlet-mapping&gt;&lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;&lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;我们配置springmvc为  *.do 等行使的路径。这样可以将我们的请求与tomcat默认的分开，相互不影响。</code></pre><h3 id="3-2-配置方式2-，我们不希望带任何后缀"><a href="#3-2-配置方式2-，我们不希望带任何后缀" class="headerlink" title="3.2 配置方式2 ，我们不希望带任何后缀"></a>3.2 配置方式2 ，我们不希望带任何后缀</h3><pre><code class="hljs">&lt;servlet-mapping&gt;&lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;&lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;相当于覆盖了tomcat的default servlet，这样不需要任何后缀就可以访问dispatcher，但是此时带来的后果就是，无法处理静态资源.此时放在webapp目录下的css js jpg 等文件没有servlet处理，所以无法访问</code></pre><h4 id="3-2-1解决办法"><a href="#3-2-1解决办法" class="headerlink" title="3.2.1解决办法"></a>3.2.1解决办法</h4><pre><code class="hljs">我们可以将静态资源后缀指定使用default servlet拦截&lt;servlet-mapping&gt;&lt;servlet-name&gt;default&lt;/servlet-name&gt;&lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;default&lt;/servlet-name&gt;&lt;url-pattern&gt;*.css&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;这样将常用后缀的静态资源主动交给deafault处理，就可以了</code></pre><h2 id="4-带来的问题"><a href="#4-带来的问题" class="headerlink" title="4 &#x2F;*带来的问题"></a>4 &#x2F;*带来的问题</h2><pre><code class="hljs">一般不要将拦截范围设为 /*他将导致拦截范围过于宽，比如如下这样设置&lt;servlet-mapping&gt;&lt;servlet-name&gt;A&lt;/servlet-name&gt;&lt;url-pattern&gt;/test&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;A1&lt;/servlet-name&gt;&lt;url-pattern&gt;/test/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;B&lt;/servlet-name&gt;&lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;C&lt;/servlet-name&gt;&lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;D&lt;/servlet-name&gt;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><h4 id="得到结果-请求"><a href="#得到结果-请求" class="headerlink" title="得到结果 请求"></a>得到结果 请求</h4><pre><code class="hljs">localhost/test --&gt;Alocalhost/test/xyz --&gt;A1localhost/xyz   --&gt;Dlocalhost/xyz.do    --&gt;Dlocalhost/   --&gt;D可以看到 /*的拦截优先级太高，除了精准匹配和次精准匹配外，其他如 *.do 这种类型不起作用，/也不起作用。从而导致默认静态文件无法访问，默认jsp文件无法访问，servlet请求转发到jsp无法实现。从而各种404所以千万不要使用 /*， 不想要接口链接有后缀的，可以用 3.2节的解决办法即可</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用nginx后，后端无法获取真实ip</title>
    <link href="/4018746505.html"/>
    <url>/4018746505.html</url>
    
    <content type="html"><![CDATA[<h1 id="使用nginx后，后端无法获取真实ip"><a href="#使用nginx后，后端无法获取真实ip" class="headerlink" title="使用nginx后，后端无法获取真实ip"></a>使用nginx后，后端无法获取真实ip</h1><h3 id="因为nginx-是反代，后端获取的请求是nginx发出的，所以获取到的总是127-0-0-1-或者0-0-0-0-0-1"><a href="#因为nginx-是反代，后端获取的请求是nginx发出的，所以获取到的总是127-0-0-1-或者0-0-0-0-0-1" class="headerlink" title="因为nginx 是反代，后端获取的请求是nginx发出的，所以获取到的总是127.0.0.1 或者0:0:0:0:0:1"></a>因为nginx 是反代，后端获取的请求是nginx发出的，所以获取到的总是127.0.0.1 或者0:0:0:0:0:1</h3><h3 id="解决方法就是在nginx配置文件中配置添加请求头为原始请求头即可"><a href="#解决方法就是在nginx配置文件中配置添加请求头为原始请求头即可" class="headerlink" title="解决方法就是在nginx配置文件中配置添加请求头为原始请求头即可"></a>解决方法就是在nginx配置文件中配置添加请求头为原始请求头即可</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br><span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br><span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br></code></pre></td></tr></table></figure><h2 id="将上面配置放在-nginx-conf的http块中即可"><a href="#将上面配置放在-nginx-conf的http块中即可" class="headerlink" title="将上面配置放在 nginx.conf的http块中即可"></a>将上面配置放在 nginx.conf的http块中即可</h2>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>（转）nginx rewrite location 内置全局变量</title>
    <link href="/4223803474.html"/>
    <url>/4223803474.html</url>
    
    <content type="html"><![CDATA[<h1 id="（转）nginx-rewrite-location-内置全局变量"><a href="#（转）nginx-rewrite-location-内置全局变量" class="headerlink" title="（转）nginx rewrite location 内置全局变量"></a>（转）nginx rewrite location 内置全局变量</h1><pre><code class="hljs">$args ：这个变量等于请求行中的参数，同$query_string$content_length ： 请求头中的Content-length字段。$content_type ： 请求头中的Content-Type字段。$document_root ： 当前请求在root指令中指定的值。$host ： 请求主机头字段，否则为服务器名称。$http_user_agent ： 客户端agent信息$http_cookie ： 客户端cookie信息$limit_rate ： 这个变量可以限制连接速率。$request_method ： 客户端请求的动作，通常为GET或POST。$remote_addr ： 客户端的IP地址。$remote_port ： 客户端的端口。$remote_user ： 已经经过Auth Basic Module验证的用户名。$request_filename ： 当前请求的文件路径，由root或alias指令与URI请求生成。$scheme ： HTTP方法（如http，https）。$server_protocol ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。$server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值。$server_name ： 服务器名称。$server_port ： 请求到达服务器的端口号。$request_uri ： 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。$uri ： 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。$document_uri ： 与$uri相同。</code></pre><h3 id="原文地址点我"><a href="#原文地址点我" class="headerlink" title="原文地址点我"></a><a href="https://www.cnblogs.com/bass6/p/5732707.html">原文地址点我</a></h3>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Xshell6 Xftp6 强制升级</title>
    <link href="/1971814338.html"/>
    <url>/1971814338.html</url>
    
    <content type="html"><![CDATA[<h1 id="解决-Xshell6-Xftp6-强制升级"><a href="#解决-Xshell6-Xftp6-强制升级" class="headerlink" title="解决 Xshell6|Xftp6 强制升级"></a>解决 Xshell6|Xftp6 强制升级</h1><hr><h3 id="今天打开xftp，发现不让用了，要继续使用此程序，您必须应用最新的更新或使用新版本，必须强制升级，网上找到了xshell5去除强制升级的方法，但是把原文分享的文件替换，却打不开了，应该是xshell5-和sehll6-不兼容导致的"><a href="#今天打开xftp，发现不让用了，要继续使用此程序，您必须应用最新的更新或使用新版本，必须强制升级，网上找到了xshell5去除强制升级的方法，但是把原文分享的文件替换，却打不开了，应该是xshell5-和sehll6-不兼容导致的" class="headerlink" title="今天打开xftp，发现不让用了，要继续使用此程序，您必须应用最新的更新或使用新版本，必须强制升级，网上找到了xshell5去除强制升级的方法，但是把原文分享的文件替换，却打不开了，应该是xshell5 和sehll6 不兼容导致的."></a>今天打开xftp，发现不让用了，<code>要继续使用此程序，您必须应用最新的更新或使用新版本</code>，必须强制升级，网上找到了xshell5去除强制升级的方法，但是把原文分享的文件替换，却打不开了，应该是xshell5 和sehll6 不兼容导致的.</h3><h3 id="按照反编译操作，发现能解决问题，下面将步骤和文件放出"><a href="#按照反编译操作，发现能解决问题，下面将步骤和文件放出" class="headerlink" title="按照反编译操作，发现能解决问题，下面将步骤和文件放出"></a>按照反编译操作，发现能解决问题，下面将步骤和文件放出</h3><h3 id="原理是反编译文件，修改其中某个16进制再替换原文件"><a href="#原理是反编译文件，修改其中某个16进制再替换原文件" class="headerlink" title="原理是反编译文件，修改其中某个16进制再替换原文件"></a>原理是反编译文件，修改其中某个16进制再替换原文件</h3><pre><code class="hljs">1. 找到安装目录的 `nslicense.dll`文件复制出来2. 下载c32asm3. 用c32asm以16进制形式打开nslicense4. 搜索16进制： 7F0C81F98033E1010F86805. 替换成 ： 7F0C81F98033E1010F83806. 也就是将最后两位86替换成83 然后保存，并替换文件7. 如果搜不到7F0C81F98033E1010F8680 可以缩短几位进行搜索 比如搜索7F0C81F98033E101试试看</code></pre><h2 id="这是xshll5的做法，xshell6有点变化，但只要找到对应位置的86改成83即可，亲测可用"><a href="#这是xshll5的做法，xshell6有点变化，但只要找到对应位置的86改成83即可，亲测可用" class="headerlink" title="这是xshll5的做法，xshell6有点变化，但只要找到对应位置的86改成83即可，亲测可用"></a>这是xshll5的做法，xshell6有点变化，但只要找到对应位置的86改成83即可，亲测可用</h2><p>下面放出我用的修改好的文件，可以替换到xshll安装目录 和 xftp的安装目录，或者自己按照上面方法进行修改</p><p>链接：<a href="https://pan.baidu.com/s/1hZ7iAgi87lWKa_7qVaIY7w">https://pan.baidu.com/s/1hZ7iAgi87lWKa_7qVaIY7w </a></p><p>提取码：431e</p>]]></content>
    
    
    
    <tags>
      
      <tag>xshll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh远程端口转发到本地，微信开发，内网映射</title>
    <link href="/196472165.html"/>
    <url>/196472165.html</url>
    
    <content type="html"><![CDATA[<h1 id="ssh远程端口转发到本地，微信开发，内网映射"><a href="#ssh远程端口转发到本地，微信开发，内网映射" class="headerlink" title="ssh远程端口转发到本地，微信开发，内网映射"></a>ssh远程端口转发到本地，微信开发，内网映射</h1><h2 id="微信开发，需要公网ip，想要达到的目的是访问服务器指定端口，可以将请求映射到本地的服务器"><a href="#微信开发，需要公网ip，想要达到的目的是访问服务器指定端口，可以将请求映射到本地的服务器" class="headerlink" title="微信开发，需要公网ip，想要达到的目的是访问服务器指定端口，可以将请求映射到本地的服务器"></a>微信开发，需要公网ip，想要达到的目的是访问服务器指定端口，可以将请求映射到本地的服务器</h2><h3 id="需要条件：1-公网服务器"><a href="#需要条件：1-公网服务器" class="headerlink" title="需要条件：1.公网服务器"></a>需要条件：1.公网服务器</h3><h3 id="需要软件：2-xshell"><a href="#需要软件：2-xshell" class="headerlink" title="需要软件：2.xshell"></a>需要软件：2.xshell</h3><p>#步骤：<br>1.打开xshell 选择新建<br>2.选择‘连接选项卡’ 输入主机ip，协议选ssh，端口默认22<br>3.切换到‘用户身份验证’ 选项卡，输入用户名，密码<br>4.切换到 ‘隧道’选项卡，点击添加按钮，<br>4.1类型选择 ‘远程（传入）’<br>4.2源主机输入服务器ip<br>4.3侦听端口选择服务器监听端口<br>4.4不要勾选“仅接受本地连接”<br>4.5目标主机输入localhost<br>4.6目标端口输入本地监听端口</p><pre><code class="hljs">5.保存，并连上服务器</code></pre><h2 id="本地开启一个服务器用于测试。"><a href="#本地开启一个服务器用于测试。" class="headerlink" title="本地开启一个服务器用于测试。"></a>本地开启一个服务器用于测试。</h2><h2 id="不出意外的话，访问远程服务器的指定端口，能转发到本地的服务器上，类似于ngrok-frp。"><a href="#不出意外的话，访问远程服务器的指定端口，能转发到本地的服务器上，类似于ngrok-frp。" class="headerlink" title="不出意外的话，访问远程服务器的指定端口，能转发到本地的服务器上，类似于ngrok frp。"></a>不出意外的话，访问远程服务器的指定端口，能转发到本地的服务器上，类似于ngrok frp。</h2><h1 id="如果连不通，请检查远程端口是否开放，防火墙等问题。"><a href="#如果连不通，请检查远程端口是否开放，防火墙等问题。" class="headerlink" title="如果连不通，请检查远程端口是否开放，防火墙等问题。"></a>如果连不通，请检查远程端口是否开放，防火墙等问题。</h1>]]></content>
    
    
    
    <tags>
      
      <tag>微信</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>adb 控制手机屏幕滑动</title>
    <link href="/2645512854.html"/>
    <url>/2645512854.html</url>
    
    <content type="html"><![CDATA[<h1 id="adb-控制手机屏幕滑动"><a href="#adb-控制手机屏幕滑动" class="headerlink" title="adb 控制手机屏幕滑动"></a>adb 控制手机屏幕滑动</h1><pre><code class="hljs">//滑动adb shell input touchscreen swipe 930 880 930 380 //向上滑adb shell input touchscreen swipe 930 880 330 880 //向左滑adb shell input touchscreen swipe 330 880 930 880 //向右滑adb shell input touchscreen swipe 930 380 930 880 //向下滑//点击屏幕adb shell input mouse tap 990 1221</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql 存emoji表情,使用mybatic 读取写入</title>
    <link href="/1777974459.html"/>
    <url>/1777974459.html</url>
    
    <content type="html"><![CDATA[<h1 id="mysql-存emoji表情-使用mybatis-读取写入"><a href="#mysql-存emoji表情-使用mybatis-读取写入" class="headerlink" title="mysql 存emoji表情,使用mybatis 读取写入"></a>mysql 存emoji表情,使用mybatis 读取写入</h1><h2 id="设置mysql编码"><a href="#设置mysql编码" class="headerlink" title="设置mysql编码"></a>设置mysql编码</h2><p>​        首先把<code>mysql</code>对应的行的编码改成<code>utf8mb4</code>,不用改整个表或库,只需改这一行的编码格式就可以了<br>我是通过<code>navicat</code>修改的.</p><h2 id="驱动版本"><a href="#驱动版本" class="headerlink" title="驱动版本"></a>驱动版本</h2><p>​         数据库连接驱动最低版本 5.1.47，经测试低于这个版本，不能成功。</p><h2 id="设置数据库连接"><a href="#设置数据库连接" class="headerlink" title="设置数据库连接"></a>设置数据库连接</h2><p>​        连接内设置编码</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">jdbc</span>:<span class="hljs-string">mysql://127.0.0.1/testuseUnicode=true&amp;characterEncoding=UTF8&amp;mysqlEncoding=utf8</span><br></code></pre></td></tr></table></figure><h2 id="配置连接池参数"><a href="#配置连接池参数" class="headerlink" title="配置连接池参数"></a>配置连接池参数</h2><p>​        每个连接吃都有init参数,Springboot + hikari可以这么配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.hikari.connection-init-sql</span>=<span class="hljs-string">set names utf8mb4</span><br></code></pre></td></tr></table></figure><p>不出意外应该可以读写emoji表情了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>mybatis</tag>
      
      <tag>技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HttpClient Fluent API使用方法</title>
    <link href="/2005901105.html"/>
    <url>/2005901105.html</url>
    
    <content type="html"><![CDATA[<h1 id="HttpClient-Fluent-API使用方法"><a href="#HttpClient-Fluent-API使用方法" class="headerlink" title="HttpClient Fluent API使用方法"></a>HttpClient Fluent API使用方法</h1><h3 id="1-加入-maven"><a href="#1-加入-maven" class="headerlink" title="1.加入 maven"></a>1.加入 maven</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs maven"><br> &lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;<br>    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;<br>    &lt;version&gt;4.5.8&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;<br>    &lt;artifactId&gt;fluent-hc&lt;/artifactId&gt;<br>    &lt;version&gt;4.5.8&lt;/version&gt;<br>&lt;/dependency&gt;<br><br></code></pre></td></tr></table></figure><h3 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2.基本用法"></a>2.基本用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>Request.Get(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>)<br>.execute()<br>.handleResponse(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseHandler</span>&lt;String&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">handleResponse</span><span class="hljs-params">(HttpResponse response)</span> <span class="hljs-keyword">throws</span> ClientProtocolException, IOException &#123;<br><span class="hljs-keyword">return</span> EntityUtils.toString(response.getEntity(), <span class="hljs-string">&quot;utf-8&quot;</span>);<br>&#125;<br>&#125;);<br><br></code></pre></td></tr></table></figure><h3 id="3-额外参数"><a href="#3-额外参数" class="headerlink" title="3.额外参数"></a>3.额外参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Request.Get(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>)<br>.connectTimeout(<span class="hljs-number">3000</span>)<br>.addHeader(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>)<br>.userAgent(<span class="hljs-string">&quot;test&quot;</span>)<br>.execute();<br><br></code></pre></td></tr></table></figure><h3 id="4-post"><a href="#4-post" class="headerlink" title="4.post"></a>4.post</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*添加一个post参数*/</span><br><span class="hljs-type">BasicNameValuePair</span> <span class="hljs-variable">pair</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BasicNameValuePair</span>(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;hh&quot;</span>);<br>Request.Post(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>)<br>.connectTimeout(<span class="hljs-number">3000</span>)<br>.bodyForm(pair)<br>.execute();<br></code></pre></td></tr></table></figure><h3 id="5-post-json"><a href="#5-post-json" class="headerlink" title="5.post json"></a>5.post json</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Request.Post(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>)<br>.connectTimeout(<span class="hljs-number">3000</span>)<br>.bodyString(JSON.toJSONString(<span class="hljs-keyword">var</span>), ContentType.APPLICATION_JSON)<br>.execute();<br><br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Request.Post(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br>.useExpectContinue()<br>.version(HttpVersion.HTTP_1_1)<br>.bodyString(<span class="hljs-string">&quot;啦啦啦&quot;</span>, ContentType.DEFAULT_TEXT)<br>.execute();<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将逐帧加载的图片转变成 模糊慢慢清楚的形式</title>
    <link href="/3278664172.html"/>
    <url>/3278664172.html</url>
    
    <content type="html"><![CDATA[<h1 id="将逐帧加载的图片转变成-模糊慢慢清楚的形式"><a href="#将逐帧加载的图片转变成-模糊慢慢清楚的形式" class="headerlink" title="将逐帧加载的图片转变成 模糊慢慢清楚的形式"></a>将逐帧加载的图片转变成 模糊慢慢清楚的形式</h1><h3 id="关键词：Progressive"><a href="#关键词：Progressive" class="headerlink" title="关键词：Progressive"></a>关键词：Progressive</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-comment">/*逐帧加载的图片转变成画质加载的形式*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">switchPic</span><span class="hljs-params">(String source, String target)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br><span class="hljs-comment">/*删除目标文件夹*/</span><br><span class="hljs-keyword">if</span> (Files.exists(Paths.get(target))) &#123;<br>Files.delete(Paths.get(target));<br>&#125;<br><br><span class="hljs-comment">/*读取图片*/</span><br><span class="hljs-type">BufferedImage</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> ImageIO.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(source));<br><br><span class="hljs-comment">/*创建write*/</span><br><span class="hljs-type">JPEGImageWriter</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPEGImageWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JPEGImageWriterSpi</span>());<br>w.setOutput(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileImageOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(target)));<br><br><span class="hljs-comment">/*修改参数，顺便压缩下*/</span><br><span class="hljs-type">ImageWriteParam</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> w.getDefaultWriteParam();<br>p.setProgressiveMode(ImageWriteParam.MODE_COPY_FROM_METADATA);<br>p.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);<br>p.setCompressionQuality(<span class="hljs-number">0.7F</span>);<br><br><span class="hljs-comment">/*写入文件*/</span><br>w.write(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IIOImage</span>(read, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>), p);<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="可以讲图片放入nginx下，利用chrome-将网速调慢，可以看出，转变前是-逐行加载的形式，转变后是由模糊慢慢变清楚的形式"><a href="#可以讲图片放入nginx下，利用chrome-将网速调慢，可以看出，转变前是-逐行加载的形式，转变后是由模糊慢慢变清楚的形式" class="headerlink" title="可以讲图片放入nginx下，利用chrome 将网速调慢，可以看出，转变前是 逐行加载的形式，转变后是由模糊慢慢变清楚的形式"></a>可以讲图片放入nginx下，利用chrome 将网速调慢，可以看出，转变前是 逐行加载的形式，转变后是由模糊慢慢变清楚的形式</h2>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx rewrite实现restful风格页面</title>
    <link href="/2285636061.html"/>
    <url>/2285636061.html</url>
    
    <content type="html"><![CDATA[<h1 id="nginx-rewrite实现restful风格页面"><a href="#nginx-rewrite实现restful风格页面" class="headerlink" title="nginx rewrite实现restful风格页面"></a>nginx rewrite实现restful风格页面</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><pre><code class="hljs">问题描述： 现在后端采用nginx 动静分离。某一页面地址如“www.example.com/article.html?page=1”所示，通过get参数传递到页面，再在页面上解析参数，通过ajax获取到内容展示出来。但该类网址是url相同的只是参数不同。想要改成如“www.example.com/page1.html” 这种类型的url,页面还是同一个页面，但是看起来像拥有多个页面一样。</code></pre><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><pre><code class="hljs">让nginx 解析url，匹配出所有的 `www.example.com/page*.html` 形式的url，统统返回给前端相同的页面。</code></pre><h2 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx">// 这是以前的配置，所有静态页面从指定文件夹寻找<br><span class="hljs-section">location</span> / &#123;<br><span class="hljs-attribute">root</span> /home/html/;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span> 修改后的配置如下<br>location / &#123;<br>rewrite <span class="hljs-string">/page</span><span class="hljs-params">([0-9]+?)</span>\<span class="hljs-string">.html</span> <span class="hljs-string">/article.html</span> break;<br>root <span class="hljs-string">/home/html/</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><pre><code class="hljs">rewrite [正则表达式 替换前的URL] [替换后的URL] [标识];在匹配资源时将所有rewrite第一个参数正则匹配的链接，替换成第二个参数指定的地址。我这里是将 /page(若干个数字).html 替换成 /article.html ，这样就符合要求了</code></pre><h2 id="标识的类型和解释"><a href="#标识的类型和解释" class="headerlink" title="标识的类型和解释"></a>标识的类型和解释</h2><p>标识可取以下几种类型 </p><table><thead><tr><th>标识</th><th>作用</th></tr></thead><tbody><tr><td>last</td><td>停止rewrite的检测</td></tr><tr><td>break</td><td>停止rewrite的检测</td></tr><tr><td>redirect</td><td>返回302临时重定向，浏览器重新跳转</td></tr><tr><td>permanent</td><td>返回301永久重定向，浏览器会重新跳转</td></tr></tbody></table><p>** break 表示进行rewrite完成后，拿着新的url在该location内部进行匹配，也就是在下面的root里面去寻找资源。**</p><p>** last 不但在该location下进行匹配，还会跳出该location 去其他location进行匹配。**</p><pre><code class="hljs">正则表达式可以自由发挥，功能很强到多数都是支持的，如果访问不通，可以去nginx下面的log/error.log 里面找找日志看看</code></pre><h2 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h2><p><a href="https://blog.csdn.net/ip_JL/article/details/84422124">Nginx高级之Rewrite规则</a></p><p><a href="https://www.runoob.com/regexp/regexp-syntax.html">正则表达式</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>apache.commons.lang3 优雅的解决为空则返回默认值功能</title>
    <link href="/1321738366.html"/>
    <url>/1321738366.html</url>
    
    <content type="html"><![CDATA[<h2 id="apache-commons-lang3-优雅的解决为空则返回默认值功能"><a href="#apache-commons-lang3-优雅的解决为空则返回默认值功能" class="headerlink" title="apache.commons.lang3 优雅的解决为空则返回默认值功能"></a>apache.commons.lang3 优雅的解决为空则返回默认值功能</h2><p>&#96;</p><pre><code class="hljs">//示例// java 7 中没有getOrDefault,用这个方法将就一下import org.apache.commons.lang3.ObjectUtils;ObjectUtils.defaultIfNull(map.get(d1),new Date());</code></pre><p>&#96;</p>]]></content>
    
    
    
    <tags>
      
      <tag>apache.commons.lang3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql 开启远程登录,设置密码</title>
    <link href="/3537035799.html"/>
    <url>/3537035799.html</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql-开启远程登录"><a href="#Mysql-开启远程登录" class="headerlink" title="Mysql 开启远程登录"></a>Mysql 开启远程登录</h1><hr><h2 id="1-连接mysql"><a href="#1-连接mysql" class="headerlink" title="1.连接mysql"></a>1.连接mysql</h2><pre><code class="hljs">mysql -uroot -p</code></pre><h2 id="2-切换到mysql数据库"><a href="#2-切换到mysql数据库" class="headerlink" title="2.切换到mysql数据库"></a>2.切换到mysql数据库</h2><pre><code class="hljs">use mysql</code></pre><h2 id="3-查看当前root用户-其实就是user表的一条记录"><a href="#3-查看当前root用户-其实就是user表的一条记录" class="headerlink" title="3.查看当前root用户,(其实就是user表的一条记录)"></a>3.查看当前root用户,(其实就是user表的一条记录)</h2><pre><code class="hljs">select user,host from user</code></pre><h2 id="3-1-初始化密码（刚安装可能是没有密码的）"><a href="#3-1-初始化密码（刚安装可能是没有密码的）" class="headerlink" title="3.1 初始化密码（刚安装可能是没有密码的）"></a>3.1 初始化密码（刚安装可能是没有密码的）</h2><pre><code class="hljs">#如果没有初始化mysql密码的，可以使用下面语句#旧版本update user set password=PASSWORD(‘123456’) where User=&#39;root&#39;;#5.7以后的版本删除了password字段，改为authentication_stringupdate user set authentication_string=password(&#39;123456&#39;) where user=&#39;root&#39; ;</code></pre><h2 id="4-查看root这个用户的host是不是-‘-’-，如果不是则修改为"><a href="#4-查看root这个用户的host是不是-‘-’-，如果不是则修改为" class="headerlink" title="4.查看root这个用户的host是不是 ‘%’ ，如果不是则修改为%"></a>4.查看root这个用户的host是不是 ‘%’ ，如果不是则修改为%</h2><pre><code class="hljs">#将root用户的host列修改为 ‘%’ ，表示不限制远程连接的ipupdate user set host = &#39;%&#39; where user = &#39;root&#39;# 这里修改如果报“Duplicate entry &#39;%-root&#39; for key &#39;PRIMARY&#39;”的话，请查看表中是不是有多个root用户，可以删除只保留一个root 用户</code></pre><h2 id="5-修改root用户的权限"><a href="#5-修改root用户的权限" class="headerlink" title="5.修改root用户的权限"></a>5.修改root用户的权限</h2><pre><code class="hljs">#添加所有权限GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39;IDENTIFIED BY &#39;mypassword&#39; WITH GRANT OPTION;#刷新权限表FLUSH PRIVILEGES;</code></pre><h2 id="6-开通防火墙的3306端口，如果是阿里云需要在控制台开放3306端口"><a href="#6-开通防火墙的3306端口，如果是阿里云需要在控制台开放3306端口" class="headerlink" title="6.开通防火墙的3306端口，如果是阿里云需要在控制台开放3306端口"></a>6.开通防火墙的3306端口，如果是阿里云需要在控制台开放3306端口</h2><h2 id="7-修改-vi-etc-mysql-my-conf"><a href="#7-修改-vi-etc-mysql-my-conf" class="headerlink" title="7.修改 vi &#x2F;etc&#x2F;mysql&#x2F;my.conf"></a>7.修改 vi &#x2F;etc&#x2F;mysql&#x2F;my.conf</h2><pre><code class="hljs">#如果存在这一行就删除掉，或者将绑定的ip改成0.0.0.0，#如果没有此配置，看一下 /etc/mysql/mysql.conf.d/mysqld.cnf 这个里面删除 bind-address = 127.0.0.1</code></pre><h2 id="7-1-如果是5-7版本的mysql，请看一下"><a href="#7-1-如果是5-7版本的mysql，请看一下" class="headerlink" title="7.1 如果是5.7版本的mysql，请看一下"></a>7.1 如果是5.7版本的mysql，请看一下</h2><pre><code class="hljs">#如果还是不行，请修改以下这个配置文件，找到bind-address/etc/mysql/mysql.conf.d/mysqld.cnf</code></pre><h2 id="8-重启mysql"><a href="#8-重启mysql" class="headerlink" title="8.重启mysql"></a>8.重启mysql</h2><pre><code class="hljs">启动mysql：方式一：sudo /etc/init.d/mysql start 方式二：sudo service mysql start停止mysql：方式一：sudo /etc/init.d/mysql stop 方式二：sudo service mysql stop重启mysql：方式一：sudo/etc/init.d/mysql restart方式二：sudo service mysql restart</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openssl生成证书</title>
    <link href="/169366740.html"/>
    <url>/169366740.html</url>
    
    <content type="html"><![CDATA[<h1 id="openssl生成证书，配置nginx"><a href="#openssl生成证书，配置nginx" class="headerlink" title="openssl生成证书，配置nginx"></a>openssl生成证书，配置nginx</h1><hr><h2 id="所有文件和解释"><a href="#所有文件和解释" class="headerlink" title="所有文件和解释"></a>所有文件和解释</h2><pre><code class="hljs">.key  私钥.crt  证书文件.csr  证书申请时会用到的记录信息的文件</code></pre><h2 id="生成key-和-csr"><a href="#生成key-和-csr" class="headerlink" title="生成key 和 csr"></a>生成key 和 csr</h2><pre><code class="hljs">#openssl 在系统当前目录生成 key 和 csr文件openssl req -new -newkey rsa:2048 -sha256 -nodes -out example_com.csr -keyout example_com.key -subj &quot;/C=CN/ST=ShenZhen/L=ShenZhen/O=Example Inc./OU=Web Security/CN=example.com&quot;C：Country ，单位所在国家，为两位数的国家缩写，如： CN 就是中国ST 字段： State/Province ，单位所在州或省L 字段： Locality ，单位所在城市 / 或县区O 字段： Organization ，此网站的单位名称;OU 字段： Organization Unit，下属部门名称;也常常用于显示其他证书相关信息，如证书类型，证书产品名称或身份验证类型或验证内容等;CN 字段： Common Name ，网站的域名;</code></pre><h2 id="签署csr文件得到crt证书，就可以拿着crt证书和key-配置nginx了"><a href="#签署csr文件得到crt证书，就可以拿着crt证书和key-配置nginx了" class="headerlink" title="签署csr文件得到crt证书，就可以拿着crt证书和key 配置nginx了"></a>签署csr文件得到crt证书，就可以拿着crt证书和key 配置nginx了</h2><pre><code class="hljs">生成 csr 文件后，提供给 CA 机构，签署成功后，就会得到一個 example.crt 证书文件</code></pre><h2 id="如果只是测试使用可以自签名"><a href="#如果只是测试使用可以自签名" class="headerlink" title="如果只是测试使用可以自签名"></a>如果只是测试使用可以自签名</h2><pre><code class="hljs"># 使用下面命令，可以自签名证书openssl x509 -req -in example_com.csr -out example_com.crt -signkey example_com.key -days 3650</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql 完整改密码步骤</title>
    <link href="/2618678352.html"/>
    <url>/2618678352.html</url>
    
    <content type="html"><![CDATA[<h1 id="mysql-完整改密码步骤"><a href="#mysql-完整改密码步骤" class="headerlink" title="mysql 完整改密码步骤"></a>mysql 完整改密码步骤</h1><pre><code class="hljs">如果密码不小心忘记了，需要重置密码，请按照一下步骤来</code></pre><h2 id="1-vim-etc-my-cnf-加入skip-grant-tables"><a href="#1-vim-etc-my-cnf-加入skip-grant-tables" class="headerlink" title="1. vim &#x2F;etc&#x2F;my.cnf 加入skip-grant-tables"></a>1. vim &#x2F;etc&#x2F;my.cnf 加入skip-grant-tables</h2><pre><code class="hljs">注意5.7版本以上可能是 /etc/mysql/mysql.conf.d/mysqld.cnf 文件</code></pre><h2 id="重启mysql"><a href="#重启mysql" class="headerlink" title="重启mysql"></a>重启mysql</h2><pre><code class="hljs">/etc/init.d/mysql restart</code></pre><h2 id="无密码登录mysql-重设密码-（新版本和旧版本修改密码方式变了，请确定自己的版本）"><a href="#无密码登录mysql-重设密码-（新版本和旧版本修改密码方式变了，请确定自己的版本）" class="headerlink" title="无密码登录mysql,重设密码 （新版本和旧版本修改密码方式变了，请确定自己的版本）"></a>无密码登录mysql,重设密码 （新版本和旧版本修改密码方式变了，请确定自己的版本）</h2><pre><code class="hljs">mysql -uroot -puse mysql#旧版本update user set password=PASSWORD(‘123456’) where User=&#39;root&#39;;#5.7以后的版本删除了password字段，改为authentication_stringupdate user set authentication_string=password(&#39;123456&#39;) where user=&#39;root&#39; ;#如果还不可以请百度搜索 mysql5.7 修改密码</code></pre><h2 id="删除添加的skip-grant-tables-这一行"><a href="#删除添加的skip-grant-tables-这一行" class="headerlink" title="删除添加的skip-grant-tables 这一行"></a>删除添加的skip-grant-tables 这一行</h2><h2 id="重启mysql-1"><a href="#重启mysql-1" class="headerlink" title="重启mysql"></a>重启mysql</h2>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu 18 安装nginx</title>
    <link href="/3507292475.html"/>
    <url>/3507292475.html</url>
    
    <content type="html"><![CDATA[<h1 id="ubuntu-18-安装nginx"><a href="#ubuntu-18-安装nginx" class="headerlink" title="ubuntu 18 安装nginx"></a>ubuntu 18 安装nginx</h1><h2 id="安装nginx依赖"><a href="#安装nginx依赖" class="headerlink" title="安装nginx依赖"></a>安装nginx依赖</h2><h3 id="安装gcc"><a href="#安装gcc" class="headerlink" title="安装gcc"></a>安装gcc</h3><pre><code class="hljs">apt-get install build-essentialapt-get install libtool</code></pre><h3 id="安装pcre依赖库"><a href="#安装pcre依赖库" class="headerlink" title="安装pcre依赖库"></a>安装pcre依赖库</h3><pre><code class="hljs">sudo apt-get updatesudo apt-get install libpcre3 libpcre3-dev</code></pre><h3 id="安装zlib依赖库"><a href="#安装zlib依赖库" class="headerlink" title="安装zlib依赖库"></a>安装zlib依赖库</h3><pre><code class="hljs">apt-get install zlib1g-dev</code></pre><h3 id="安装ssl依赖库"><a href="#安装ssl依赖库" class="headerlink" title="安装ssl依赖库"></a>安装ssl依赖库</h3><pre><code class="hljs">apt-get install openssl</code></pre><h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><pre><code class="hljs">#下载nginxwget http://nginx.org/download/nginx-1.17.0.tar.gz#解压nginx （这个解压出来的文件夹，安装完成后也不要删除，以后再想配置还能用）tar -zxvf nginx-1.17.0.tar.gz#进入解压目录cd nginx-1.17.0#配置./configure --prefix=/usr/local/nginx#编辑nginx( 这里只是编译还没有安装)make注意：这里可能会报错，提示“pcre.h No such file or directory”,具体详见：http://stackoverflow.com/questions/22555561/error-building-fatal-error-pcre-h-no-such-file-or-directory需要安装 libpcre3-dev,命令为：sudo apt-get install libpcre3-dev#安装nginx（上面配置时，指定了安装位置）sudo make install启动nginx：sudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</code></pre><h2 id="nginx-常用命令"><a href="#nginx-常用命令" class="headerlink" title="nginx 常用命令"></a>nginx 常用命令</h2><pre><code class="hljs">启动/usr/local/nginx/sbin/nginx./sbin/nginx　停止./sbin/nginx -s stop重加载配置文件./sbin/nginx -s reload查看版本，和编译配置信息nginx -V</code></pre><h2 id="添加到环境变量"><a href="#添加到环境变量" class="headerlink" title="添加到环境变量"></a>添加到环境变量</h2><pre><code class="hljs">在/etc/profile 中加入：export NGINX_HOME=/usr/local/nginxexport PATH=$PATH:$NGINX_HOME/sbin保存，执行 source /etc/profile ，使配置文件生效</code></pre><h2 id="转载自–-这篇博客"><a href="#转载自–-这篇博客" class="headerlink" title="转载自–&gt; 这篇博客"></a>转载自–&gt; <a href="%22https://www.cnblogs.com/piscesLoveCc/p/5794926.html%22">这篇博客</a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为已安装的nginx 添加模块</title>
    <link href="/1956753180.html"/>
    <url>/1956753180.html</url>
    
    <content type="html"><![CDATA[<p>#为已安装的nginx 添加模块</p><hr><h2 id="假设nginx-安装目录-usr-local-nginx"><a href="#假设nginx-安装目录-usr-local-nginx" class="headerlink" title="假设nginx 安装目录 &#x2F;usr&#x2F;local&#x2F;nginx"></a>假设nginx 安装目录 &#x2F;usr&#x2F;local&#x2F;nginx</h2><h2 id="重新配置nginx"><a href="#重新配置nginx" class="headerlink" title="重新配置nginx"></a>重新配置nginx</h2><pre><code class="hljs">#上篇介绍，解压编译nginx的目录不要删除，从新进入那个目录#配置，再原来的基础上，又添加了新的配置，这里是ssl模块以前的配置 ./configure --prefix=/usr/local/nginx新配置 ./configure --prefix=/usr/local/nginx --with-http_ssl_module#编译（注意只是编译，并没有install）make#查看编译好的文件在objs目录下，找到编译好的nginx。#备份原nginxcp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak#复制新的nginxcp /usr/local/nginx-1.17.0/objs/nginx /usr/local/nginx/sbin/nginx</code></pre><h2 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h2><pre><code class="hljs">/usr/local/nginx/sbin/nginx</code></pre><h1 id="新模块已生效，可以进行对应的配置，我这里添加了ssl模块，就可以修改配置文件，启用ssl了"><a href="#新模块已生效，可以进行对应的配置，我这里添加了ssl模块，就可以修改配置文件，启用ssl了" class="headerlink" title="新模块已生效，可以进行对应的配置，我这里添加了ssl模块，就可以修改配置文件，启用ssl了"></a>新模块已生效，可以进行对应的配置，我这里添加了ssl模块，就可以修改配置文件，启用ssl了</h1>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven使用本地的jar包</title>
    <link href="/106157645.html"/>
    <url>/106157645.html</url>
    
    <content type="html"><![CDATA[<h1 id="maven使用本地的jar包"><a href="#maven使用本地的jar包" class="headerlink" title="maven使用本地的jar包"></a>maven使用本地的jar包</h1><hr><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><pre><code class="hljs">为了写这个网站后台，我把项目考在移动硬盘中拿回家继续写，结果maven引用的一个jar在公司maven私服里面，我自己电脑里没有。项目跑不起来。</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><pre><code class="hljs">机智的我，想起来连接公司服务器，从其他使用到这个jar的项目中获得到了jar包，可是怎么把这个jar安装到本地的maven中，并让我能够在idea中使用呢？？</code></pre><h2 id="配置mavne，下面拿mysql-连接驱动做讲解"><a href="#配置mavne，下面拿mysql-连接驱动做讲解" class="headerlink" title="配置mavne，下面拿mysql 连接驱动做讲解"></a>配置mavne，下面拿mysql 连接驱动做讲解</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>version<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>system<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">systemPath</span>&gt;</span>d:/mysql-connector.jar<span class="hljs-tag">&lt;/<span class="hljs-name">systemPath</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><pre><code class="hljs">也就是配置一个systemPath标签，值填本地jar包地址，就可以在idea中运行了</code></pre><h2 id="以上配置打包成war包是不会将本地jar-打包进去的，如果需要打包"><a href="#以上配置打包成war包是不会将本地jar-打包进去的，如果需要打包" class="headerlink" title="以上配置打包成war包是不会将本地jar 打包进去的，如果需要打包"></a>以上配置打包成war包是不会将本地jar 打包进去的，如果需要打包</h2><pre><code class="hljs">&lt;plugin&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;configuration&gt;&lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt;&lt;/configuration&gt;&lt;/plugin&gt;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot+idea 配置热部署</title>
    <link href="/4243760172.html"/>
    <url>/4243760172.html</url>
    
    <content type="html"><![CDATA[<h1 id="springboot-idea-配置热部署"><a href="#springboot-idea-配置热部署" class="headerlink" title="springboot+idea 配置热部署"></a>springboot+idea 配置热部署</h1><hr><h2 id="1-maven"><a href="#1-maven" class="headerlink" title="1.maven"></a>1.maven</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 热部署模块 --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="2-maven-插件"><a href="#2-maven-插件" class="headerlink" title="2.maven 插件"></a>2.maven 插件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">fork</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">fork</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="3-idea-设置"><a href="#3-idea-设置" class="headerlink" title="3.idea 设置"></a>3.idea 设置</h2><pre><code class="hljs">ctrl+alt+s 打开idea的设置，找到[Build，Execution,Deployment] - &gt; [Complier] -&gt; 打勾[Build project automatically]</code></pre><h2 id="4-idea设置"><a href="#4-idea设置" class="headerlink" title="4.idea设置"></a>4.idea设置</h2><pre><code class="hljs">ctrl+alt+shift+/, 打开的窗口选择第一项[Registry]找到[ compiler.automake.allow.when.app.running ] 后面打勾</code></pre><h2 id="5-debug模式下启动项目"><a href="#5-debug模式下启动项目" class="headerlink" title="5.debug模式下启动项目"></a>5.debug模式下启动项目</h2><pre><code class="hljs">不出意外，修改类会自动加载，并且速度非常快</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot单元测试 ，spring项目单元测试</title>
    <link href="/3302245890.html"/>
    <url>/3302245890.html</url>
    
    <content type="html"><![CDATA[<h1 id="springboot单元测试-，spring项目单元测试"><a href="#springboot单元测试-，spring项目单元测试" class="headerlink" title="springboot单元测试 ，spring项目单元测试"></a>springboot单元测试 ，spring项目单元测试</h1><h1 id="1-springboot"><a href="#1-springboot" class="headerlink" title="1.springboot"></a>1.springboot</h1><h2 id="添加maven"><a href="#添加maven" class="headerlink" title="添加maven"></a>添加maven</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="编写一个测试类，加上注解"><a href="#编写一个测试类，加上注解" class="headerlink" title="编写一个测试类，加上注解"></a>编写一个测试类，加上注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//启动类所在的class</span><br><span class="hljs-meta">@SpringBootTest(classes = DemoApplication.class)</span><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span>            <span class="hljs-comment">//固定的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><span class="hljs-comment">//注入需要用到的类</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> BingImageMapper bingImageMapper;<br><br><br><span class="hljs-comment">//测试执行的方法</span><br><span class="hljs-meta">@org</span>.junit.Test<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//可以正常使用</span><br>bingImageMapper.selectByPrimaryKey(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><pre><code class="hljs">直接执行test方法即可</code></pre><h1 id="2-spring"><a href="#2-spring" class="headerlink" title="2.spring"></a>2.spring</h1><h2 id="编写测试类继承-AbstractJUnit4SpringContextTests，并添加注解，将web-xml中配置的的配置文件也写在注解里"><a href="#编写测试类继承-AbstractJUnit4SpringContextTests，并添加注解，将web-xml中配置的的配置文件也写在注解里" class="headerlink" title="编写测试类继承 AbstractJUnit4SpringContextTests，并添加注解，将web.xml中配置的的配置文件也写在注解里"></a>编写测试类继承 <code>AbstractJUnit4SpringContextTests</code>，并添加注解，将<code>web.xml</code>中配置的的配置文件也写在注解里</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@ContextConfiguration(&#123;&quot;/applicationContext.xml&quot;,&quot;/testspring/applicationContext.xml&quot;,&quot;/dao-applicationContext-db.xml&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PointTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractJUnit4SpringContextTests</span>&#123;<br><span class="hljs-comment">//注入需要用到的类</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> BingImageMapper bingImageMapper;<br><br><span class="hljs-comment">//测试执行的方法</span><br><span class="hljs-meta">@org</span>.junit.Test<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><span class="hljs-comment">//可以正常使用</span><br>bingImageMapper.selectByPrimaryKey(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="如果有多个配置，全写进去"><a href="#如果有多个配置，全写进去" class="headerlink" title="如果有多个配置，全写进去"></a>如果有多个配置，全写进去</h2>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>让网站支持markdown 语法，让代码高亮</title>
    <link href="/2418605146.html"/>
    <url>/2418605146.html</url>
    
    <content type="html"><![CDATA[<h1 id="让网站支持markdown-语法，让代码高亮"><a href="#让网站支持markdown-语法，让代码高亮" class="headerlink" title="让网站支持markdown 语法，让代码高亮"></a>让网站支持markdown 语法，让代码高亮</h1><hr><h2 id="需要引入的文件和作用"><a href="#需要引入的文件和作用" class="headerlink" title="需要引入的文件和作用"></a>需要引入的文件和作用</h2><table><thead><tr><th>文件</th><th>作用</th></tr></thead><tbody><tr><td>shoudowm.js</td><td>将markdown文本转成html</td></tr><tr><td>github-markdown.min.css</td><td>将转成html格式的文章美化</td></tr><tr><td>highlight.pack.js</td><td>将转成html格式的文本中的代码进行分析语言，转格式</td></tr><tr><td>highlight.css</td><td>美化文章中的代码段</td></tr></tbody></table><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><pre><code class="hljs">假设文章是通过ajax 动态获取的，我用的axios。</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//创建showdowm转换器，将后台获取到的markdown文本转成html</span><br><span class="hljs-keyword">var</span> content = <span class="hljs-keyword">new</span> showdown.<span class="hljs-title class_">Converter</span>(&#123;<span class="hljs-attr">tables</span>: <span class="hljs-literal">true</span>&#125;).<span class="hljs-title function_">makeHtml</span>(value.<span class="hljs-property">content</span>);<br><br><span class="hljs-comment">//这里将转换成的html代码段插入页面中，相当于原生js的 innerHTML </span><br>self.<span class="hljs-property">content</span> = content；<br><span class="hljs-comment">//注意需要将插入点元素的class设置成‘markdown-body’，这样github-markdown.min.css才能渲染它</span><br><br><br></code></pre></td></tr></table></figure><pre><code class="hljs">理论上经过上面很简单的两步就可以在页面上看到格式良好的页面了，但是代码块没有高亮显示。</code></pre><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><pre><code class="hljs">f12观察一下，代码块被包裹在&lt;per&gt;&lt;&gt;code&gt;代码&lt;/code&gt;&lt;/per&gt;中，我们需要另一个工具将其中的代码提取出来，分析出语言，添加不同的css样式</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//因为前面已经引入了 highlight.pack.js 和 highlight.css（这个css可以替换，或者自己修改出喜欢的风格）。</span><br>这里待页面文章插入成功执行<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;pre code&#x27;</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">block</span>) &#123;<br>                    hljs.<span class="hljs-title function_">highlightBlock</span>(block);<br>                       &#125;);<br><br><span class="hljs-comment">//也就是选择出页面上的‘pre code’ 调用highlightBlock方法，这个方法由highlight 提供，全自动识别代码类型，高亮显示。高亮规则在css中可调节。</span><br><br><br></code></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><pre><code class="hljs">由于用的vue axios，动态加载的文章，所以在axios请求回调函数中进行操作。转换markdown文本，插入页面，调用页面高亮方法，一气呵成。但是vue插入页面是异步执行的，在运行代码高亮代码时页面上还不存在&#39;pre code&#39;,导致无法将代码高亮显示。这里有两个方法可供选择。1.setTimeout，延迟100毫秒再去操作2.使用vue的nextTick进行操作，nextTick用法自行查询，它的作用就是在页面的渲染完成后才会去执行里面的方法，这样就不会找不到元素了。</code></pre><h2 id="资源地址"><a href="#资源地址" class="headerlink" title="资源地址"></a>资源地址</h2><p><a href="https://github.com/showdownjs/showdown">Showdown Github</a></p><p><a href="https://github.com/sindresorhus/github-markdown-css#readme">Github-markdown-css Github</a></p><p><a href="https://highlightjs.org/">highlightjs官网,css也在官网能下载到</a></p><p><a href="https://github.com/highlightjs/highlight.js">highlightjs Github</a></p><pre><code class="hljs">因为世界上语言众多，如果全集中在一个css中，太大了。官网采用定制的方式，需要哪种语言的代码高亮，就选择哪种语言的。可以根据自己需求定制。定制完成后下载下来的文件style目录下有很多风格不同的代码css，都可以尝试一下。如果不满意可以自行修改</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 设置开机自启</title>
    <link href="/1981756926.html"/>
    <url>/1981756926.html</url>
    
    <content type="html"><![CDATA[<p>写一个sh脚本放到 <code>/etc/init.d</code> 目录下，开机会执行这里面的命令。</p><p>如果想每次登陆都执行一次，放入<code>/etc/profile.d</code>目录下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>linux开机自启</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好，世界</title>
    <link href="/2901793364.html"/>
    <url>/2901793364.html</url>
    
    <content type="html"><![CDATA[<p>今天是 2019-05-26</p>]]></content>
    
    
    
    <tags>
      
      <tag>diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
