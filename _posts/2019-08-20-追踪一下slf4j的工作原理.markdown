---
layout:     post
title:      "追踪一下slf4j的工作原理"
subtitle:   ""
date:       2019-08-20
author:     "hcy"
header-img: "img/gene-head-img.jpg"
tags:
    - java
---


## 追踪一下slf4j的工作原理


	slf4j 是一个java界非常流行的日志门面框架，使用它，你可以任意更换底层实现如logback，		log4j，而不需要修改任何代码。那他是如何做到的呢，女朋友有这样的疑问，就要给她讲清楚。

* ### 首先引入slf4j的包，这里采用最新稳定版,因为只引入slf4j无法打印日志，这里选择logback作为底层实现，测试

```
<dependency>
   <groupId>org.slf4j</groupId>
   <artifactId>slf4j-api</artifactId>
   <version>1.7.28</version>
</dependency>

<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.2.3</version>
</dependency>
```

* ###程序使用方式如下

```
	public static void main(String[] args) {
		Logger log = LoggerFactory.getLogger(T1.class);
		log.info("info");
		log.debug("debug");
		log.warn("warn");
	}

```
	slf4j获取到的Logger对象，是从LoggerFactory中得到，所以存在不同类型的Logger类，就存在不同类型的LoggerFactory对象
	进入LoggerFactory.getLogger(T1.class)方法，我们看到其获取class名，调用了重载的getLogger(String )方法
	获取了 ILoggerFactory，从factory中得到Logger并返回的

```
	public static Logger getLogger(Class<?> clazz) {
        Logger logger = getLogger(clazz.getName());
   	    return logger;
    }

	public static Logger getLogger(String name) {
   	 ILoggerFactory iLoggerFactory = getILoggerFactory();
   	 return iLoggerFactory.getLogger(name);
	}
	
	
	/*
		判断状态位 INITIALIZATION_STATE，状态位共五种状态
			UNINITIALIZED   尚未初始化
			SUCCESSFUL_INITIALIZATION  成功初始化
			NOP_FALLBACK_INITIALIZATION 无底层实现类
			FAILED_INITIALIZATION  初始化报错
			ONGOING_INITIALIZATION  初始化中
	*/

    public static ILoggerFactory getILoggerFactory() {
		//这里类似懒汉单例模式，加锁后设置状态位为ONGOING_INITIALIZATION，然后调用初始化代码，这样就只能有一个线程会初始化loggerfactory，其他线程走下面的switch 中的ONGOING_INITIALIZATION。
        if (INITIALIZATION_STATE == UNINITIALIZED) {
            synchronized (LoggerFactory.class) {
                if (INITIALIZATION_STATE == UNINITIALIZED) {
                    INITIALIZATION_STATE = ONGOING_INITIALIZATION;
                    performInitialization();
                }
            }
        }
        switch (INITIALIZATION_STATE) {
        case SUCCESSFUL_INITIALIZATION:
            return StaticLoggerBinder.getSingleton().getLoggerFactory();
        case NOP_FALLBACK_INITIALIZATION:
            return NOP_FALLBACK_FACTORY;
        case FAILED_INITIALIZATION:
            throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);
        case ONGOING_INITIALIZATION:
            // support re-entrant behavior.
            // See also http://jira.qos.ch/browse/SLF4J-97
            return SUBST_FACTORY;
        }
        throw new IllegalStateException("Unreachable code");
    }
	

	//这里的INITIALIZATION_STATE的定义，其加了volatile关键字，多线程修改他时，能立刻被看到
 	static volatile int INITIALIZATION_STATE = UNINITIALIZED;

```

	从上面的getILoggerFactory() 方法中可以看到，获取分五种状态，
	1.如果第一次访问，为未初始化状态，UNINITIALIZED，则让第一个获得锁的进行初始化，且不会堵塞后来的线程。
	2.如果初始化成功，SUCCESSFUL_INITIALIZATION，后来的线程可以直接从StaticLoggerBinder中获取loggerFactory
	3.如果没有实现类，NOP_FALLBACK_INITIALIZATION，则返回NOP_FALLBACK_FACTORY
	4.如果初始化报错了，FAILED_INITIALIZATION，则直接抛出异常，阻止程序继续执行
	54如果正在初始化中ONGOING_INITIALIZATION，则返回一个临时的loggerFactory，他会把所有的logger记录在队列中，等待真正初始化完成后，用真实的logger把队列中的日志输出出来


```
	//初始化中时，返回的临时loggerfactory
	static final SubstituteLoggerFactory SUBST_FACTORY = new SubstituteLoggerFactory();

	//SubstituteLoggerFactory的getLogger方法

    synchronized public  Logger getLogger(String name) {
        SubstituteLogger logger = loggers.get(name);
        if (logger == null) {
            logger = new SubstituteLogger(name, eventQueue, postInitialization);
            loggers.put(name, logger);
        }
        return logger;
    }

```
	上面可以看到，这个临时的loggerFactory即SubstituteLoggerFactory，他的getLogger(String name)方法会首先使用
	SubstituteLogger logger = loggers.get(name);
	从loggers中获取，loggers为一个Map<String,Logger>，用于缓存创建的SubstituteLogger
	如果为空则创建一个SubstituteLogger，并放进map中
	创建new SubstituteLogger时，传递的参数是Logger的名字，LinkedBlockingQueue的队列，postInitialization是否初始化完成的标志位


```
	//SubstituteLogger的info方法，是如何实现的
	
	private volatile Logger _delegate;
	private final boolean createdPostInitialization;
   

	public void info(String msg) {
        delegate().info(msg);
    }

    Logger delegate() {
        if(_delegate != null) {
            return _delegate;
        }
        if(createdPostInitialization) {
            return NOPLogger.NOP_LOGGER;
        } else {
            return getEventRecordingLogger();
        }
    }

    private Logger getEventRecordingLogger() {
        if (eventRecodingLogger == null) {
            eventRecodingLogger = new EventRecodingLogger(this, eventQueue);
        }
        return eventRecodingLogger;
    }

```

	可以看出，SubstituteLogge会将所有的日志，委托给delegate()返回的Logger处理，
	delegate()方法，如果存在被代理的_delegate，则返回_delegate，
	如果已经标志位为true了，则返回一个nopLogger，否则返回一个EventRecodingLogger，
	nopLogger 会扔掉所有的日志
	EventRecodingLogger会将所有日志放入queue中存储起来，等待其他方法将存储的日志重新拿出来输出
	这就是slf4j初始化过程中返回的临时Logger，其在真实logger没创建完成时，返回带队列存储功能的临时logger，
	等到真实logger创建完成后_delegate变量被设置为真实logger，delegate（）方法会返回真实logger，从而后续输出都会被转发到真实logger中。

* ### loggerFactory初始化过程

```
		//未初始化前，会加锁并修改状态，并调用performInitialization（）；
        if (INITIALIZATION_STATE == UNINITIALIZED) {
            synchronized (LoggerFactory.class) {
                if (INITIALIZATION_STATE == UNINITIALIZED) {
                    INITIALIZATION_STATE = ONGOING_INITIALIZATION;
                    performInitialization();
                }
            }
        }

	//这个方法调用 bind()
    private final static void performInitialization() {
        bind();
        if (INITIALIZATION_STATE == SUCCESSFUL_INITIALIZATION) {
            versionSanityCheck();
        }
    }


 private final static void bind() {
        try {
			//获取实现类集合，就是用类加载器加载名称叫做 ‘org/slf4j/impl/StaticLoggerBinder.class’的类，这个字符串是写死在代码里的
            Set<URL> staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();
        	//调用实现类的初始化方法，进行初始化
            StaticLoggerBinder.getSingleton();
			//修改状态位为success
            INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;
			//将SubstituteLoggerFactory的loggers（map）存储的临时logger获取出来，设置临时logger中的_delegate变量为真实logger
            fixSubstituteLoggers();
			//从队列中取出日志，用真实logger输出
            replayEvents();
            // 清理SubstituteLoggerFactory 内map中存储的logger，清理队列
            SUBST_FACTORY.clear();
        } catch (NoClassDefFoundError ncde) {
			//如果报NoClassDefFoundError，可能是没有任何实现类，这时将状态位设为NOP_FALLBACK_INITIALIZATION
            String msg = ncde.getMessage();
            if (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) {
                INITIALIZATION_STATE = NOP_FALLBACK_INITIALIZATION;
            } else {
                failedBinding(ncde);
                throw ncde;
            }
		//如果报NoSuchMethodError，可能是底层实现类没有按照要求实现，将状态位设为FAILED_INITIALIZATION
        } catch (java.lang.NoSuchMethodError nsme) {
            String msg = nsme.getMessage();
            if (msg != null && msg.contains("org.slf4j.impl.StaticLoggerBinder.getSingleton()")) {
                INITIALIZATION_STATE = FAILED_INITIALIZATION;
            }
            throw nsme;
        } catch (Exception e) {
            failedBinding(e);
            throw new IllegalStateException("Unexpected initialization failure", e);
        }
    }
```

## 总结

	总结下就是，slf4j在第一次获取logger时进行初始化，并通过写死的字符串‘org/slf4j/impl/StaticLoggerBinder.class’尝试查找真实实现类，再调用真实实现类的静态方法，进行初始化。
	再初始化没完成之前，会返回一个会存储在队列中的代理logger，等到真实logger创建完成后，会取出队列中的日志，重新打印出来，并且该代理logger会将以后的日志转发给真实logger中。
	如果不存在slf4j的具体实现类，则会返回一个nop_logger，这个Logger不处理任何日志，将日志丢弃，但不影响程序运行。


## 一个bug
	如果不存在任何slf4j真实实现的情况下，多线程同时获取logger，后面的可能会获取到SubstituteLogger，这个Logger会将所有日志放入队列中，等待真实logger创建完成，但不存在真实实现就永远不会完成，所以此时获取的logger会一直将日志放入queue中，日志过多的话可能导致oom