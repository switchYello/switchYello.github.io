---
layout:     post
title:      "java hkdf算法生成密钥"
subtitle:   ""
date:       2019-11-28
author:     "hcy"
header-img: "img/gene-head-img.jpg"
tags:
    - netty
    - java加密解密
---


### hkdf算法包含两部分，‘提取’ 和 ‘扩展’来生成任意长度的，更随机的密码

##### 首先介绍生成密码需要的元素

名称|类型|例子|说明
-|-|-|-|-
password|byte[]|"abc".getBytes()|用户输入的密码
salt|byte[]|new byte[]{1,5,7,6,41,85,63,7,89}|用于提取密码
info|byte[]|"product-info".getByte()|使生成密码更随机
length|int|64|希望生成的密钥长度


##### 1.提取

	prk = hkdfExtract（salt,password）

```
    private static byte[] hkdfExtract(byte[] salt, byte[] passsword) throws NoSuchAlgorithmException, InvalidKeyException {
        Mac mac = Mac.getInstance("HmacSHA1");
        SecretKeySpec keySpec = new SecretKeySpec(salt, "HmacSHA1");
        mac.init(keySpec);
        return mac.doFinal(passsword);
    }

```

上面的意思就是用salt做密钥使用sha算法对password进行摘要得到的结果作为提取的结果prk


##### 2.扩展

	key = hkdfExpand(prk,info,length)

	具体逻辑,伪代码
	
```
result = new byte[length];//保存生成的结果 ，长度等于参数指定的长度
byte t = 1； //设置一个递增的byte变量，从1开始 
digest=new byte[0] 

Mac sha = Mac.getInstance("HmacSHA1");//使用第一步生成的prk，初始化一个sha1
sha.init(prk);

whilt(true){
	sha.update(digest) //sha算法分别摘要，digest，info，t，得到的结果保存在digest中
	sha.update(info)
	sha.update(t)
	digest = sha.doFinal();
	t++；
	result+=digest; 
}



```
		
这里的意思是，以上一步生成的prk作为sha的密钥，对digtest、info、t进行摘要，将摘要结果保存在result中，
比如sha1每次摘要结果长度是20，如果参数length >20 则再次对digtest、info、t摘要，将结果叠加进去
注意第二次的digtest为上一次摘要的结果，t也递增了，最终获得的长度将大于length，取前length个作为hkdf的返回值

```
    //扩展 key = Expand(prk,info,length)
    private static byte[] hkdfExpand(byte[] prk, byte[] info, int length) throws NoSuchAlgorithmException, InvalidKeyException {
        Mac mac = Mac.getInstance("HmacSHA1");
        SecretKeySpec keySpec = new SecretKeySpec(prk, "HmacSHA1");
        mac.init(keySpec);
        byte[] result = new byte[length];
        int pos = 0;
        byte[] digest = new byte[0];
        byte t = 1;
        while (pos < result.length) {
            mac.update(digest);
            mac.update(info);
            mac.update(t);
            digest = mac.doFinal();
            System.arraycopy(digest, 0, result, pos, Math.min(digest.length, length - pos));
            pos += digest.length;
            t++;
        }
        return result;
    }

```
	



##### 3.调用
```
public static byte[] createHkdfKey(String password, byte[] salt, int keySize) throws GeneralSecurityException {
	//第一步先提取，得到prk    
	byte[] prk = hkdfExtract(salt, passwoed.getBytes());
	//第二步，扩展    
	return hkdfExpand(prk, info, keySize);
}

```

##### 4.总结

	总之hkdf算法还是比较简单的，且可以生成任意长度的密钥，可以搭配其他的摘要算法如hkdfSha1，hkdfSha256，hkdfMd5
	都是可以的